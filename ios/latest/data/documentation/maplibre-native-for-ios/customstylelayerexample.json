{"abstract":[{"type":"text","text":"Creating a Custom Style Layer with Metal"}],"sections":[],"schemaVersion":{"major":0,"patch":0,"minor":3},"metadata":{"title":"Custom Style Layers (Metal API)","modules":[{"name":"MapLibre"}],"role":"article","roleHeading":"Article"},"hierarchy":{"paths":[["doc:\/\/org.swift.MyProject\/documentation\/MapLibre"]]},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Custom style layers allow you to draw directly with Metal, enabling you to render specialized shapes, custom geometry, or apply advanced visual effects that go beyond what is possible with standard style layers.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Below you can find an example of how to create a custom style layer with "},{"type":"reference","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer","isActive":true},{"text":". In this implementation, a SwiftUI view wraps an ","type":"text"},{"identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNMapView","type":"reference","isActive":true},{"type":"text","text":" and appends a subclassed custom style layer once the map loads. The layer’s "},{"type":"reference","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/didMoveToMapView:","isActive":true},{"text":" method handles initialization, including compiling Metal shaders and creating a ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrenderpipelinestate?language=objc","isActive":true},{"text":" for subsequent draw operations. The ","type":"text"},{"identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/willMoveFromMapView:","isActive":true,"type":"reference"},{"type":"text","text":" method provides a place to release or invalidate resources when the layer is removed from the map, while the "},{"type":"reference","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/drawInMapView:withContext:","isActive":true},{"text":" method encodes the drawing commands using a ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrendercommandencoder","isActive":true},{"type":"text","text":" and the map’s projection matrix. By projecting latitude\/longitude coordinates into a normalized 0–1 space and then transforming them into tile coordinates, the layer ensures that rendered geometry aligns correctly with the base map."}]},{"inlineContent":[{"type":"image","identifier":"CustomStyleLayerExample.png"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct CustomStyleLayerExample: UIViewRepresentable {","    func makeCoordinator() -> CustomStyleLayerExample.Coordinator {","        Coordinator(self)","    }","","    final class Coordinator: NSObject, MLNMapViewDelegate {","        var control: CustomStyleLayerExample","","        init(_ control: CustomStyleLayerExample) {","            self.control = control","        }","","        func mapViewDidFinishLoadingMap(_ mapView: MLNMapView) {","            let mapOverlay = CustomStyleLayer(identifier: \"test-overlay\")","            let style = mapView.style!","            style.layers.append(mapOverlay)","        }","    }","","    func makeUIView(context: Context) -> MLNMapView {","        let mapView = MLNMapView()","        mapView.delegate = context.coordinator","        return mapView","    }","","    func updateUIView(_: MLNMapView, context _: Context) {}","}","","class CustomStyleLayer: MLNCustomStyleLayer {","    private var pipelineState: MTLRenderPipelineState?","    private var depthStencilStateWithoutStencil: MTLDepthStencilState?","","    override func didMove(to mapView: MLNMapView) {","        #if MLN_RENDER_BACKEND_METAL","            let resource = mapView.backendResource()","","            let shaderSource = \"\"\"","            #include <metal_stdlib>","            using namespace metal;","","            typedef struct","            {","               vector_float2 position;","               vector_float4 color;","            } Vertex;","","            struct RasterizerData","            {","               float4 position [[position]];","               float4 color;","            };","","            struct Uniforms","            {","               float4x4 matrix;","            };","","            vertex RasterizerData","            vertexShader(uint vertexID [[vertex_id]],","                        constant Vertex *vertices [[buffer(0)]],","                        constant Uniforms &uniforms [[buffer(1)]])","            {","               RasterizerData out;","","               const float4 position = uniforms.matrix * float4(float2(vertices[vertexID].position.xy), 1, 1);","","               out.position = position;","               out.color = vertices[vertexID].color;","","               return out;","            }","","            fragment float4 fragmentShader(RasterizerData in [[stage_in]])","            {","               return in.color;","            }","            \"\"\"","","            var error: NSError?","            let device = resource.device","            let library = try? device?.makeLibrary(source: shaderSource, options: nil)","            assert(library != nil, \"Error compiling shaders: \\(String(describing: error))\")","            let vertexFunction = library?.makeFunction(name: \"vertexShader\")","            let fragmentFunction = library?.makeFunction(name: \"fragmentShader\")","","            \/\/ Configure a pipeline descriptor that is used to create a pipeline state.","            let pipelineStateDescriptor = MTLRenderPipelineDescriptor()","            pipelineStateDescriptor.label = \"Simple Pipeline\"","            pipelineStateDescriptor.vertexFunction = vertexFunction","            pipelineStateDescriptor.fragmentFunction = fragmentFunction","            pipelineStateDescriptor.colorAttachments[0].pixelFormat = resource.mtkView.colorPixelFormat","            pipelineStateDescriptor.depthAttachmentPixelFormat = .depth32Float_stencil8","            pipelineStateDescriptor.stencilAttachmentPixelFormat = .depth32Float_stencil8","","            do {","                pipelineState = try device?.makeRenderPipelineState(descriptor: pipelineStateDescriptor)","            } catch {","                assertionFailure(\"Failed to create pipeline state: \\(error)\")","            }","","            \/\/ Notice that we don't configure the stencilTest property, leaving stencil testing disabled","            let depthStencilDescriptor = MTLDepthStencilDescriptor()","            depthStencilDescriptor.depthCompareFunction = .always \/\/ Or another value as needed","            depthStencilDescriptor.isDepthWriteEnabled = false","","            depthStencilStateWithoutStencil = device!.makeDepthStencilState(descriptor: depthStencilDescriptor)","        #endif","    }","","    override func willMove(from _: MLNMapView) {}","","    override func draw(in _: MLNMapView, with context: MLNStyleLayerDrawingContext) {","        #if MLN_RENDER_BACKEND_METAL","            guard let renderEncoder else { return }","","            \/\/ Project to 0..1.","            let p1 = project(CLLocationCoordinate2D(latitude: 25.0, longitude: 12.5))","            let p2 = project(CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0))","            let p3 = project(CLLocationCoordinate2D(latitude: 0.0, longitude: 25.0))","","            \/\/ Multiply by the world size so it becomes the tile coordinate system.","            let worldSize = 512.0 * pow(2.0, context.zoomLevel)","","            let p1Tile = CGPoint(x: p1.x * worldSize, y: p1.y * worldSize)","            let p2Tile = CGPoint(x: p2.x * worldSize, y: p2.y * worldSize)","            let p3Tile = CGPoint(x: p3.x * worldSize, y: p3.y * worldSize)","","            \/\/ Then build a triangle from tile coordinates","            struct Vertex { var position: vector_float2; var color: vector_float4 }","            let triangleVertices: [Vertex] = [","                Vertex(position: vector_float2(Float(p1Tile.x), Float(p1Tile.y)),","                       color: vector_float4(1, 0, 0, 1)),","                Vertex(position: vector_float2(Float(p2Tile.x), Float(p2Tile.y)),","                       color: vector_float4(0, 1, 0, 1)),","                Vertex(position: vector_float2(Float(p3Tile.x), Float(p3Tile.y)),","                       color: vector_float4(0, 0, 1, 1)),","            ]","","            \/\/ Use the camera's full projection matrix *unchanged*.","            var matrix = convertMatrix(context.projectionMatrix)","","            \/\/ Encode","            renderEncoder.setRenderPipelineState(pipelineState!)","            renderEncoder.setDepthStencilState(depthStencilStateWithoutStencil)","            renderEncoder.setVertexBytes(triangleVertices, length: MemoryLayout<Vertex>.size * triangleVertices.count, index: 0)","            renderEncoder.setVertexBytes(&matrix, length: MemoryLayout<float4x4>.size, index: 1)","","            \/\/ Draw the triangle.","            renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)","        #endif","    }","","    func project(_ coordinate: CLLocationCoordinate2D) -> CGPoint {","        \/\/ We project the coordinates into the space 0 to 1 and then scale these when drawing based on the current zoom level","        let worldSize = 1.0","        let x = (180.0 + coordinate.longitude) \/ 360.0 * worldSize","        let yi = log(tan((45.0 + coordinate.latitude \/ 2.0) * Double.pi \/ 180.0))","        let y = (180.0 - yi * (180.0 \/ Double.pi)) \/ 360.0 * worldSize","","        return CGPoint(x: x, y: y)","    }","","    struct MLNMatrix4f {","        var m00, m01, m02, m03: Float","        var m10, m11, m12, m13: Float","        var m20, m21, m22, m23: Float","        var m30, m31, m32, m33: Float","    }","","    func convertMatrix(_ mat: MLNMatrix4) -> MLNMatrix4f {","        MLNMatrix4f(","            m00: Float(mat.m00), m01: Float(mat.m01), m02: Float(mat.m02), m03: Float(mat.m03),","            m10: Float(mat.m10), m11: Float(mat.m11), m12: Float(mat.m12), m13: Float(mat.m13),","            m20: Float(mat.m20), m21: Float(mat.m21), m22: Float(mat.m22), m23: Float(mat.m23),","            m30: Float(mat.m30), m31: Float(mat.m31), m32: Float(mat.m32), m33: Float(mat.m33)","        )","    }","}"]}],"kind":"content"}],"kind":"article","seeAlsoSections":[{"identifiers":["doc:\/\/org.swift.MyProject\/documentation\/MapLibre-Native-for-iOS\/RenderingStatisticsHud","doc:\/\/org.swift.MyProject\/documentation\/MapLibre-Native-for-iOS\/PluginLayers"],"title":"Advanced","generated":true}],"identifier":{"interfaceLanguage":"occ","url":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre-Native-for-iOS\/CustomStyleLayerExample"},"variants":[{"paths":["\/documentation\/maplibre-native-for-ios\/customstylelayerexample"],"traits":[{"interfaceLanguage":"occ"}]}],"references":{"doc://org.swift.MyProject/documentation/MapLibre/MLNCustomStyleLayer/willMoveFromMapView:":{"role":"symbol","url":"\/documentation\/maplibre\/mlncustomstylelayer\/willmovefrommapview:","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/willMoveFromMapView:","type":"topic","kind":"symbol","title":"willMoveFromMapView:","fragments":[{"text":"- ","kind":"text"},{"kind":"identifier","text":"willMoveFromMapView:"}],"abstract":[{"text":"Called immediately before a layer is removed from a map view’s style.","type":"text"}],"navigatorTitle":[{"text":"willMoveFromMapView:","kind":"identifier"}]},"doc://org.swift.MyProject/documentation/MapLibre/MLNCustomStyleLayer/didMoveToMapView:":{"role":"symbol","url":"\/documentation\/maplibre\/mlncustomstylelayer\/didmovetomapview:","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/didMoveToMapView:","type":"topic","kind":"symbol","title":"didMoveToMapView:","fragments":[{"text":"- ","kind":"text"},{"kind":"identifier","text":"didMoveToMapView:"}],"abstract":[{"type":"text","text":"Called immediately after a layer is added to a map view’s style."}],"navigatorTitle":[{"kind":"identifier","text":"didMoveToMapView:"}]},"doc://org.swift.MyProject/documentation/MapLibre/MLNCustomStyleLayer/drawInMapView:withContext:":{"kind":"symbol","type":"topic","url":"\/documentation\/maplibre\/mlncustomstylelayer\/drawinmapview:withcontext:","fragments":[{"text":"- ","kind":"text"},{"text":"drawInMapView:withContext:","kind":"identifier"}],"identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer\/drawInMapView:withContext:","title":"drawInMapView:withContext:","role":"symbol","abstract":[{"text":"Called each time the layer needs to draw a new frame in a map view.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"drawInMapView:withContext:"}]},"doc://org.swift.MyProject/documentation/MapLibre":{"title":"MapLibre","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre","url":"\/documentation\/maplibre","type":"topic","kind":"symbol","role":"collection","abstract":[{"type":"text","text":"Powerful, free and open-source mapping toolkit with full control over data sources and styling."}]},"doc://org.swift.MyProject/documentation/MapLibre-Native-for-iOS/RenderingStatisticsHud":{"role":"article","title":"Rendering Statistics HUD","abstract":[{"text":"Show rendering statistics on the map","type":"text"}],"kind":"article","url":"\/documentation\/maplibre-native-for-ios\/renderingstatisticshud","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre-Native-for-iOS\/RenderingStatisticsHud","type":"topic"},"doc://org.swift.MyProject/documentation/MapLibre-Native-for-iOS/PluginLayers":{"url":"\/documentation\/maplibre-native-for-ios\/pluginlayers","role":"article","title":"Plugin Layers","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre-Native-for-iOS\/PluginLayers","kind":"article","type":"topic","abstract":[{"text":"Plugin Layers are a way to add layer types that render themselves into the style parsing engine at runtime.  It is a way to dynamically link new layer types to the MapLibre core – and styling language – without having to compile them into the library itself.","type":"text"}]},"CustomStyleLayerExample.png":{"alt":null,"type":"image","variants":[{"traits":["2x","light"],"url":"\/images\/CustomStyleLayerExample@2x.png"}],"identifier":"CustomStyleLayerExample.png"},"doc://org.swift.MyProject/documentation/MapLibre/MLNMapView":{"title":"MLNMapView","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNMapView","kind":"symbol","url":"\/documentation\/maplibre\/mlnmapview","type":"topic","role":"symbol","abstract":[{"type":"text","text":"An interactive, customizable map view with an interface similar to the one"},{"text":" ","type":"text"},{"type":"text","text":"provided by Apple’s MapKit."}],"fragments":[{"text":"MLNMapView","kind":"identifier"}]},"https://developer.apple.com/documentation/metal/mtlrenderpipelinestate?language=objc":{"title":"MTLRenderPipelineState","identifier":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrenderpipelinestate?language=objc","url":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrenderpipelinestate?language=objc","titleInlineContent":[{"code":"MTLRenderPipelineState","type":"codeVoice"}],"type":"link"},"doc://org.swift.MyProject/documentation/MapLibre/MLNCustomStyleLayer":{"role":"symbol","url":"\/documentation\/maplibre\/mlncustomstylelayer","identifier":"doc:\/\/org.swift.MyProject\/documentation\/MapLibre\/MLNCustomStyleLayer","type":"topic","kind":"symbol","title":"MLNCustomStyleLayer","fragments":[{"text":"MLNCustomStyleLayer","kind":"identifier"}],"abstract":[{"text":"A style layer that is rendered by Metal code that you provide.","type":"text"}]},"https://developer.apple.com/documentation/metal/mtlrendercommandencoder":{"title":"MTLRenderCommandEncoder","url":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrendercommandencoder","type":"link","titleInlineContent":[{"code":"MTLRenderCommandEncoder","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/metal\/mtlrendercommandencoder"}}}