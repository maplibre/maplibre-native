{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MapLibre Android Examples","text":"<p>Welcome to the examples documentation of MapLibre Android.</p> <ul> <li> <p> Quickstart</p> <p>Learn how to include MapLibre Android in your project</p> <p> Getting started</p> </li> <li> <p> Find us on Slack</p> <p>Discuss the project and ask questions in the <code>#maplibre-android</code> channel</p> <p> Slack</p> </li> <li> <p> Contribute to these Docs</p> <p>Share your own examples with the community!</p> <p> Documentation on GitHub</p> </li> </ul>"},{"location":"#open-source-apps-using-maplibre-android","title":"Open-Source Apps Using MapLibre Android","text":"<p>You can learn how to use the API from MapLibre Android by stuying the source code of existing apps that intergrate MapLibre Android. Here are some open-source apps that use MapLibre Android:</p> <ul> <li>Streetcomplete (source code)</li> <li>The official Wikipedia app for Android (source code).</li> <li>MapLibreAndroidTestApp. This app is part of the MapLibre Native repository and is used for (automated) testing. Many of the examples in this documentation site come directly from this app.</li> </ul>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>MapLibre Android API Documentation</li> <li>Source code on GitHub</li> <li>Latest releases</li> <li>GitHub Discussions</li> <li>MapLibre on Slack. Join the <code>#maplibre-native</code> and <code>#maplibre-android</code> channels.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This guide will explain various ways to create a map.</p> <p>When working with maps, you likely want to configure the <code>MapView</code>.</p> <p>There are several ways to build a <code>MapView</code>:</p> <ol> <li>Using existing XML namespace tags for<code>MapView</code> in the layout.</li> <li>Creating <code>MapLibreMapOptions</code> and passing builder function values into the <code>MapView</code>.</li> <li>Creating a <code>SupportMapFragment</code> with the help of <code>MapLibreMapOptions</code>.</li> </ol> <p>Before diving into <code>MapView</code> configurations, let's understand the capabilities of both XML namespaces and <code>MapLibreMapOptions</code>.</p> <p>Here are some common configurations you can set:</p> <ul> <li>Map base URI</li> <li>Camera settings</li> <li>Zoom level</li> <li>Pitch</li> <li>Gestures</li> <li>Compass</li> <li>Logo</li> <li>Attribution</li> <li>Placement of the above elements on the map and more</li> </ul> <p>We will explore how to achieve these configurations in XML layout and programmatically in Activity code, step by step.</p>"},{"location":"configuration/#mapview-configuration-with-an-xml-layout","title":"<code>MapView</code> Configuration with an XML layout","text":"<p>To configure <code>MapView</code> within an XML layout, you need to use the right namespace and provide the necessary data in the layout file.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".activity.options.MapOptionsXmlActivity\"&gt;\n\n    &lt;org.maplibre.android.maps.MapView\n        android:id=\"@+id/mapView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:maplibre_apiBaseUri=\"https://api.maplibre.org\"\n        app:maplibre_cameraBearing=\"0.0\"\n        app:maplibre_cameraPitchMax=\"90.0\"\n        app:maplibre_cameraPitchMin=\"0.0\"\n        app:maplibre_cameraTargetLat=\"42.31230486601532\"\n        app:maplibre_cameraTargetLng=\"64.63967338936439\"\n        app:maplibre_cameraTilt=\"0.0\"\n        app:maplibre_cameraZoom=\"3.9\"\n        app:maplibre_cameraZoomMax=\"26.0\"\n        app:maplibre_cameraZoomMin=\"2.0\"\n        app:maplibre_localIdeographFontFamilies=\"@array/array_local_ideograph_family_test\"\n        app:maplibre_localIdeographFontFamily=\"Droid Sans\"\n        app:maplibre_uiCompass=\"true\"\n        app:maplibre_uiCompassFadeFacingNorth=\"true\"\n        app:maplibre_uiCompassGravity=\"top|end\"\n        app:maplibre_uiDoubleTapGestures=\"true\"\n        app:maplibre_uiHorizontalScrollGestures=\"true\"\n        app:maplibre_uiRotateGestures=\"true\"\n        app:maplibre_uiScrollGestures=\"true\"\n        app:maplibre_uiTiltGestures=\"true\"\n        app:maplibre_uiZoomGestures=\"true\" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre> <p>This can be found in <code>activity_map_options_xml.xml</code>.</p> <p>You can assign any other existing values to the <code>maplibre...</code> tags. Then, you only need to create <code>MapView</code> and <code>MapLibreMap</code> objects with a simple setup in the Activity.</p> MapOptionsXmlActivity.kt<pre><code>package org.maplibre.android.testapp.activity.options\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.OnMapReadyCallback\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/**\n *  TestActivity demonstrating configuring MapView with XML\n */\n\nclass MapOptionsXmlActivity : AppCompatActivity(), OnMapReadyCallback {\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_options_xml)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync(this)\n    }\n\n    override fun onMapReady(maplibreMap: MapLibreMap) {\n        this.maplibreMap = maplibreMap\n        this.maplibreMap.setStyle(\"https://demotiles.maplibre.org/style.json\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n}\n</code></pre> <p>This can be found in <code>MapOptionsXmlActivity.kt</code>.</p>"},{"location":"configuration/#mapview-configuration-with-maplibremapoptions","title":"<code>MapView</code> configuration with <code>MapLibreMapOptions</code>","text":"<p>Here we don't have to create MapView from XML since we want to create it programmatically. <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;FrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"/&gt;\n</code></pre></p> <p>This can be found in <code>activity_map_options_runtime.xml</code>.</p> <p>A <code>MapLibreMapOptions</code> object must be created and passed to the MapView constructor. All setup is done in the Activity code:</p> MapOptionsRuntimeActivity.kt<pre><code>package org.maplibre.android.testapp.activity.options\n\nimport android.os.Bundle\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.MapLibreMapOptions\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.OnMapReadyCallback\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/**\n *  TestActivity demonstrating configuring MapView with MapOptions\n */\nclass MapOptionsRuntimeActivity : AppCompatActivity(), OnMapReadyCallback {\n\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var mapView: MapView\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_options_runtime)\n\n        // Create map configuration\n        val maplibreMapOptions = MapLibreMapOptions.createFromAttributes(this)\n        maplibreMapOptions.apply {\n            apiBaseUri(\"https://api.maplibre.org\")\n            camera(\n                CameraPosition.Builder()\n                    .bearing(0.0)\n                    .target(LatLng(42.31230486601532, 64.63967338936439))\n                    .zoom(3.9)\n                    .tilt(0.0)\n                    .build()\n            )\n            maxPitchPreference(90.0)\n            minPitchPreference(0.0)\n            maxZoomPreference(26.0)\n            minZoomPreference(2.0)\n            localIdeographFontFamily(\"Droid Sans\")\n            zoomGesturesEnabled(true)\n            compassEnabled(true)\n            compassFadesWhenFacingNorth(true)\n            scrollGesturesEnabled(true)\n            rotateGesturesEnabled(true)\n            tiltGesturesEnabled(true)\n        }\n\n        // Create map programmatically, add to view hierarchy\n        mapView = MapView(this, maplibreMapOptions)\n        mapView.getMapAsync(this)\n        mapView.onCreate(savedInstanceState)\n        (findViewById&lt;View&gt;(R.id.container) as ViewGroup).addView(mapView)\n    }\n\n    override fun onMapReady(maplibreMap: MapLibreMap) {\n        this.maplibreMap = maplibreMap\n        this.maplibreMap.setStyle(\"https://demotiles.maplibre.org/style.json\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n}\n</code></pre> <p>This can be found in <code>MapOptionsRuntimeActivity.kt</code>.</p> <p>Finally you will see a result similar to this:</p> <p>For the full contents of <code>MapOptionsRuntimeActivity</code> and <code>MapOptionsXmlActivity</code>, please take a look at the source code of MapLibreAndroidTestApp.</p> <p>You can read more about <code>MapLibreMapOptions</code> in the Android API documentation.</p>"},{"location":"configuration/#supportmapfragment-with-the-help-of-maplibremapoptions","title":"<code>SupportMapFragment</code> with the help of <code>MapLibreMapOptions</code>.","text":"<p>If you are using MapFragment in your project, it is also easy to provide initial values to the <code>newInstance()</code> static method of <code>SupportMapFragment</code>, which requires a <code>MapLibreMapOptions</code> parameter.</p> <p>Let's see how this can be done in a sample activity:</p> <pre><code>package org.maplibre.android.testapp.activity.fragment\n\nimport android.os.Bundle // ktlint-disable import-ordering\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.* // ktlint-disable no-wildcard-imports\nimport org.maplibre.android.maps.MapFragment.OnMapViewReadyCallback\nimport org.maplibre.android.maps.MapView.OnDidFinishRenderingFrameListener\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/**\n * Test activity showcasing using the MapFragment API using Support Library Fragments.\n *\n *\n * Uses MapLibreMapOptions to initialise the Fragment.\n *\n */\nclass SupportMapFragmentActivity :\n    AppCompatActivity(),\n    OnMapViewReadyCallback,\n    OnMapReadyCallback,\n    OnDidFinishRenderingFrameListener {\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var mapView: MapView\n    private var initialCameraAnimation = true\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_fragment)\n        val mapFragment: SupportMapFragment?\n        if (savedInstanceState == null) {\n            mapFragment = SupportMapFragment.newInstance(createFragmentOptions())\n            supportFragmentManager\n                .beginTransaction()\n                .add(R.id.fragment_container, mapFragment, TAG)\n                .commit()\n        } else {\n            mapFragment = supportFragmentManager.findFragmentByTag(TAG) as SupportMapFragment?\n        }\n        mapFragment!!.getMapAsync(this)\n    }\n\n    private fun createFragmentOptions(): MapLibreMapOptions {\n        val options = MapLibreMapOptions.createFromAttributes(this, null)\n        options.scrollGesturesEnabled(false)\n        options.zoomGesturesEnabled(false)\n        options.tiltGesturesEnabled(false)\n        options.rotateGesturesEnabled(false)\n        options.debugActive(false)\n        val dc = LatLng(38.90252, -77.02291)\n        options.minZoomPreference(9.0)\n        options.maxZoomPreference(11.0)\n        options.camera(\n            CameraPosition.Builder()\n                .target(dc)\n                .zoom(11.0)\n                .build()\n        )\n        return options\n    }\n\n    override fun onMapViewReady(map: MapView) {\n        mapView = map\n        mapView.addOnDidFinishRenderingFrameListener(this)\n    }\n\n    override fun onMapReady(map: MapLibreMap) {\n        maplibreMap = map\n        maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Satellite Hybrid\"))\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.removeOnDidFinishRenderingFrameListener(this)\n    }\n\n    override fun onDidFinishRenderingFrame(fully: Boolean, frameEncodingTime: Double, frameRenderingTime: Double) {\n        if (initialCameraAnimation &amp;&amp; fully &amp;&amp; this::maplibreMap.isInitialized) {\n            maplibreMap.animateCamera(\n                CameraUpdateFactory.newCameraPosition(CameraPosition.Builder().tilt(45.0).build()),\n                5000\n            )\n            initialCameraAnimation = false\n        }\n    }\n\n    companion object {\n        private const val TAG = \"com.mapbox.map\"\n    }\n}\n</code></pre> <p>You can also find the full contents of <code>SupportMapFragmentActivity</code> in the MapLibreAndroidTestApp.</p> <p>To learn more about <code>SupportMapFragment</code>, please visit the Android API documentation.</p>"},{"location":"geojson-guide/","title":"Using a GeoJSON Source","text":"<p>This guide will teach you how to use <code>GeoJsonSource</code> by deep diving into GeoJSON file format.</p>"},{"location":"geojson-guide/#goals","title":"Goals","text":"<p>After finishing  this documentation you should be able to:</p> <ol> <li>Understand how <code>Style</code>, <code>Layer</code>, and <code>Source</code> interact with each other.</li> <li>Explore building blocks of GeoJSON data.</li> <li>Use GeoJSON files in constructing <code>GeoJsonSource</code>s.</li> <li>Update data at runtime.</li> </ol>"},{"location":"geojson-guide/#1-styles-layers-and-data-source","title":"1. Styles, Layers, and Data source","text":"<ul> <li>A style defines the visual representation of the map such as colors and appearance.</li> <li>Layers control how data should be presented to the user.</li> <li>Data sources hold actual data and provides layers with it.</li> </ul> <p>Styles consist of collections of layers and a data source. Layers reference data sources. Hence, they require a unique source ID when you construct them. It would be meaningless if we don't have any data to show, so we need know how to supply data through a data source.</p> <p>Firstly, we need to understand how to store data and pass it into a data source; therefore, we will discuss GeoJSON in the next session.</p>"},{"location":"geojson-guide/#2-geojson","title":"2. GeoJSON","text":"<p>GeoJSON is a JSON file for encoding various geographical data structures. It defines several JSON objects to represent geospatial information. Typicalle the<code>.geojson</code> extension is used for GeoJSON files. We define the most fundamental objects:</p> <ul> <li><code>Geometry</code> refers to a single geometric shape that contains one or more coordinates. These shapes are visual objects displayed on a map. A geometry can be one of the following six types:<ul> <li>Point</li> <li>MultiPoint</li> <li>LineString</li> <li>MultilineString</li> <li>Polygon</li> <li>MultiPolygon</li> </ul> </li> <li><code>Feautue</code> is a compound object that combines a single geometry with user-defined attributes, such as name, color.</li> <li><code>FeatureCollection</code> is set of features stored in an array. It is a root object that introduces all other features.</li> </ul> <p>A typical GeoJSON structure might look like:</p> <pre><code>{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [125.6, 10.1]\n  },\n  \"properties\": {\n    \"name\": \"Dinagat Islands\"\n  }\n}\n</code></pre> <p>So far we learned describing geospatial data in GeoJSON files. We will start applying this knowledge into our map applications.</p>"},{"location":"geojson-guide/#3-geojsonsource","title":"3. GeoJsonSource","text":"<p>As we discussed before, map requires some sort data to be rendered. We use different sources such as Vector, Raster and GeoJSON. We will focus exclusively on <code>GeoJsonSource</code> and will not address other sources.</p> <p><code>GeoJsonSource</code> is a type of source that has a unique <code>String</code> ID and GeoJSON data.</p> <p>There are several ways to construct a <code>GeoJsonSource</code>:</p> <ul> <li>Locally stored files such as assets and raw folders</li> <li>Remote services</li> <li>Raw string  parsed into FeatureCollections objects</li> <li>Geometry, Feature, and FeatureCollection objects that map to GeoJSON Base builders</li> </ul> <p>A sample <code>GeoJsonSource</code>:</p> <pre><code>val source = GeoJsonSource(\"source\", featureCollection)\nval lineLayer = LineLayer(\"layer\", \"source\")\n    .withProperties(\n        PropertyFactory.lineColor(Color.RED),\n        PropertyFactory.lineWidth(10f)\n    )\n\nstyle.addSource(source)\nstyle.addLayer(lineLayer)\n</code></pre> <p>Note that you can not simply show data on a map. Layers must reference them. Therefore, you create a layer that gives visual appearance to it.</p>"},{"location":"geojson-guide/#creating-geojson-sources","title":"Creating GeoJSON sources","text":"<p>There are various ways you can create a <code>GeoJSONSource</code>. Some of the options are shown below.</p> Loading from local files with assets folder file<pre><code>binding.mapView.getMapAsync { map -&gt;\n    map.moveCamera(CameraUpdateFactory.newLatLngZoom(cameraTarget, cameraZoom))\n    map.setStyle(\n        Style.Builder()\n            .withImage(imageId, imageIcon)\n            .withSource(GeoJsonSource(sourceId, URI(\"asset://points-sf.geojson\")))\n            .withLayer(SymbolLayer(layerId, sourceId).withProperties(iconImage(imageId)))\n    )\n}\n</code></pre> Loading with raw folder file<pre><code>val source: Source = try {\n    GeoJsonSource(\"amsterdam-spots\", ResourceUtils.readRawResource(this, R.raw.amsterdam))\n} catch (ioException: IOException) {\n    Toast.makeText(\n        this@RuntimeStyleActivity,\n        \"Couldn't add source: \" + ioException.message,\n        Toast.LENGTH_SHORT\n    ).show()\n    return\n}\nmaplibreMap.style!!.addSource(source)\nvar layer: FillLayer? = FillLayer(\"parksLayer\", \"amsterdam-spots\")\nlayer!!.setProperties(\n    PropertyFactory.fillColor(Color.RED),\n    PropertyFactory.fillOutlineColor(Color.BLUE),\n    PropertyFactory.fillOpacity(0.3f),\n    PropertyFactory.fillAntialias(true)\n)\n</code></pre> Parsing inline JSON<pre><code>fun readRawResource(context: Context?, @RawRes rawResource: Int): String {\n    var json = \"\"\n    if (context != null) {\n        val writer: Writer = StringWriter()\n        val buffer = CharArray(1024)\n        context.resources.openRawResource(rawResource).use { `is` -&gt;\n            val reader: Reader = BufferedReader(InputStreamReader(`is`, \"UTF-8\"))\n            var numRead: Int\n            while (reader.read(buffer).also { numRead = it } != -1) {\n                writer.write(buffer, 0, numRead)\n            }\n        }\n        json = writer.toString()\n    }\n    return json\n}\n</code></pre> Loading from remote services<pre><code>private fun createEarthquakeSource(): GeoJsonSource {\n    return GeoJsonSource(EARTHQUAKE_SOURCE_ID, URI(EARTHQUAKE_SOURCE_URL))\n}\n</code></pre> <pre><code>companion object {\n    private const val EARTHQUAKE_SOURCE_URL =\n        \"https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson\"\n    private const val EARTHQUAKE_SOURCE_ID = \"earthquakes\"\n    private const val HEATMAP_LAYER_ID = \"earthquakes-heat\"\n    private const val HEATMAP_LAYER_SOURCE = \"earthquakes\"\n    private const val CIRCLE_LAYER_ID = \"earthquakes-circle\"\n}\n</code></pre> Parsing string with the fromJson method of FeatureCollection<pre><code>return FeatureCollection.fromJson(\n    \"\"\"\n    {\n      \"type\": \"FeatureCollection\",\n      \"features\": [\n        {\n          \"type\": \"Feature\",\n          \"properties\": {},\n          \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n              [\n                [\n                  -77.06867337226866,\n                  38.90467655551809\n                ],\n                [\n                  -77.06233263015747,\n                  38.90479344272695\n                ],\n                [\n                  -77.06234335899353,\n                  38.906463238984344\n                ],\n                [\n                  -77.06290125846863,\n                  38.907206285691615\n                ],\n                [\n                  -77.06364154815674,\n                  38.90684728656818\n                ],\n                [\n                  -77.06326603889465,\n                  38.90637140121084\n                ],\n                [\n                  -77.06321239471436,\n                  38.905561553883246\n                ],\n                [\n                  -77.0691454410553,\n                  38.905436318935635\n                ],\n                [\n                  -77.06912398338318,\n                  38.90466820642439\n                ],\n                [\n                  -77.06867337226866,\n                  38.90467655551809\n                ]\n              ]\n            ]\n          }\n        }\n      ]\n    }\n    \"\"\".trimIndent()\n).features()!![0].geometry() as Polygon\n</code></pre> Creating Geometry, Feature, and FeatureCollections from scratch<pre><code>val properties = JsonObject()\nproperties.addProperty(\"key1\", \"value1\")\nval source = GeoJsonSource(\n    \"test-source\",\n    FeatureCollection.fromFeatures(\n        arrayOf(\n            Feature.fromGeometry(Point.fromLngLat(17.1, 51.0), properties),\n            Feature.fromGeometry(Point.fromLngLat(17.2, 51.0), properties),\n            Feature.fromGeometry(Point.fromLngLat(17.3, 51.0), properties),\n            Feature.fromGeometry(Point.fromLngLat(17.4, 51.0), properties)\n        )\n    )\n)\nstyle.addSource(source)\nval visible = Expression.eq(Expression.get(\"key1\"), Expression.literal(\"value1\"))\nval invisible = Expression.neq(Expression.get(\"key1\"), Expression.literal(\"value1\"))\nval layer = CircleLayer(\"test-layer\", source.id)\n    .withFilter(visible)\nstyle.addLayer(layer)\n</code></pre> <p>Note that the GeoJSON objects we discussed earlier have classes defined in the MapLibre SDK. Therefore, we can either map JSON objects to regular Java/Kotlin objects or build them directly.</p>"},{"location":"geojson-guide/#4-updating-data-at-runtime","title":"4. Updating data at runtime","text":"<p>The key feature of <code>GeoJsonSource</code>s is that once we add one, we can set another set of data. We achieve this using <code>setGeoJson()</code> method. For instance, we create a source variable and check if we have not assigned it, then we create a new source object and add it to style; otherwise, we set a different data source:</p> <pre><code>private fun createFeatureCollection(): FeatureCollection {\n    val point = if (isInitialPosition) {\n        Point.fromLngLat(-74.01618140, 40.701745)\n    } else {\n        Point.fromLngLat(-73.988097, 40.749864)\n    }\n    val properties = JsonObject()\n    properties.addProperty(KEY_PROPERTY_SELECTED, isSelected)\n    val feature = Feature.fromGeometry(point, properties)\n    return FeatureCollection.fromFeatures(arrayOf(feature))\n}\n</code></pre> <pre><code>private fun updateSource(style: Style?) {\n    val featureCollection = createFeatureCollection()\n    if (source != null) {\n        source!!.setGeoJson(featureCollection)\n    } else {\n        source = GeoJsonSource(SOURCE_ID, featureCollection)\n        style!!.addSource(source!!)\n    }\n}\n</code></pre> <p>See this guide for an advanced example that showcases random cars and a passenger on a map updating their positions with smooth animation.</p>"},{"location":"geojson-guide/#summary","title":"Summary","text":"<p>GeoJsonSources have their pros and cons. They are most effective when you want to add additional data to your style or provide features like animating objects on your map.</p> <p>However, working with large datasets can be challenging if you need to manipulate and store data within the app; in such cases, it\u2019s better to use a remote data source.</p>"},{"location":"getting-started/","title":"Quickstart","text":"<p>To follow this example from scratch, in Android Studio create a new \"Empty Views Activity\" and then select \"Kotlin\" as the language.  Select \"Groovy DSL\" as the build configuration language.</p> <ol> <li> <p>If you have an older project, you'll need to add bintray Maven repositories to your project-level Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>).  Add <code>mavenCentral()</code> to where repositories are already defined in that file, something like this:</p> <pre><code>allprojects {\n    repositories {\n    ...\n    mavenCentral()\n    }\n}\n</code></pre> </li> </ol> <p>A newly-created app will likely already have <code>mavenCentral()</code> in a top-level <code>settings.gradle</code> file, and you won't need to add it.</p> <ol> <li> <p>Add the library as a dependency into your module Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>). Replace <code>&lt;version&gt;</code> with the latest MapLibre Android version (e.g.: <code>org.maplibre.gl:android-sdk:11.8.0</code>):</p> <pre><code>dependencies {\n    ...\n    implementation 'org.maplibre.gl:android-sdk:&lt;version&gt;'\n\n}\n</code></pre> </li> <li> <p>Sync your Android project with Gradle files.</p> </li> <li> <p>Add a <code>MapView</code> to your layout XML file (usually <code>&lt;project&gt;/&lt;app-module&gt;/src/main/res/layout/activity_main.xml</code>).</p> <pre><code>...\n&lt;org.maplibre.android.maps.MapView\n    android:id=\"@+id/mapView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    /&gt;\n...\n</code></pre> </li> <li> <p>Initialize the <code>MapView</code> in your <code>MainActivity</code> file by following the example below.  If modifying a newly-created \"Empty Views Activity\" example, it replaces all the Kotlin code after the \"package\" line.</p> <pre><code>import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport org.maplibre.android.MapLibre\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\n\nclass MainActivity : AppCompatActivity() {\n\n    // Declare a variable for MapView\n    private lateinit var mapView: MapView\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Init MapLibre\n        MapLibre.getInstance(this)\n\n        // Init layout view\n        val inflater = LayoutInflater.from(this)\n        val rootView = inflater.inflate(R.layout.activity_main, null)\n        setContentView(rootView)\n\n        // Init the MapView\n        mapView = rootView.findViewById(R.id.mapView)\n        mapView.getMapAsync { map -&gt;\n            map.setStyle(\"https://demotiles.maplibre.org/style.json\")\n            map.cameraPosition = CameraPosition.Builder().target(LatLng(0.0,0.0)).zoom(1.0).build()\n        }\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n}\n</code></pre> </li> <li> <p>Build and run the app. If you run the app successfully, a map will be displayed as seen in the screenshot below.</p> </li> </ol>"},{"location":"location-component/","title":"LocationComponent","text":"<p>This guide will demonstrate how to utilize the LocationComponent to represent the user's current location.</p> <p>When implementing the LocationComponent, the application should request location permissions.  Declare the need for foreground location in the <code>AndroidManifest.xml</code> file. For more information, please refer to the Android Developer Documentation.</p> <pre><code>&lt;manifest ... &gt;\n  &lt;!-- Always include this permission --&gt;\n  &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n\n  &lt;!-- Include only if your app benefits from precise location access. --&gt;\n  &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Create a new activity named <code>BasicLocationPulsingCircleActivity</code>:</p> <ul> <li>This Activity should implement the <code>OnMapReadyCallback</code> interface. The <code>onMapReady()</code> method is triggered when the map is ready to be used.</li> <li>Add a variable <code>permissionsManager</code> to manage permissions.</li> <li>Add a variable <code>locationComponent</code> to manage user location.</li> <li>At the end of the <code>onCreate()</code> method, call <code>checkPermissions()</code> to ensure that the application can access the user's location.</li> </ul> <pre><code>/**\n * This activity shows a basic usage of the LocationComponent's pulsing circle. There's no\n * customization of the pulsing circle's color, radius, speed, etc.\n */\nclass BasicLocationPulsingCircleActivity : AppCompatActivity(), OnMapReadyCallback {\n    private var lastLocation: Location? = null\n    private lateinit var mapView: MapView\n    private var permissionsManager: PermissionsManager? = null\n    private var locationComponent: LocationComponent? = null\n    private lateinit var maplibreMap: MapLibreMap\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_location_layer_basic_pulsing_circle)\n        mapView = findViewById(R.id.mapView)\n        if (savedInstanceState != null) {\n            lastLocation = savedInstanceState.getParcelable(SAVED_STATE_LOCATION, Location::class.java)\n        }\n        mapView.onCreate(savedInstanceState)\n        checkPermissions()\n    }\n</code></pre> <p>In the <code>checkPermissions()</code> method, the PermissionManager is used to request location permissions at runtime and handle the callbacks for permission granting or rejection.Additionally, you should pass the results of <code>Activity.onRequestPermissionResult()</code> to it. If the permissions are granted, call <code>mapView.getMapAsync(this)</code> to register the activity as a listener for onMapReady event.</p> <pre><code>private fun checkPermissions() {\n    if (PermissionsManager.areLocationPermissionsGranted(this)) {\n        mapView.getMapAsync(this)\n    } else {\n        permissionsManager = PermissionsManager(object : PermissionsListener {\n            override fun onExplanationNeeded(permissionsToExplain: List&lt;String&gt;) {\n                Toast.makeText(\n                    this@BasicLocationPulsingCircleActivity,\n                    \"You need to accept location permissions.\",\n                    Toast.LENGTH_SHORT\n                ).show()\n            }\n\n            override fun onPermissionResult(granted: Boolean) {\n                if (granted) {\n                    mapView.getMapAsync(this@BasicLocationPulsingCircleActivity)\n                } else {\n                    finish()\n                }\n            }\n        })\n        permissionsManager!!.requestLocationPermissions(this)\n    }\n}\n\noverride fun onRequestPermissionsResult(\n    requestCode: Int,\n    permissions: Array&lt;String&gt;,\n    grantResults: IntArray\n) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n    permissionsManager!!.onRequestPermissionsResult(requestCode, permissions, grantResults)\n}\n</code></pre> <p>In the <code>onMapReady()</code> method, first set the style and then handle the user's location using the LocationComponent.</p> <p>To configure the LocationComponent, developers should use LocationComponentOptions.</p> <p>In this demonstration, we create an instance of this class.</p> <p>In this method:</p> <ul> <li>Use the annotation <code>@SuppressLint(\"MissingPermission\")</code> to suppress warnings related to missing location access permissions.</li> <li>In <code>setStyle(),</code> you can utilize other public and token-free styles like demotiles instead of the predefined styles.</li> <li>For the builder of LocationComponentOptions, use <code>pulseEnabled(true)</code> to enable the pulse animation, which enhances awareness of the user's location.</li> <li>Use method <code>buildLocationComponentActivationOptions()</code> to set LocationComponentActivationOptions, then activate <code>locatinoComponent</code> with it.</li> <li>To apply options, make sure you call <code>activateLocationComponent()</code> of <code>locationComponent</code>. You can also set <code>locationComponent</code>'s various properties like <code>isLocationComponentEnabled</code> , <code>cameraMode</code> , etc...</li> <li><code>CameraMode.TRACKING</code><sup>1</sup> means that when the user's location is updated, the camera will reposition accordingly.</li> <li><code>locationComponent!!.forceLocationUpdate(lastLocation)</code> updates the the user's last known location.</li> </ul> <pre><code>@SuppressLint(\"MissingPermission\")\noverride fun onMapReady(maplibreMap: MapLibreMap) {\n    this.maplibreMap = maplibreMap\n    maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\")) { style: Style -&gt;\n        locationComponent = maplibreMap.locationComponent\n        val locationComponentOptions =\n            LocationComponentOptions.builder(this@BasicLocationPulsingCircleActivity)\n                .pulseEnabled(true)\n                .build()\n        val locationComponentActivationOptions =\n            buildLocationComponentActivationOptions(style, locationComponentOptions)\n        locationComponent!!.activateLocationComponent(locationComponentActivationOptions)\n        locationComponent!!.isLocationComponentEnabled = true\n        locationComponent!!.cameraMode = CameraMode.TRACKING\n        locationComponent!!.forceLocationUpdate(lastLocation)\n    }\n}\n</code></pre> <p>LocationComponentActivationOptions is used to hold the style, LocationComponentOptions and other locating behaviors.</p> <ul> <li>It can also be used to configure how to obtain the current location, such as LocationEngine and intervals.</li> <li>In this demonstration, it sets 750ms as the fastest interval for location updates, providing high accuracy location results (but with higher power consumption).</li> <li>For more information, please visit the documentation page.</li> </ul> <pre><code>private fun buildLocationComponentActivationOptions(\n    style: Style,\n    locationComponentOptions: LocationComponentOptions\n): LocationComponentActivationOptions {\n    return LocationComponentActivationOptions\n        .builder(this, style)\n        .locationComponentOptions(locationComponentOptions)\n        .useDefaultLocationEngine(true)\n        .locationEngineRequest(\n            LocationEngineRequest.Builder(750)\n                .setFastestInterval(750)\n                .setPriority(LocationEngineRequest.PRIORITY_HIGH_ACCURACY)\n                .build()\n        )\n        .build()\n}\n</code></pre> <p>For further customization, you can also utilize the <code>foregroundTintColor()</code> and <code>pulseColor()</code> methods on the LocationComponentOptions builder:</p> <pre><code>val locationComponentOptions =\n    LocationComponentOptions.builder(this@BasicLocationPulsingCircleActivity)\n       .pulseEnabled(true)\n       .pulseColor(Color.RED)             // Set color of pulse\n       .foregroundTintColor(Color.BLACK)  // Set color of user location\n       .build()\n</code></pre> <p>Here is the final results with different color configurations. For the complete content of this demo, please refer to the source code of the Test App.</p> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p> <ol> <li> <p>A variety of camera modes determine how the camera will track the user location.   They provide the right context to your users at the correct time.\u00a0\u21a9</p> </li> </ol>"},{"location":"snapshotter/","title":"Using the Snapshotter","text":"<p>This guide will help you walk through how to use MapSnapshotter.</p>"},{"location":"snapshotter/#map-snapshot-with-local-style","title":"Map Snapshot with Local Style","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterLocalStyleActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>To get started we will show how to use the map snapshotter with a local style.</p> <p>Add the source code of the Demotiles style as <code>demotiles.json</code> to the <code>res/raw</code> directory of our app<sup>1</sup>. First we will read this style:</p> <pre><code>val styleJson = resources.openRawResource(R.raw.demotiles).reader().readText()\n</code></pre> <p>Next, we configure the MapSnapshotter, passing height and width, the style we just read and the camera position:</p> <pre><code>mapSnapshotter = MapSnapshotter(\n    applicationContext,\n    MapSnapshotter.Options(\n        container.measuredWidth.coerceAtMost(1024),\n        container.measuredHeight.coerceAtMost(1024)\n    )\n        .withStyleBuilder(Style.Builder().fromJson(styleJson))\n        .withCameraPosition(\n            CameraPosition.Builder().target(LatLng(LATITUDE, LONGITUDE))\n                .zoom(ZOOM).build()\n        )\n)\n</code></pre> <p>Lastly we use the <code>.start()</code> method to create the snapshot, and pass callbacks for when the snapshot is ready or for when an error occurs.</p> <pre><code>mapSnapshotter.start({ snapshot -&gt;\n    Timber.i(\"Snapshot ready\")\n    val imageView = findViewById&lt;View&gt;(R.id.snapshot_image) as ImageView\n    imageView.setImageBitmap(snapshot.bitmap)\n}) { error -&gt; Timber.e(error )}\n</code></pre>"},{"location":"snapshotter/#show-a-grid-of-snapshots","title":"Show a Grid of Snapshots","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example, we demonstrate how to use the <code>MapSnapshotter</code> to create multiple map snapshots with different styles and camera positions, displaying them in a grid layout.</p> <p>First we create a <code>GridLayout</code> and a list of <code>MapSnapshotter</code> instances. We create a <code>Style.Builder</code> with a different style for each cell in the grid.</p> <pre><code>val styles = arrayOf(\n    TestStyles.DEMOTILES,\n    TestStyles.AMERICANA,\n    TestStyles.OPENFREEMAP_LIBERTY,\n    TestStyles.AWS_OPEN_DATA_STANDARD_LIGHT,\n    TestStyles.PROTOMAPS_LIGHT,\n    TestStyles.PROTOMAPS_DARK,\n    TestStyles.PROTOMAPS_WHITE,\n    TestStyles.PROTOMAPS_GRAYSCALE\n)\nval builder = Style.Builder().fromUri(\n    styles[(row * grid.rowCount + column) % styles.size]\n)\n</code></pre> <p>Next we create a <code>MapSnapshotter.Options</code> object to customize the settings of each snapshot(ter).</p> <pre><code>val options = MapSnapshotter.Options(\n    grid.measuredWidth / grid.columnCount,\n    grid.measuredHeight / grid.rowCount\n)\n    .withPixelRatio(1f)\n    .withLocalIdeographFontFamily(MapLibreConstants.DEFAULT_FONT)\n</code></pre> <p>For some rows we randomize the visible region of the snapshot:</p> <pre><code>if (row % 2 == 0) {\n    options.withRegion(\n        LatLngBounds.Builder()\n            .include(\n                LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .include(\n                LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .build()\n    )\n}\n</code></pre> <p>For some columns we randomize the camera position:</p> <pre><code>if (column % 2 == 0) {\n    options.withCameraPosition(\n        CameraPosition.Builder()\n            .target(\n                options.region?.center ?: LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .bearing(randomInRange(0f, 360f).toDouble())\n            .tilt(randomInRange(0f, 60f).toDouble())\n            .zoom(randomInRange(0f, 10f).toDouble())\n            .padding(1.0, 1.0, 1.0, 1.0)\n            .build()\n    )\n}\n</code></pre> <p>In the last column of the first row we add two bitmaps. See the next example for more details.</p> <pre><code>if (row == 0 &amp;&amp; column == 2) {\n    val carBitmap = BitmapUtils.getBitmapFromDrawable(\n        ResourcesCompat.getDrawable(resources, R.drawable.ic_directions_car_black, theme)\n    )\n\n    // Marker source\n    val markerCollection = FeatureCollection.fromFeatures(\n        arrayOf(\n            Feature.fromGeometry(\n                Point.fromLngLat(4.91638, 52.35673),\n                featureProperties(\"1\", \"Android\")\n            ),\n            Feature.fromGeometry(\n                Point.fromLngLat(4.91638, 12.34673),\n                featureProperties(\"2\", \"Car\")\n            )\n        )\n    )\n    val markerSource: Source = GeoJsonSource(MARKER_SOURCE, markerCollection)\n\n    // Marker layer\n    val markerSymbolLayer = SymbolLayer(MARKER_LAYER, MARKER_SOURCE)\n        .withProperties(\n            PropertyFactory.iconImage(Expression.get(TITLE_FEATURE_PROPERTY)),\n            PropertyFactory.iconIgnorePlacement(true),\n            PropertyFactory.iconAllowOverlap(true),\n            PropertyFactory.iconSize(\n                Expression.switchCase(\n                    Expression.toBool(Expression.get(SELECTED_FEATURE_PROPERTY)),\n                    Expression.literal(1.5f),\n                    Expression.literal(1.0f)\n                )\n            ),\n            PropertyFactory.iconAnchor(Property.ICON_ANCHOR_BOTTOM),\n            PropertyFactory.iconColor(Color.BLUE)\n        )\n    builder.withImage(\"Car\", Objects.requireNonNull(carBitmap!!), false)\n        .withSources(markerSource)\n        .withLayers(markerSymbolLayer)\n    options\n        .withRegion(null)\n        .withCameraPosition(\n            CameraPosition.Builder()\n                .target(\n                    LatLng(5.537109374999999, 52.07950600379697)\n                )\n                .zoom(1.0)\n                .padding(1.0, 1.0, 1.0, 1.0)\n                .build()\n        )\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshot-with-bitmap-overlay","title":"Map Snapshot with Bitmap Overlay","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterBitMapOverlayActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example adds a bitmap on top of the snapshot. It also demonstrates how you can add a click listener to a snapshot.</p> MapSnapshotterBitMapOverlayActivity.kt<pre><code>package org.maplibre.android.testapp.activity.snapshot\n\nimport android.annotation.SuppressLint\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Canvas\nimport android.graphics.PointF\nimport android.os.Bundle\nimport android.view.MotionEvent\nimport android.view.View\nimport android.view.ViewTreeObserver.OnGlobalLayoutListener\nimport android.widget.ImageView\nimport androidx.annotation.VisibleForTesting\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.snapshotter.MapSnapshot\nimport org.maplibre.android.snapshotter.MapSnapshotter\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport timber.log.Timber\n\n/**\n * Test activity showing how to use a the [MapSnapshotter] and overlay\n * [android.graphics.Bitmap]s on top.\n */\nclass MapSnapshotterBitMapOverlayActivity :\n    AppCompatActivity(),\n    MapSnapshotter.SnapshotReadyCallback {\n    private var mapSnapshotter: MapSnapshotter? = null\n\n    @get:VisibleForTesting\n    var mapSnapshot: MapSnapshot? = null\n        private set\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_snapshotter_marker)\n        val container = findViewById&lt;View&gt;(R.id.container)\n        container.viewTreeObserver\n            .addOnGlobalLayoutListener(object : OnGlobalLayoutListener {\n                override fun onGlobalLayout() {\n                    container.viewTreeObserver.removeOnGlobalLayoutListener(this)\n                    Timber.i(\"Starting snapshot\")\n                    mapSnapshotter = MapSnapshotter(\n                        applicationContext,\n                        MapSnapshotter.Options(\n                            Math.min(container.measuredWidth, 1024),\n                            Math.min(container.measuredHeight, 1024)\n                        )\n                            .withStyleBuilder(\n                                Style.Builder().fromUri(TestStyles.AMERICANA)\n                            )\n                            .withCameraPosition(\n                                CameraPosition.Builder().target(LatLng(52.090737, 5.121420))\n                                    .zoom(15.0).build()\n                            )\n                    )\n                    mapSnapshotter!!.start(this@MapSnapshotterBitMapOverlayActivity)\n                }\n            })\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapSnapshotter!!.cancel()\n    }\n\n    @SuppressLint(\"ClickableViewAccessibility\")\n    override fun onSnapshotReady(snapshot: MapSnapshot) {\n        mapSnapshot = snapshot\n        Timber.i(\"Snapshot ready\")\n        val imageView = findViewById&lt;View&gt;(R.id.snapshot_image) as ImageView\n        val image = addMarker(snapshot)\n        imageView.setImageBitmap(image)\n        imageView.setOnTouchListener { v: View?, event: MotionEvent -&gt;\n            if (event.action == MotionEvent.ACTION_DOWN) {\n                val latLng = snapshot.latLngForPixel(PointF(event.x, event.y))\n                Timber.e(\"Clicked LatLng is %s\", latLng)\n                return@setOnTouchListener true\n            }\n            false\n        }\n    }\n\n    private fun addMarker(snapshot: MapSnapshot): Bitmap {\n        val canvas = Canvas(snapshot.bitmap)\n        val marker =\n            BitmapFactory.decodeResource(resources, R.drawable.maplibre_marker_icon_default, null)\n        // Dom toren\n        val markerLocation = snapshot.pixelForLatLng(LatLng(52.090649433011315, 5.121310651302338))\n        canvas.drawBitmap(\n            marker, /* Subtract half of the width so we center the bitmap correctly */\n            markerLocation.x - marker.width / 2, /* Subtract half of the height so we align the bitmap bottom correctly */\n            markerLocation.y - marker.height / 2,\n            null\n        )\n        return snapshot.bitmap\n    }\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshotter-with-heatmap-layer","title":"Map Snapshotter with Heatmap Layer","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterHeatMapActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example, we demonstrate how to use the <code>MapSnapshotter</code> to create a snapshot of a map that includes a heatmap layer. The heatmap represents earthquake data loaded from a GeoJSON source.</p> <p>First, we create the <code>MapSnapshotterHeatMapActivity</code> class, which extends <code>AppCompatActivity</code> and implements <code>MapSnapshotter.SnapshotReadyCallback</code> to receive the snapshot once it's ready.</p> <pre><code>class MapSnapshotterHeatMapActivity : AppCompatActivity(), MapSnapshotter.SnapshotReadyCallback {\n</code></pre> <p>In the <code>onCreate</code> method, we set up the layout and initialize the <code>MapSnapshotter</code> once the layout is ready.</p> <pre><code>override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_map_snapshotter_marker)\n    val container = findViewById&lt;View&gt;(R.id.container)\n    container.viewTreeObserver\n        .addOnGlobalLayoutListener(object : OnGlobalLayoutListener {\n            override fun onGlobalLayout() {\n                container.viewTreeObserver.removeOnGlobalLayoutListener(this)\n                Timber.i(\"Starting snapshot\")\n                val builder = Style.Builder().fromUri(TestStyles.AMERICANA)\n                    .withSource(earthquakeSource!!)\n                    .withLayerAbove(heatmapLayer, \"water\")\n                mapSnapshotter = MapSnapshotter(\n                    applicationContext,\n                    MapSnapshotter.Options(container.measuredWidth, container.measuredHeight)\n                        .withStyleBuilder(builder)\n                        .withCameraPosition(\n                            CameraPosition.Builder()\n                                .target(LatLng(15.0, (-94).toDouble()))\n                                .zoom(5.0)\n                                .padding(1.0, 1.0, 1.0, 1.0)\n                                .build()\n                        )\n                )\n                mapSnapshotter!!.start(this@MapSnapshotterHeatMapActivity)\n            }\n        })\n}\n</code></pre> <p>Here, we wait for the layout to be laid out using an <code>OnGlobalLayoutListener</code> before initializing the <code>MapSnapshotter</code>. We create a <code>Style.Builder</code> with a base style (<code>TestStyles.AMERICANA</code>), add the earthquake data source, and add the heatmap layer above the \"water\" layer.</p> <p>The <code>heatmapLayer</code> property defines the <code>HeatmapLayer</code> used to visualize the earthquake data.</p> <pre><code>private val heatmapLayer: HeatmapLayer\n    get() {\n        val layer = HeatmapLayer(HEATMAP_LAYER_ID, EARTHQUAKE_SOURCE_ID)\n        layer.maxZoom = 9f\n        layer.sourceLayer = HEATMAP_LAYER_SOURCE\n        layer.setProperties(\n            PropertyFactory.heatmapColor(\n                Expression.interpolate(\n                    Expression.linear(), Expression.heatmapDensity(),\n                    Expression.literal(0), Expression.rgba(33, 102, 172, 0),\n                    Expression.literal(0.2), Expression.rgb(103, 169, 207),\n                    Expression.literal(0.4), Expression.rgb(209, 229, 240),\n                    Expression.literal(0.6), Expression.rgb(253, 219, 199),\n                    Expression.literal(0.8), Expression.rgb(239, 138, 98),\n                    Expression.literal(1), Expression.rgb(178, 24, 43)\n                )\n            ),\n            PropertyFactory.heatmapWeight(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.get(\"mag\"),\n                    Expression.stop(0, 0),\n                    Expression.stop(6, 1)\n                )\n            ),\n            PropertyFactory.heatmapIntensity(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(0, 1),\n                    Expression.stop(9, 3)\n                )\n            ),\n            PropertyFactory.heatmapRadius(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(0, 2),\n                    Expression.stop(9, 20)\n                )\n            ),\n            PropertyFactory.heatmapOpacity(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(7, 1),\n                    Expression.stop(9, 0)\n                )\n            )\n        )\n        return layer\n    }\n</code></pre> <p>This code sets up the heatmap layer's properties, such as color ramp, weight, intensity, radius, and opacity, using expressions that interpolate based on data properties and zoom level.</p> <p>We also define the <code>earthquakeSource</code>, which loads data from a GeoJSON file containing earthquake information.</p> <pre><code>private val earthquakeSource: Source?\n    get() {\n        var source: Source? = null\n        try {\n            source = GeoJsonSource(EARTHQUAKE_SOURCE_ID, URI(EARTHQUAKE_SOURCE_URL))\n        } catch (uriSyntaxException: URISyntaxException) {\n            Timber.e(uriSyntaxException, \"That's not a valid URL.\")\n        }\n        return source\n    }\n</code></pre> <p>When the snapshot is ready, the <code>onSnapshotReady</code> callback is invoked, where we set the snapshot bitmap to an <code>ImageView</code> to display it.</p> <pre><code>@SuppressLint(\"ClickableViewAccessibility\")\noverride fun onSnapshotReady(snapshot: MapSnapshot) {\n    Timber.i(\"Snapshot ready\")\n    val imageView = findViewById&lt;ImageView&gt;(R.id.snapshot_image)\n    imageView.setImageBitmap(snapshot.bitmap)\n}\n</code></pre> <p>Finally, we ensure to cancel the snapshotter in the <code>onStop</code> method to free up resources.</p> <pre><code>override fun onStop() {\n    super.onStop()\n    mapSnapshotter?.cancel()\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshotter-with-expression","title":"Map Snapshotter with Expression","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterWithinExpression.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example the map on top is a live while the map on the bottom is a snapshot that is updated as you pan the map. We style of the snapshot is modified: using a within expression only POIs within a certain distance to a line is shown. A highlight for this area is added to the map as are various points.</p> MapSnapshotterWithinExpression.kt<pre><code>package org.maplibre.android.testapp.activity.turf\n\nimport android.graphics.Color\nimport android.os.Bundle\nimport android.os.PersistableBundle\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.geojson.*\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.snapshotter.MapSnapshot\nimport org.maplibre.android.snapshotter.MapSnapshotter\nimport org.maplibre.android.style.expressions.Expression.within\nimport org.maplibre.android.style.layers.CircleLayer\nimport org.maplibre.android.style.layers.FillLayer\nimport org.maplibre.android.style.layers.LineLayer\nimport org.maplibre.android.style.layers.Property.NONE\nimport org.maplibre.android.style.layers.PropertyFactory.*\nimport org.maplibre.android.style.layers.SymbolLayer\nimport org.maplibre.android.style.sources.GeoJsonOptions\nimport org.maplibre.android.style.sources.GeoJsonSource\nimport org.maplibre.android.testapp.databinding.ActivityMapsnapshotterWithinExpressionBinding\nimport org.maplibre.android.testapp.styles.TestStyles.getPredefinedStyleWithFallback\n\n/**\n * An Activity that showcases the use of MapSnapshotter with 'within' expression\n */\nclass MapSnapshotterWithinExpression : AppCompatActivity() {\n    private lateinit var binding: ActivityMapsnapshotterWithinExpressionBinding\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var snapshotter: MapSnapshotter\n    private var snapshotInProgress = false\n\n    private val cameraListener = object : MapView.OnCameraDidChangeListener {\n        override fun onCameraDidChange(animated: Boolean) {\n            if (!snapshotInProgress) {\n                snapshotInProgress = true\n                snapshotter.setCameraPosition(maplibreMap.cameraPosition)\n                snapshotter.start(object : MapSnapshotter.SnapshotReadyCallback {\n                    override fun onSnapshotReady(snapshot: MapSnapshot) {\n                        binding.imageView.setImageBitmap(snapshot.bitmap)\n                        snapshotInProgress = false\n                    }\n                })\n            }\n        }\n    }\n\n    private val snapshotterObserver = object : MapSnapshotter.Observer {\n        override fun onStyleImageMissing(imageName: String) {\n        }\n\n        override fun onDidFinishLoadingStyle() {\n            // Show only POI labels inside geometry using within expression\n            (snapshotter.getLayer(\"poi-label\") as SymbolLayer).setFilter(\n                within(\n                    bufferLineStringGeometry()\n                )\n            )\n            // Hide other types of labels to highlight POI labels\n            (snapshotter.getLayer(\"road-label\") as SymbolLayer).setProperties(visibility(NONE))\n            (snapshotter.getLayer(\"transit-label\") as SymbolLayer).setProperties(visibility(NONE))\n            (snapshotter.getLayer(\"road-number-shield\") as SymbolLayer).setProperties(visibility(NONE))\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMapsnapshotterWithinExpressionBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.mapView.onCreate(savedInstanceState)\n        binding.mapView.getMapAsync { map -&gt;\n            maplibreMap = map\n\n            // Setup camera position above Georgetown\n            maplibreMap.cameraPosition = CameraPosition.Builder().target(LatLng(38.90628988399711, -77.06574689337494)).zoom(15.5).build()\n\n            // Wait for the map to become idle before manipulating the style and camera of the map\n            binding.mapView.addOnDidBecomeIdleListener(object : MapView.OnDidBecomeIdleListener {\n                override fun onDidBecomeIdle() {\n                    maplibreMap.easeCamera(\n                        CameraUpdateFactory.newCameraPosition(\n                            CameraPosition.Builder().zoom(16.0).target(LatLng(38.905156245642814, -77.06535338052844)).bearing(80.68015859462369).tilt(55.0).build()\n                        ),\n                        1000\n                    )\n                    binding.mapView.removeOnDidBecomeIdleListener(this)\n                }\n            })\n            // Load mapbox streets and add lines and circles\n            setupStyle()\n        }\n    }\n\n    private fun setupStyle() {\n        // Assume the route is represented by an array of coordinates.\n        val coordinates = listOf&lt;Point&gt;(\n            Point.fromLngLat(-77.06866264343262, 38.90506061276737),\n            Point.fromLngLat(-77.06283688545227, 38.905194197410545),\n            Point.fromLngLat(-77.06285834312439, 38.906429843444094),\n            Point.fromLngLat(-77.0630407333374, 38.90680554236621)\n        )\n\n        // Setup style with additional layers,\n        // using streets as a base style\n        maplibreMap.setStyle(\n            Style.Builder().fromUri(getPredefinedStyleWithFallback(\"Streets\"))\n        ) {\n            binding.mapView.addOnCameraDidChangeListener(cameraListener)\n        }\n\n        val options = MapSnapshotter.Options(binding.imageView.measuredWidth / 2, binding.imageView.measuredHeight / 2)\n            .withCameraPosition(maplibreMap.cameraPosition)\n            .withPixelRatio(2.0f).withStyleBuilder(\n                Style.Builder().fromUri(getPredefinedStyleWithFallback(\"Streets\")).withSources(\n                    GeoJsonSource(\n                        POINT_ID,\n                        LineString.fromLngLats(coordinates)\n                    ),\n                    GeoJsonSource(\n                        FILL_ID,\n                        FeatureCollection.fromFeature(\n                            Feature.fromGeometry(bufferLineStringGeometry())\n                        ),\n                        GeoJsonOptions().withBuffer(0).withTolerance(0.0f)\n                    )\n                ).withLayerBelow(\n                    LineLayer(LINE_ID, POINT_ID).withProperties(\n                        lineWidth(7.5f),\n                        lineColor(Color.LTGRAY)\n                    ),\n                    \"poi-label\"\n                ).withLayerBelow(\n                    CircleLayer(POINT_ID, POINT_ID).withProperties(\n                        circleRadius(7.5f),\n                        circleColor(Color.DKGRAY),\n                        circleOpacity(0.75f)\n                    ),\n                    \"poi-label\"\n                ).withLayerBelow(\n                    FillLayer(FILL_ID, FILL_ID).withProperties(\n                        fillOpacity(0.12f),\n                        fillColor(Color.YELLOW)\n                    ),\n                    LINE_ID\n                )\n            )\n        snapshotter = MapSnapshotter(this, options)\n        snapshotter.setObserver(snapshotterObserver)\n    }\n\n    override fun onStart() {\n        super.onStart()\n        binding.mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        binding.mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        binding.mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        binding.mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        binding.mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        binding.mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle, outPersistentState: PersistableBundle) {\n        super.onSaveInstanceState(outState, outPersistentState)\n        binding.mapView.onSaveInstanceState(outState)\n    }\n        private fun bufferLineStringGeometry(): Polygon {\n        // TODO replace static data by Turf#Buffer: mapbox-java/issues/987\n        return FeatureCollection.fromJson(\n            \"\"\"\n            {\n              \"type\": \"FeatureCollection\",\n              \"features\": [\n                {\n                  \"type\": \"Feature\",\n                  \"properties\": {},\n                  \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                      [\n                        [\n                          -77.06867337226866,\n                          38.90467655551809\n                        ],\n                        [\n                          -77.06233263015747,\n                          38.90479344272695\n                        ],\n                        [\n                          -77.06234335899353,\n                          38.906463238984344\n                        ],\n                        [\n                          -77.06290125846863,\n                          38.907206285691615\n                        ],\n                        [\n                          -77.06364154815674,\n                          38.90684728656818\n                        ],\n                        [\n                          -77.06326603889465,\n                          38.90637140121084\n                        ],\n                        [\n                          -77.06321239471436,\n                          38.905561553883246\n                        ],\n                        [\n                          -77.0691454410553,\n                          38.905436318935635\n                        ],\n                        [\n                          -77.06912398338318,\n                          38.90466820642439\n                        ],\n                        [\n                          -77.06867337226866,\n                          38.90467655551809\n                        ]\n                      ]\n                    ]\n                  }\n                }\n              ]\n            }\n            \"\"\".trimIndent()\n        ).features()!![0].geometry() as Polygon\n    }\n\n    companion object {\n        const val POINT_ID = \"point\"\n        const val FILL_ID = \"fill\"\n        const val LINE_ID = \"line\"\n    }\n}\n</code></pre> <ol> <li> <p>See App resources overview for this and other ways you can provide resources to your app.\u00a0\u21a9</p> </li> </ol>"},{"location":"annotations/add-markers/","title":"Add Markers in Bulk","text":"<p>This example demonstrates how you can add markers in bulk.</p> BulkMarkerActivity.kt<pre><code>package org.maplibre.android.testapp.activity.annotation\n\nimport android.app.ProgressDialog\nimport android.os.Bundle\nimport android.view.Menu\nimport android.view.View\nimport android.widget.AdapterView\nimport android.widget.AdapterView.OnItemSelectedListener\nimport android.widget.ArrayAdapter\nimport android.widget.Spinner\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.maplibre.android.annotations.MarkerOptions\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport org.maplibre.android.testapp.utils.GeoParseUtil\nimport timber.log.Timber\nimport java.io.IOException\nimport java.text.DecimalFormat\nimport java.util.*\nimport kotlin.math.min\n\n/**\n * Test activity showcasing adding a large amount of Markers.\n */\nclass BulkMarkerActivity : AppCompatActivity(), OnItemSelectedListener {\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var mapView: MapView\n    private var locations: List&lt;LatLng&gt;? = null\n    private var progressDialog: ProgressDialog? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_marker_bulk)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync { initMap(it) }\n    }\n\n    private fun initMap(maplibreMap: MapLibreMap) {\n        this.maplibreMap = maplibreMap\n        maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        val spinnerAdapter = ArrayAdapter.createFromResource(\n            this,\n            R.array.bulk_marker_list,\n            android.R.layout.simple_spinner_item\n        )\n        spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\n        menuInflater.inflate(R.menu.menu_bulk_marker, menu)\n        val item = menu.findItem(R.id.spinner)\n        val spinner = item.actionView as Spinner\n        spinner.adapter = spinnerAdapter\n        spinner.onItemSelectedListener = this@BulkMarkerActivity\n        return true\n    }\n\n    override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View, position: Int, id: Long) {\n        val amount = Integer.valueOf(resources.getStringArray(R.array.bulk_marker_list)[position])\n        if (locations == null) {\n            progressDialog = ProgressDialog.show(this, \"Loading\", \"Fetching markers\", false)\n            lifecycleScope.launch(Dispatchers.IO) {\n                locations = loadLocationTask(this@BulkMarkerActivity)\n                withContext(Dispatchers.Main) {\n                    onLatLngListLoaded(locations, amount)\n                }\n            }\n        } else {\n            showMarkers(amount)\n        }\n    }\n\n    private fun onLatLngListLoaded(latLngs: List&lt;LatLng&gt;?, amount: Int) {\n        progressDialog!!.hide()\n        locations = latLngs\n        showMarkers(amount)\n    }\n\n    private fun showMarkers(amount: Int) {\n        if (!this::maplibreMap.isInitialized || locations == null || mapView.isDestroyed) {\n            return\n        }\n        maplibreMap.clear()\n        showGlMarkers(min(amount, locations!!.size))\n    }\n\n    private fun showGlMarkers(amount: Int) {\n        val markerOptionsList: MutableList&lt;MarkerOptions&gt; = ArrayList()\n        val formatter = DecimalFormat(\"#.#####\")\n        val random = Random()\n        var randomIndex: Int\n        for (i in 0 until amount) {\n            randomIndex = random.nextInt(locations!!.size)\n            val latLng = locations!![randomIndex]\n            markerOptionsList.add(\n                MarkerOptions()\n                    .position(latLng)\n                    .title(i.toString())\n                    .snippet(formatter.format(latLng.latitude) + \"`, \" + formatter.format(latLng.longitude))\n            )\n        }\n        maplibreMap.addMarkers(markerOptionsList)\n    }\n\n    override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {\n        // nothing selected, nothing to do!\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (progressDialog != null) {\n            progressDialog!!.dismiss()\n        }\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    private fun loadLocationTask(\n        activity: BulkMarkerActivity,\n    ) : List&lt;LatLng&gt;? {\n        try {\n            val json = GeoParseUtil.loadStringFromAssets(\n                activity.applicationContext,\n                \"points.geojson\"\n            )\n            return GeoParseUtil.parseGeoJsonCoordinates(json)\n        } catch (exception: IOException) {\n            Timber.e(exception, \"Could not add markers\")\n        }\n        return null\n    }\n}\n</code></pre>"},{"location":"annotations/marker-annotations/","title":"Annotation: Marker","text":"<p>This guide will show you how to add Markers in the map.</p> <p><code>Annotation</code> is an overlay on top of a Map. In package <code>org.maplibre.android.annotations</code>, it has the following subclasses:</p> <ol> <li>Marker</li> <li>Polyline</li> <li>Polygon</li> </ol> <p>A Marker shows an icon image at a geographical location. By default, marker uses a provided image as its icon.</p> <p></p> <p>Or, the icon can be customized using IconFactory to generate an Icon using a provided image.</p> <p>For more customization, please read the documentation about MarkerOptions.</p> <p>In this showcase, we continue the code from the Quickstart, rename Activity into <code>JsonApiActivity</code>, and pull the GeoJSON data from a free and public API. Then add markers to the map with GeoJSON:</p> <ol> <li> <p>In your module Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>), add <code>okhttp</code> to simplify code for making HTTP requests.   <pre><code>dependencies {\n    ...\n    implementation 'com.squareup.okhttp3:okhttp:4.10.0'\n    ...\n}\n</code></pre></p> </li> <li> <p>Sync your Android project the with Gradle files.</p> </li> <li> <p>In <code>JsonApiActivity</code> we add a new variable for <code>MapLibreMap</code>.    It is used to add annotations to the map instance.   <pre><code>class JsonApiActivity : AppCompatActivity() {\n\n    // Declare a variable for MapView\n    private lateinit var mapView: MapView\n\n    // Declare a variable for MapLibreMap\n    private lateinit var maplibreMap: MapLibreMap\n</code></pre></p> </li> <li> <p>Call <code>mapview.getMapSync()</code> in order to get a <code>MapLibreMap</code> object.    After <code>maplibreMap</code> is assigned, call the <code>getEarthQuakeDataFromUSGS()</code> method    to make a HTTP request and transform data into the map annotations.   <pre><code>mapView.getMapAsync { map -&gt;\n    maplibreMap = map\n\n    maplibreMap.setStyle(\"https://demotiles.maplibre.org/style.json\")\n\n    // Fetch data from USGS\n    getEarthQuakeDataFromUSGS()\n}\n</code></pre></p> </li> <li> <p>Define a function <code>getEarthQuakeDataFromUSGS()</code> to fetch GeoJSON data from a public API.    If we successfully get the response, call <code>addMarkersToMap()</code> on the UI thread.   <pre><code>// Get Earthquake data from usgs.gov, read API doc at:\n// https://earthquake.usgs.gov/fdsnws/event/1/\nprivate fun getEarthQuakeDataFromUSGS() {\n    val url = \"https://earthquake.usgs.gov/fdsnws/event/1/query\".toHttpUrl().newBuilder()\n        .addQueryParameter(\"format\", \"geojson\")\n        .addQueryParameter(\"starttime\", \"2022-01-01\")\n        .addQueryParameter(\"endtime\", \"2022-12-31\")\n        .addQueryParameter(\"minmagnitude\", \"5.8\")\n        .addQueryParameter(\"latitude\", \"24\")\n        .addQueryParameter(\"longitude\", \"121\")\n        .addQueryParameter(\"maxradius\", \"1.5\")\n        .build()\n    val request: Request = Request.Builder().url(url).build()\n\n    OkHttpClient().newCall(request).enqueue(object : Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            Toast.makeText(this@JsonApiActivity, \"Fail to fetch data\", Toast.LENGTH_SHORT)\n                .show()\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            val featureCollection = response.body?.string()\n                ?.let(FeatureCollection::fromJson)\n                ?: return\n            // If FeatureCollection in response is not null\n            // Then add markers to map\n            runOnUiThread { addMarkersToMap(featureCollection) }\n        }\n    })\n}\n</code></pre></p> </li> <li> <p>Now it is time to add markers into the map.</p> </li> <li>In the <code>addMarkersToMap()</code> method, we define two types of bitmap for the marker icon.</li> <li>For each feature in the GeoJSON, add a marker with a snippet about earthquake details.</li> <li>If the magnitude of an earthquake is bigger than 6.0, we use the red icon. Otherwise, we use the blue one.</li> <li> <p>Finally, move the camera to the bounds of the newly added markers   <pre><code>private fun addMarkersToMap(data: FeatureCollection) {\n    val bounds = mutableListOf&lt;LatLng&gt;()\n\n    // Get bitmaps for marker icon\n    val infoIconDrawable = ResourcesCompat.getDrawable(\n        this.resources,\n        // Intentionally specify package name\n        // This makes copy from another project easier\n        org.maplibre.android.R.drawable.maplibre_info_icon_default,\n        theme\n    )!!\n    val bitmapBlue = infoIconDrawable.toBitmap()\n    val bitmapRed = infoIconDrawable\n        .mutate()\n        .apply { setTint(Color.RED) }\n        .toBitmap()\n\n    // Add symbol for each point feature\n    data.features()?.forEach { feature -&gt;\n        val geometry = feature.geometry()?.toJson() ?: return@forEach\n        val point = Point.fromJson(geometry) ?: return@forEach\n        val latLng = LatLng(point.latitude(), point.longitude())\n        bounds.add(latLng)\n\n        // Contents in InfoWindow of each marker\n        val title = feature.getStringProperty(\"title\")\n        val epochTime = feature.getNumberProperty(\"time\")\n        val dateString = SimpleDateFormat(\"yyyy/MM/dd HH:mm\", Locale.TAIWAN).format(epochTime)\n\n        // If magnitude &gt; 6.0, show marker with red icon. If not, show blue icon instead\n        val mag = feature.getNumberProperty(\"mag\")\n        val icon = IconFactory.getInstance(this)\n            .fromBitmap(if (mag.toFloat() &gt; 6.0) bitmapRed else bitmapBlue)\n\n        // Use MarkerOptions and addMarker() to add a new marker in map\n        val markerOptions = MarkerOptions()\n            .position(latLng)\n            .title(dateString)\n            .snippet(title)\n            .icon(icon)\n        maplibreMap.addMarker(markerOptions)\n    }\n\n    // Move camera to newly added annotations\n    maplibreMap.getCameraForLatLngBounds(LatLngBounds.fromLatLngs(bounds))?.let {\n        val newCameraPosition = CameraPosition.Builder()\n            .target(it.target)\n            .zoom(it.zoom - 0.5)\n            .build()\n        maplibreMap.cameraPosition = newCameraPosition\n    }\n}\n</code></pre></p> </li> <li> <p>Here is the final result. For the full contents of <code>JsonApiActivity</code>, please visit source code of our Test App.</p> </li> </ol>"},{"location":"camera/animation-types/","title":"Animation Types","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CameraAnimationTypeActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example showcases the different animation types.</p> <ul> <li>Move: available via the <code>MapLibreMap.moveCamera</code> method.</li> <li>Ease: available via the <code>MapLibreMap.easeCamera</code> method.</li> <li>Animate: available via the <code>MapLibreMap.animateCamera</code> method.</li> </ul>"},{"location":"camera/animation-types/#move","title":"Move","text":"<p>The <code>MapLibreMap.moveCamera</code> method jumps to the camera position provided.</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder()\n        .target(nextLatLng)\n        .zoom(14.0)\n        .tilt(30.0)\n        .tilt(0.0)\n        .build()\nmaplibreMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))\n</code></pre>"},{"location":"camera/animation-types/#ease","title":"Ease","text":"<p>The <code>MapLibreMap.moveCamera</code> eases to the camera position provided (with constant ground speed).</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder()\n        .target(nextLatLng)\n        .zoom(15.0)\n        .bearing(180.0)\n        .tilt(30.0)\n        .build()\nmaplibreMap.easeCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    7500,\n    callback\n)\n</code></pre>"},{"location":"camera/animation-types/#animate","title":"Animate","text":"<p>The <code>MapLibreMap.animateCamera</code> uses a powered flight animation move to the camera position provided<sup>1</sup>.</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder().target(nextLatLng).bearing(270.0).tilt(20.0).build()\nmaplibreMap.animateCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    7500,\n    callback\n)\n</code></pre>"},{"location":"camera/animation-types/#animation-callbacks","title":"Animation Callbacks","text":"<p>In the previous section a <code>CancellableCallback</code> was passed to the last two animation methods. This callback shows a toast message when the animation is cancelled or when it is finished.</p> <pre><code>private val callback: CancelableCallback =\n    object : CancelableCallback {\n        override fun onCancel() {\n            Timber.i(\"Duration onCancel Callback called.\")\n            Toast.makeText(\n                applicationContext,\n                \"Ease onCancel Callback called.\",\n                Toast.LENGTH_LONG\n            )\n                .show()\n        }\n\n        override fun onFinish() {\n            Timber.i(\"Duration onFinish Callback called.\")\n            Toast.makeText(\n                applicationContext,\n                \"Ease onFinish Callback called.\",\n                Toast.LENGTH_LONG\n            )\n                .show()\n        }\n    }\n</code></pre> <ol> <li> <p>The implementation is based on  Van Wijk, Jarke J.; Nuij, Wim A. A. \u201cSmooth and efficient zooming and panning.\u201d INFOVIS \u201903. pp. 15\u201322. https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5 \u21a9</p> </li> </ol>"},{"location":"camera/animator-animation/","title":"Animator Animation","text":"<p>This example showcases how to use the Animator API to schedule a sequence of map animations.</p> CameraAnimatorActivity.kt<pre><code>package org.maplibre.android.testapp.activity.camera\n\nimport android.animation.Animator\nimport android.animation.AnimatorSet\nimport android.animation.TypeEvaluator\nimport android.animation.ValueAnimator\nimport android.os.Bundle\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport android.view.animation.AnticipateOvershootInterpolator\nimport android.view.animation.BounceInterpolator\nimport android.view.animation.Interpolator\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.collection.LongSparseArray\nimport androidx.core.view.animation.PathInterpolatorCompat\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\nimport androidx.interpolator.view.animation.FastOutSlowInInterpolator\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.*\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/** Test activity showcasing using Android SDK animators to animate camera position changes. */\nclass CameraAnimatorActivity : AppCompatActivity(), OnMapReadyCallback {\n    private val animators = LongSparseArray&lt;Animator&gt;()\n    private lateinit var set: Animator\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_camera_animator)\n        mapView = findViewById&lt;View&gt;(R.id.mapView) as MapView\n        if (::mapView.isInitialized) {\n            mapView.onCreate(savedInstanceState)\n            mapView.getMapAsync(this)\n        }\n    }\n\n    override fun onMapReady(map: MapLibreMap) {\n        maplibreMap = map\n        map.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n        initFab()\n    }\n\n    private fun initFab() {\n        findViewById&lt;View&gt;(R.id.fab).setOnClickListener { view: View -&gt;\n            view.visibility = View.GONE\n            val animatedPosition =\n                CameraPosition.Builder()\n                    .target(LatLng(37.789992, -122.402214))\n                    .tilt(60.0)\n                    .zoom(14.5)\n                    .bearing(135.0)\n                    .build()\n            set = createExampleAnimator(maplibreMap.cameraPosition, animatedPosition)\n            set.start()\n        }\n    }\n\n    //\n    // Animator API used for the animation on the FAB\n    //\n    private fun createExampleAnimator(\n        currentPosition: CameraPosition,\n        targetPosition: CameraPosition\n    ): Animator {\n        val animatorSet = AnimatorSet()\n        animatorSet.play(createLatLngAnimator(currentPosition.target!!, targetPosition.target!!))\n        animatorSet.play(createZoomAnimator(currentPosition.zoom, targetPosition.zoom))\n        animatorSet.play(createBearingAnimator(currentPosition.bearing, targetPosition.bearing))\n        animatorSet.play(createTiltAnimator(currentPosition.tilt, targetPosition.tilt))\n        return animatorSet\n    }\n\n    private fun createLatLngAnimator(currentPosition: LatLng, targetPosition: LatLng): Animator {\n        val latLngAnimator =\n            ValueAnimator.ofObject(LatLngEvaluator(), currentPosition, targetPosition)\n        latLngAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        latLngAnimator.interpolator = FastOutSlowInInterpolator()\n        latLngAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.newLatLng((animation.animatedValue as LatLng))\n            )\n        }\n        return latLngAnimator\n    }\n\n    private fun createZoomAnimator(currentZoom: Double, targetZoom: Double): Animator {\n        val zoomAnimator = ValueAnimator.ofFloat(currentZoom.toFloat(), targetZoom.toFloat())\n        zoomAnimator.duration = (2200 * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.startDelay = (600 * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.interpolator = AnticipateOvershootInterpolator()\n        zoomAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.zoomTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return zoomAnimator\n    }\n\n    private fun createBearingAnimator(currentBearing: Double, targetBearing: Double): Animator {\n        val bearingAnimator =\n            ValueAnimator.ofFloat(currentBearing.toFloat(), targetBearing.toFloat())\n        bearingAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        bearingAnimator.startDelay = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        bearingAnimator.interpolator = FastOutLinearInInterpolator()\n        bearingAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.bearingTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return bearingAnimator\n    }\n\n    private fun createTiltAnimator(currentTilt: Double, targetTilt: Double): Animator {\n        val tiltAnimator = ValueAnimator.ofFloat(currentTilt.toFloat(), targetTilt.toFloat())\n        tiltAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        tiltAnimator.startDelay = (1500 * ANIMATION_DELAY_FACTOR).toLong()\n        tiltAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.tiltTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return tiltAnimator\n    }\n\n    //\n    // Interpolator examples\n    //\n    private fun obtainExampleInterpolator(menuItemId: Int): Animator? {\n        return animators[menuItemId.toLong()]\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        menuInflater.inflate(R.menu.menu_animator, menu)\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        if (!::maplibreMap.isInitialized) {\n            return false\n        }\n        if (item.itemId != android.R.id.home) {\n            findViewById&lt;View&gt;(R.id.fab).visibility = View.GONE\n            resetCameraPosition()\n            playAnimation(item.itemId)\n        }\n        return super.onOptionsItemSelected(item)\n    }\n\n    private fun resetCameraPosition() {\n        maplibreMap.moveCamera(\n            CameraUpdateFactory.newCameraPosition(\n                CameraPosition.Builder()\n                    .target(START_LAT_LNG)\n                    .zoom(11.0)\n                    .bearing(0.0)\n                    .tilt(0.0)\n                    .build()\n            )\n        )\n    }\n\n    private fun playAnimation(itemId: Int) {\n        val animator = obtainExampleInterpolator(itemId)\n        if (animator != null) {\n            animator.cancel()\n            animator.start()\n        }\n    }\n\n    private fun obtainExampleInterpolator(interpolator: Interpolator, duration: Long): Animator {\n        val zoomAnimator = ValueAnimator.ofFloat(11.0f, 16.0f)\n        zoomAnimator.duration = (duration * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.interpolator = interpolator\n        zoomAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.zoomTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return zoomAnimator\n    }\n\n    //\n    // MapView lifecycle\n    //\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n        for (i in 0 until animators.size()) {\n            animators[animators.keyAt(i)]!!.cancel()\n        }\n        if (this::set.isInitialized) {\n            set.cancel()\n        }\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (::mapView.isInitialized) {\n            mapView.onDestroy()\n        }\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        if (::mapView.isInitialized) {\n            mapView.onLowMemory()\n        }\n    }\n\n    /** Helper class to evaluate LatLng objects with a ValueAnimator */\n    private class LatLngEvaluator : TypeEvaluator&lt;LatLng&gt; {\n        private val latLng = LatLng()\n        override fun evaluate(fraction: Float, startValue: LatLng, endValue: LatLng): LatLng {\n            latLng.latitude = startValue.latitude + (endValue.latitude - startValue.latitude) * fraction\n            latLng.longitude = startValue.longitude + (endValue.longitude - startValue.longitude) * fraction\n            return latLng\n        }\n    }\n\n    companion object {\n        private const val ANIMATION_DELAY_FACTOR = 1.5\n        private val START_LAT_LNG = LatLng(37.787947, -122.407432)\n    }\n\n    init {\n        val accelerateDecelerateAnimatorSet = AnimatorSet()\n        accelerateDecelerateAnimatorSet.playTogether(\n            createLatLngAnimator(START_LAT_LNG, LatLng(37.826715, -122.422795)),\n            obtainExampleInterpolator(FastOutSlowInInterpolator(), 2500)\n        )\n        animators.put(\n            R.id.menu_action_accelerate_decelerate_interpolator.toLong(),\n            accelerateDecelerateAnimatorSet\n        )\n        val bounceAnimatorSet = AnimatorSet()\n        bounceAnimatorSet.playTogether(\n            createLatLngAnimator(START_LAT_LNG, LatLng(37.787947, -122.407432)),\n            obtainExampleInterpolator(BounceInterpolator(), 3750)\n        )\n        animators.put(R.id.menu_action_bounce_interpolator.toLong(), bounceAnimatorSet)\n        animators.put(\n            R.id.menu_action_anticipate_overshoot_interpolator.toLong(),\n            obtainExampleInterpolator(AnticipateOvershootInterpolator(), 2500)\n        )\n        animators.put(\n            R.id.menu_action_path_interpolator.toLong(),\n            obtainExampleInterpolator(\n                PathInterpolatorCompat.create(.22f, .68f, 0f, 1.71f),\n                2500\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"camera/cameraposition/","title":"CameraPosition Capabilities","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CameraPositionActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example showcases how to listen to camera change events.</p> <p>The camera animation is kicked off with this code:</p> <pre><code>val cameraPosition = CameraPosition.Builder().target(LatLng(latitude, longitude)).zoom(zoom).bearing(bearing).tilt(tilt).build()\n\nmaplibreMap?.animateCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    5000,\n    object : CancelableCallback {\n        override fun onCancel() {\n            Timber.v(\"OnCancel called\")\n        }\n\n        override fun onFinish() {\n            Timber.v(\"OnFinish called\")\n        }\n    }\n)\n</code></pre> <p>Notice how the color of the button in the bottom right changes color. Depending on the state of the camera.</p> <p>We can listen for changes to the state of the camera by registering a <code>OnCameraMoveListener</code>, <code>OnCameraIdleListener</code>, <code>OnCameraMoveCanceledListener</code> or <code>OnCameraMoveStartedListener</code> with the <code>MapLibreMap</code>. For example, the <code>OnCameraMoveListener</code> is defined with:</p> <pre><code>private val moveListener = OnCameraMoveListener {\n    Timber.e(\"OnCameraMove\")\n    fab.setColorFilter(\n        ContextCompat.getColor(this@CameraPositionActivity, android.R.color.holo_orange_dark)\n    )\n}\n</code></pre> <p>And registered with:</p> <pre><code>maplibreMap.addOnCameraMoveListener(moveListener)\n</code></pre> <p>Refer to the full example to learn the methods to register the other types of camera change events.</p>"},{"location":"camera/gesture-detector/","title":"Gesture Detector","text":"<p>The gesture detector of MapLibre Android is encapsulated in the <code>maplibre-gestures-android</code> package.</p>"},{"location":"camera/gesture-detector/#gesture-listeners","title":"Gesture Listeners","text":"<p>You can add listeners for move, rotate, scale and shove gestures. For example, adding a move gesture listener with <code>MapLibreMap.addOnRotateListener</code>:</p> <pre><code>maplibreMap.addOnMoveListener(\n    object : OnMoveListener {\n        override fun onMoveBegin(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_START, \"MOVE START\")\n            )\n        }\n\n        override fun onMove(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_PROGRESS, \"MOVE PROGRESS\")\n            )\n        }\n\n        override fun onMoveEnd(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_END, \"MOVE END\")\n            )\n            recalculateFocalPoint()\n        }\n    }\n)\n</code></pre> <p>Refer to the full example below for examples of listeners for the other gesture types.</p>"},{"location":"camera/gesture-detector/#settings","title":"Settings","text":"<p>You can access an <code>UISettings</code> object via <code>MapLibreMap.uiSettings</code>. Available settings include:</p> <ul> <li>Toggle Quick Zoom. You can double tap on the map to use quick zoom. You can toggle this behavior on and off (<code>UiSettings.isQuickZoomGesturesEnabled</code>).</li> <li>Toggle Velocity Animations. By default flicking causes the map to continue panning (while decelerating). You can turn this off with <code>UiSettings.isScaleVelocityAnimationEnabled</code>.</li> <li>Toggle Rotate Enabled. Use <code>uiSettings.isRotateGesturesEnabled</code>.</li> <li>Toggle Zoom Enabled. Use <code>uiSettings.isZoomGesturesEnabled</code>.</li> </ul>"},{"location":"camera/gesture-detector/#full-example-activity","title":"Full Example Activity","text":"GestureDetectorActivity.kt<pre><code>package org.maplibre.android.testapp.activity.camera\n\nimport android.annotation.SuppressLint\nimport android.os.Bundle\nimport android.os.Handler\nimport android.os.Looper\nimport android.view.LayoutInflater\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.RelativeLayout\nimport android.widget.TextView\nimport androidx.annotation.ColorInt\nimport androidx.annotation.IntDef\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.content.ContextCompat\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport org.maplibre.android.gestures.AndroidGesturesManager\nimport org.maplibre.android.gestures.MoveGestureDetector\nimport org.maplibre.android.gestures.RotateGestureDetector\nimport org.maplibre.android.gestures.ShoveGestureDetector\nimport org.maplibre.android.gestures.StandardScaleGestureDetector\nimport org.maplibre.android.annotations.Marker\nimport org.maplibre.android.annotations.MarkerOptions\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.MapLibreMap.CancelableCallback\nimport org.maplibre.android.maps.MapLibreMap.OnMoveListener\nimport org.maplibre.android.maps.MapLibreMap.OnRotateListener\nimport org.maplibre.android.maps.MapLibreMap.OnScaleListener\nimport org.maplibre.android.maps.MapLibreMap.OnShoveListener\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport org.maplibre.android.testapp.utils.FontCache\nimport org.maplibre.android.testapp.utils.ResourceUtils\n\n/** Test activity showcasing APIs around gestures implementation. */\nclass GestureDetectorActivity : AppCompatActivity() {\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var recyclerView: RecyclerView\n    private var gestureAlertsAdapter: GestureAlertsAdapter? = null\n    private var gesturesManager: AndroidGesturesManager? = null\n    private var marker: Marker? = null\n    private var focalPointLatLng: LatLng? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_gesture_detector)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync { map: MapLibreMap -&gt;\n            maplibreMap = map\n            maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n            initializeMap()\n        }\n        recyclerView = findViewById(R.id.alerts_recycler)\n        recyclerView.setLayoutManager(LinearLayoutManager(this))\n        gestureAlertsAdapter = GestureAlertsAdapter()\n        recyclerView.setAdapter(gestureAlertsAdapter)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        gestureAlertsAdapter!!.cancelUpdates()\n        mapView.onPause()\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    private fun initializeMap() {\n        gesturesManager = maplibreMap.gesturesManager\n        val layoutParams = recyclerView.layoutParams as RelativeLayout.LayoutParams\n        layoutParams.height = (mapView.height / 1.75).toInt()\n        layoutParams.width = mapView.width / 3\n        recyclerView.layoutParams = layoutParams\n        attachListeners()\n        fixedFocalPointEnabled(maplibreMap.uiSettings.focalPoint != null)\n    }\n\n    fun attachListeners() {\n        maplibreMap.addOnMoveListener(\n            object : OnMoveListener {\n                override fun onMoveBegin(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"MOVE START\")\n                    )\n                }\n\n                override fun onMove(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"MOVE PROGRESS\")\n                    )\n                }\n\n                override fun onMoveEnd(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"MOVE END\")\n                    )\n                    recalculateFocalPoint()\n                }\n            }\n        )\n        maplibreMap.addOnRotateListener(\n            object : OnRotateListener {\n                override fun onRotateBegin(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"ROTATE START\")\n                    )\n                }\n\n                override fun onRotate(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"ROTATE PROGRESS\")\n                    )\n                    recalculateFocalPoint()\n                }\n\n                override fun onRotateEnd(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"ROTATE END\")\n                    )\n                }\n            }\n        )\n        maplibreMap.addOnScaleListener(\n            object : OnScaleListener {\n                override fun onScaleBegin(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"SCALE START\")\n                    )\n                    if (focalPointLatLng != null) {\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"INCREASING MOVE THRESHOLD\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.moveThreshold =\n                            ResourceUtils.convertDpToPx(this@GestureDetectorActivity, 175f)\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"MANUALLY INTERRUPTING MOVE\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.interrupt()\n                    }\n                    recalculateFocalPoint()\n                }\n\n                override fun onScale(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"SCALE PROGRESS\")\n                    )\n                }\n\n                override fun onScaleEnd(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"SCALE END\")\n                    )\n                    if (focalPointLatLng != null) {\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"REVERTING MOVE THRESHOLD\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.moveThreshold = 0f\n                    }\n                }\n            }\n        )\n        maplibreMap.addOnShoveListener(\n            object : OnShoveListener {\n                override fun onShoveBegin(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"SHOVE START\")\n                    )\n                }\n\n                override fun onShove(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"SHOVE PROGRESS\")\n                    )\n                }\n\n                override fun onShoveEnd(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"SHOVE END\")\n                    )\n                }\n            }\n        )\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        menuInflater.inflate(R.menu.menu_gestures, menu)\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        val uiSettings = maplibreMap.uiSettings\n        when (item.itemId) {\n            R.id.menu_gesture_focus_point -&gt; {\n                fixedFocalPointEnabled(focalPointLatLng == null)\n                return true\n            }\n            R.id.menu_gesture_animation -&gt; {\n                uiSettings.isScaleVelocityAnimationEnabled =\n                    !uiSettings.isScaleVelocityAnimationEnabled\n                uiSettings.isRotateVelocityAnimationEnabled =\n                    !uiSettings.isRotateVelocityAnimationEnabled\n                uiSettings.isFlingVelocityAnimationEnabled =\n                    !uiSettings.isFlingVelocityAnimationEnabled\n                return true\n            }\n            R.id.menu_gesture_rotate -&gt; {\n                uiSettings.isRotateGesturesEnabled = !uiSettings.isRotateGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_tilt -&gt; {\n                uiSettings.isTiltGesturesEnabled = !uiSettings.isTiltGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_zoom -&gt; {\n                uiSettings.isZoomGesturesEnabled = !uiSettings.isZoomGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_scroll -&gt; {\n                uiSettings.isScrollGesturesEnabled = !uiSettings.isScrollGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_double_tap -&gt; {\n                uiSettings.isDoubleTapGesturesEnabled = !uiSettings.isDoubleTapGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_quick_zoom -&gt; {\n                uiSettings.isQuickZoomGesturesEnabled = !uiSettings.isQuickZoomGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_scroll_horizontal -&gt; {\n                uiSettings.isHorizontalScrollGesturesEnabled =\n                    !uiSettings.isHorizontalScrollGesturesEnabled\n                return true\n            }\n        }\n        return super.onOptionsItemSelected(item)\n    }\n\n    private fun fixedFocalPointEnabled(enabled: Boolean) {\n        if (enabled) {\n            focalPointLatLng = LatLng(51.50325, -0.12968)\n            marker = maplibreMap.addMarker(MarkerOptions().position(focalPointLatLng))\n            maplibreMap.easeCamera(\n                CameraUpdateFactory.newLatLngZoom(focalPointLatLng!!, 16.0),\n                object : CancelableCallback {\n                    override fun onCancel() {\n                        recalculateFocalPoint()\n                    }\n\n                    override fun onFinish() {\n                        recalculateFocalPoint()\n                    }\n                }\n            )\n        } else {\n            if (marker != null) {\n                maplibreMap.removeMarker(marker!!)\n                marker = null\n            }\n            focalPointLatLng = null\n            maplibreMap.uiSettings.focalPoint = null\n        }\n    }\n\n    private fun recalculateFocalPoint() {\n        if (focalPointLatLng != null) {\n            maplibreMap.uiSettings.focalPoint =\n                maplibreMap.projection.toScreenLocation(focalPointLatLng!!)\n        }\n    }\n\n    private class GestureAlertsAdapter : RecyclerView.Adapter&lt;GestureAlertsAdapter.ViewHolder&gt;() {\n        private var isUpdating = false\n        private val updateHandler = Handler(Looper.getMainLooper())\n        private val alerts: MutableList&lt;GestureAlert&gt; = ArrayList()\n\n        class ViewHolder internal constructor(view: View) : RecyclerView.ViewHolder(view) {\n            var alertMessageTv: TextView\n\n            init {\n                val typeface = FontCache.get(\"Roboto-Regular.ttf\", view.context)\n                alertMessageTv = view.findViewById(R.id.alert_message)\n                alertMessageTv.typeface = typeface\n            }\n        }\n\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n            val view =\n                LayoutInflater.from(parent.context)\n                    .inflate(R.layout.item_gesture_alert, parent, false)\n            return ViewHolder(view)\n        }\n\n        override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n            val alert = alerts[position]\n            holder.alertMessageTv.text = alert.message\n            holder.alertMessageTv.setTextColor(\n                ContextCompat.getColor(holder.alertMessageTv.context, alert.color)\n            )\n        }\n\n        override fun getItemCount(): Int {\n            return alerts.size\n        }\n\n        fun addAlert(alert: GestureAlert) {\n            for (gestureAlert in alerts) {\n                if (gestureAlert.alertType != GestureAlert.TYPE_PROGRESS) {\n                    break\n                }\n                if (alert.alertType == GestureAlert.TYPE_PROGRESS &amp;&amp; gestureAlert == alert) {\n                    return\n                }\n            }\n            if (itemCount &gt;= MAX_NUMBER_OF_ALERTS) {\n                alerts.removeAt(itemCount - 1)\n            }\n            alerts.add(0, alert)\n            if (!isUpdating) {\n                isUpdating = true\n                updateHandler.postDelayed(updateRunnable, 250)\n            }\n        }\n\n        @SuppressLint(\"NotifyDataSetChanged\")\n        private val updateRunnable = Runnable {\n            notifyDataSetChanged()\n            isUpdating = false\n        }\n\n        fun cancelUpdates() {\n            updateHandler.removeCallbacksAndMessages(null)\n        }\n    }\n\n    private class GestureAlert(\n        @field:Type @param:Type\n        val alertType: Int,\n        val message: String?\n    ) {\n        @Retention(AnnotationRetention.SOURCE)\n        @IntDef(TYPE_NONE, TYPE_START, TYPE_PROGRESS, TYPE_END, TYPE_OTHER)\n        annotation class Type\n\n        @ColorInt var color = 0\n        override fun equals(other: Any?): Boolean {\n            if (this === other) {\n                return true\n            }\n            if (other == null || javaClass != other.javaClass) {\n                return false\n            }\n            val that = other as GestureAlert\n            if (alertType != that.alertType) {\n                return false\n            }\n            return if (message != null) message == that.message else that.message == null\n        }\n\n        override fun hashCode(): Int {\n            var result = alertType\n            result = 31 * result + (message?.hashCode() ?: 0)\n            return result\n        }\n\n        companion object {\n            const val TYPE_NONE = 0\n            const val TYPE_START = 1\n            const val TYPE_END = 2\n            const val TYPE_PROGRESS = 3\n            const val TYPE_OTHER = 4\n        }\n\n        init {\n            when (alertType) {\n                TYPE_NONE -&gt; color = android.R.color.black\n                TYPE_END -&gt; color = android.R.color.holo_red_dark\n                TYPE_OTHER -&gt; color = android.R.color.holo_purple\n                TYPE_PROGRESS -&gt; color = android.R.color.holo_orange_dark\n                TYPE_START -&gt; color = android.R.color.holo_green_dark\n            }\n        }\n    }\n\n    companion object {\n        private const val MAX_NUMBER_OF_ALERTS = 30\n    }\n}\n</code></pre>"},{"location":"camera/lat-lng-bounds/","title":"LatLngBounds API","text":"<p>Note</p> <p>You can find the full source code of this example in <code>LatLngBoundsActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example demonstrates setting the camera to some bounds defined by some features. It sets these bounds when the map is initialized and when the bottom sheet is opened or closed.</p> <p>Here you can see how the feature collection is loaded and how <code>MapLibreMap.getCameraForLatLngBounds</code> is used to set the bounds during map initialization:</p> <pre><code>val featureCollection: FeatureCollection =\n    fromJson(GeoParseUtil.loadStringFromAssets(this, \"points-sf.geojson\"))\nbounds = createBounds(featureCollection)\n\nmap.getCameraForLatLngBounds(bounds, createPadding(peekHeight))?.let {\n    map.cameraPosition = it\n}\n</code></pre> <p>The <code>createBounds</code> function uses the <code>LatLngBounds</code> API to include all points within the bounds:</p> <pre><code>private fun createBounds(featureCollection: FeatureCollection): LatLngBounds {\n    val boundsBuilder = LatLngBounds.Builder()\n    featureCollection.features()?.let {\n        for (feature in it) {\n            val point = feature.geometry() as Point\n            boundsBuilder.include(LatLng(point.latitude(), point.longitude()))\n        }\n    }\n    return boundsBuilder.build()\n}\n</code></pre>"},{"location":"camera/max-min-zoom/","title":"Max/Min Zoom","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MaxMinZoomActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows how to configure a maximum and a minimum zoom level.</p> <pre><code>maplibreMap.setMinZoomPreference(3.0)\nmaplibreMap.setMaxZoomPreference(5.0)\n</code></pre>"},{"location":"camera/max-min-zoom/#bonus-add-click-listener","title":"Bonus: Add Click Listener","text":"<p>As a bonus, this example also shows how you can define a click listener to the map.</p> <pre><code>maplibreMap.addOnMapClickListener {\n    if (this::maplibreMap.isInitialized) {\n        maplibreMap.setStyle(Style.Builder().fromUri(TestStyles.AMERICANA))\n    }\n    true\n}\n</code></pre> <p>You can remove a click listener again with <code>MapLibreMap.removeOnMapClickListener</code>. To use this API you need to assign the click listener to a variable, since you need to pass the listener to that method.</p> .openmaptiles_caption at 0x7fb0765a04a0&gt;"},{"location":"camera/move-map-pixels/","title":"Scroll by Method","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ScrollByActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows how you can move the map by x/y pixels.</p> <pre><code>maplibreMap.scrollBy(\n    (seekBarX.progress * MULTIPLIER_PER_PIXEL).toFloat(),\n    (seekBarY.progress * MULTIPLIER_PER_PIXEL).toFloat()\n)\n</code></pre>"},{"location":"camera/zoom-methods/","title":"Zoom Methods","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ManualZoomActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows different methods of zooming in.</p> <p>Each method uses <code>MapLibreMap.animateCamera</code>, but with a different <code>CameraUpdateFactory</code>.</p>"},{"location":"camera/zoom-methods/#zooming-in","title":"Zooming In","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomIn())\n</code></pre>"},{"location":"camera/zoom-methods/#zooming-out","title":"Zooming Out","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomOut())\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-by-some-amount-of-zoom-levels","title":"Zoom By Some Amount of Zoom Levels","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomBy(2.0))\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-to-a-zoom-level","title":"Zoom to a Zoom Level","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomTo(2.0))\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-to-a-point","title":"Zoom to a Point","text":"<pre><code>val view = window.decorView\nmaplibreMap.animateCamera(\n    CameraUpdateFactory.zoomBy(\n        1.0,\n        Point(view.measuredWidth / 4, view.measuredHeight / 4)\n    )\n)\n</code></pre>"},{"location":"data/MVT/","title":"Vector Tiles","text":"<p>Note</p> <p>You can find the full source code of this example in <code>VectorTileActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>You can specify where to load MVTs (which sometimes have <code>.pbf</code> extension) by creating a <code>TileSet</code> object with template parameters (for example <code>{z}</code> which will be replaced with the zoom level).</p> <p>MapLibre has a repo with some example vector tiles with the OpenMapTiles schema around Innsbruck, Austria. In the example we load these MVTs and create a line layer for the road network.</p> <pre><code>val tileset = TileSet(\n    \"openmaptiles\",\n    \"https://demotiles.maplibre.org/tiles-omt/{z}/{x}/{y}.pbf\"\n)\nval openmaptiles = VectorSource(\"openmaptiles\", tileset)\nstyle.addSource(openmaptiles)\nval roadLayer = LineLayer(\"road\", \"openmaptiles\").apply {\n    setSourceLayer(\"transportation\")\n    setProperties(\n        lineColor(\"red\"),\n        lineWidth(2.0f)\n    )\n}\n</code></pre> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p>"},{"location":"data/PMTiles/","title":"PMTiles","text":"<p>Starting MapLibre Android 11.7.0, using PMTiles as a data source is supported. You can prefix your vector tile source with <code>pmtiles://</code> to load a PMTiles file. The rest of the URL continue with be <code>https://</code> to load a remote PMTiles file, <code>asset://</code> to load an asset or <code>file://</code> to load a local PMTiles file.</p> <p>Note: PMTiles sources currently do not support caching or offline pack downloads.</p> <p>Oliver Wipfli has made a style available that combines a Protomaps basemap togehter with Foursquare's POI dataset. It is available in the wipfli/foursquare-os-places-pmtiles repository on GitHub. The style to use is</p> <pre><code>https://raw.githubusercontent.com/wipfli/foursquare-os-places-pmtiles/refs/heads/main/style.json\n</code></pre> <p>The neat thing about this style is that it only uses PMTiles vector sources. PMTiles can be hosted with a relatively simple file server (or file hosting service) instead of a more complex specialized tile server.</p>"},{"location":"observability/action-journal/","title":"Action Journal","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ObserverActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>The Action Journal provides functionality for persistent logging of top level map events.</p> <p>Its primary use case is to assist in debugging problematic sessions and crashes by offering additional insight into the actions performed by the map at the time of failure. Data is stored in human readable format, which is useful for analyzing individual cases, but can also be easily translated and aggregated into a database, allowing for efficient analysis of multiple cases and helping to identify recurring patterns (Google BigQuery, AWS Glue + S3 + Athena, etc).</p> <p>We are always interested in improving observability, so if you have a special use case, feel free to open an issue or pull request to extend the types of observability methods.</p>"},{"location":"observability/action-journal/#enabling-the-action-journal","title":"Enabling the Action Journal","text":"<p>You can enable the action journal either through XML:</p> <pre><code>&lt;org.maplibre.android.maps.MapView\n    android:id=\"@id/mapView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:maplibre_actionJournalEnabled=\"true\"\n    app:maplibre_actionJournalLogFileSize=\"1024\"\n    app:maplibre_actionJournalLogFileCount=\"2\"\n    app:maplibre_actionJournalRenderingReportInterval=\"10\"/&gt;\n</code></pre> <p>Or by passing the corresponding options with <code>MapLibreMapOptions</code> to <code>MapView</code>. For more information see Configuration.</p>"},{"location":"observability/action-journal/#logging-implementation-details","title":"Logging implementation details","text":"<p>The logging is implemented using rolling files with a size based policy:</p> <ul> <li>A new file is created when the current log size exceeds <code>MapLibreMapOptions.actionJournalLogFileSize</code>.</li> <li>When the maximum number of files exceeds <code>MapLibreMapOptions.actionJournalLogFileCount</code>:<ul> <li>The oldest one is deleted.</li> <li>The remaining files are renamed sequentially to maintain the naming convention <code>action_journal.0.log</code> through <code>action_journal.{logFileCount - 1}.log</code>.</li> </ul> </li> <li>Each file contains one event per line.</li> <li>All files are stored in an umbrella <code>action_journal</code> directory at <code>MapLibreMapOptions.actionJournalPath</code>.</li> </ul> <p>See also: <code>MapLibreMap</code>, <code>MapLibreMapOptions</code>.</p>"},{"location":"observability/action-journal/#event-format","title":"Event format","text":"<p>Events are stored as JSON objects with the following format:</p> Field Type Required Description name string true event name time string true event time (ISO 8601 with milliseconds) styleName string false currently loaded style name styleURL string false currently loaded style URL clientName string false clientVersion string false event object false event specific data - consists of encoded values of the parameters passed to their <code>MLNMapViewDelegate</code> counterparts <pre><code>{\n    \"name\" : \"onTileAction\",\n    \"time\" : \"2025-04-17T13:13:13.974Z\",\n    \"styleName\" : \"Streets\",\n    \"styleURL\" : \"maptiler://maps/streets\",\n    \"clientName\" : \"App\",\n    \"clientVersion\" : \"1.0\",\n    \"event\" : {\n        \"action\" : \"RequestedFromNetwork\",\n        \"tileX\" : 0,\n        \"tileY\" : 0,\n        \"tileZ\" : 0,\n        \"overscaledZ\" : 0,\n        \"sourceID\" : \"openmaptiles\"\n    }\n}\n</code></pre>"},{"location":"observability/action-journal/#usage","title":"Usage","text":"<pre><code>private fun printActionJournal(map: MapLibreMap) {\n    // configure using `MapLibreMapOptions.actionJournal*` methods\n\n    Logger.i(TAG,\"ActionJournal files: \\n${map.actionJournalLogFiles.joinToString(\"\\n\")}\")\n    Logger.i(TAG,\"ActionJournal : \\n${map.actionJournalLog.joinToString(\"\\n\")}\")\n\n    // print only the newest events on each call\n    map.clearActionJournalLog()\n}\n</code></pre>"},{"location":"observability/action-journal/#alternative","title":"Alternative","text":"<p>The implementation is kept close to the core events to minimize additional locking and avoid platform-specific conversions and calls. As a result customization options and extensibility is limited.</p> <p>For greater flexibility, consider using the <code>MapView</code> event interface (see also <code>MapChangeReceiver</code>). It provides hooks for most Action Journal events and allows for more customizable querying and storage of map data. However, this comes at the cost of added complexity. See Observe Map Events to learn about the map events that you can listen for, which mirror the events available in the action journal.</p>"},{"location":"observability/observe-map-events/","title":"Observe Map Events","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ObserverActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>You can observe-low level map events that are happening by registering listeners to a <code>MapView</code>. Below you can see the the map events that are currently available.</p> <pre><code>override fun onPreCompileShader(id: Int, type: Int, defines: String) {\n    shaderTimes[\"${id}-${type}-${defines}\"] = TimeSource.Monotonic.markNow()\n    Logger.i(TAG, \"A new shader is being compiled, shaderID:${id}, backend type:${type}, program configuration:${defines}\")\n}\n\noverride fun onPostCompileShader(id: Int, type: Int, defines: String) {\n    val startTime = shaderTimes.get(\"${id}-${type}-${defines}\")\n    if (startTime != null) {\n        Logger.i(TAG, \"A shader has been compiled in ${startTime.elapsedNow()}, shaderID:${id}, backend type:${type}, program configuration:${defines}\")\n    }\n}\n\noverride fun onGlyphsRequested(fontStack: Array&lt;String&gt;, rangeStart: Int, rangeEnd: Int) {\n    Logger.i(TAG, \"Glyphs are being requested for the font stack $fontStack, ranging from $rangeStart to $rangeEnd\")\n}\n\noverride fun onGlyphsLoaded(fontStack: Array&lt;String&gt;, rangeStart: Int, rangeEnd: Int) {\n    Logger.i(TAG, \"Glyphs have been loaded for the font stack $fontStack, ranging from $rangeStart to $rangeEnd\")\n}\n\noverride fun onSpriteRequested(id: String, url: String) {\n    Logger.i(TAG, \"The sprite $id has been requested from $url\")\n}\n\noverride fun onSpriteLoaded(id: String, url: String) {\n    Logger.i(TAG, \"The sprite $id has been loaded from $url\")\n}\n\noverride fun onTileAction(op: TileOperation, x: Int, y: Int, z: Int, wrap: Int, overscaledZ: Int, sourceID: String) {\n    val tile = \"X:${x}, Y:${y}, Z:${z}, Wrap:${wrap}, OverscaledZ:${overscaledZ}, SourceID:${sourceID}\"\n    when (op) {\n        TileOperation.RequestedFromCache -&gt; Logger.i(TAG, \"Requesting tile ${tile} from the cache\")\n        TileOperation.RequestedFromNetwork -&gt; Logger.i(TAG, \"Requesting tile ${tile} from the network\")\n        TileOperation.LoadFromCache -&gt; Logger.i(TAG, \"Loading tile ${tile}, requested from the cache\")\n        TileOperation.LoadFromNetwork -&gt; Logger.i(TAG, \"Loading tile ${tile}, requested from the network\")\n        TileOperation.StartParse -&gt; Logger.i(TAG, \"Parsing tile ${tile}\")\n        TileOperation.EndParse -&gt; Logger.i(TAG, \"Completed parsing tile ${tile}\")\n        TileOperation.Error -&gt; Logger.e(TAG, \"An error occured during proccessing for tile ${tile}\")\n        TileOperation.Cancelled -&gt; Logger.i(TAG, \"Pending work on tile ${tile} was cancelled\")\n        TileOperation.NullOp -&gt; Logger.e(TAG, \"An unknown tile operation was emitted for tile ${tile}\")\n    }\n}\n\noverride fun onDidFinishRenderingFrame(fully: Boolean, stats: RenderingStats) {\n    renderStatsTracker.addFrame(stats)\n}\n</code></pre> <p>You need to register them with these APIs:</p> <pre><code>mapView.addOnPreCompileShaderListener(this)\nmapView.addOnPostCompileShaderListener(this)\nmapView.addOnTileActionListener(this)\nmapView.addOnGlyphsLoadedListener(this)\nmapView.addOnGlyphsRequestedListener(this)\nmapView.addOnSpriteLoadedListener(this)\nmapView.addOnSpriteRequestedListener(this)\nmapView.addOnDidFinishRenderingFrameListener(this)\n</code></pre> <p>In this case we implement them by implementing the interfaces below in the activity class, but you could also use lambdas.</p> <pre><code>/**\n * Test activity showcasing logging observer actions from the core\n */\nclass ObserverActivity : AppCompatActivity(),\n    MapView.OnPreCompileShaderListener,\n    MapView.OnPostCompileShaderListener,\n    MapView.OnTileActionListener,\n    MapView.OnGlyphsLoadedListener,\n    MapView.OnGlyphsRequestedListener,\n    MapView.OnSpriteLoadedListener,\n    MapView.OnSpriteRequestedListener,\n    MapView.OnDidFinishRenderingFrameWithStatsListener {\n</code></pre> <p><code>ObserverActivity.onDidFinishRenderingFrame</code> uses <code>RenderStatsTracker</code> as an example for tracking rendering statistics over time. This offers periodic reports of minimum, maximum, average values and callbacks when predefined thresholds are exceeded.</p> <pre><code>renderStatsTracker.setReportFields(listOf(\n    \"encodingTime\",\n    \"renderingTime\",\n    \"numDrawCalls\",\n    \"numActiveTextures\",\n    \"numBuffers\",\n    \"memTextures\",\n    \"memBuffers\"\n))\n\nrenderStatsTracker.setReportListener { _, _, avg -&gt;\n    Logger.i(TAG, \"RenderStatsReport - avg - ${avg.nonZeroValuesString()}\")\n}\n\nrenderStatsTracker.setThresholds(hashMapOf(\n    \"numDrawCalls\" to 1000,\n    \"totalBuffers\" to 1000L\n))\n\nrenderStatsTracker.setThresholdExceededListener { exceededValues, _ -&gt;\n    Logger.i(TAG, \"Exceeded render values $exceededValues\")\n}\n\nrenderStatsTracker.startReports(10L)\n</code></pre>"},{"location":"styling/animated-image-source/","title":"Animated Image Source","text":"<p>Note</p> <p>You can find the full source code of this example in <code>AnimatedImageSourceActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example we will see how we can animate an image source. This is the MapLibre Native equivalent of this MapLibre GL JS example.</p> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p> <p>We set up an image source in a particular quad. Then we kick of a runnable that periodically updates the image source.</p> Creating the image source<pre><code>val quad = LatLngQuad(\n    LatLng(46.437, -80.425),\n    LatLng(46.437, -71.516),\n    LatLng(37.936, -71.516),\n    LatLng(37.936, -80.425)\n)\nval imageSource = ImageSource(ID_IMAGE_SOURCE, quad, R.drawable.southeast_radar_0)\nval layer = RasterLayer(ID_IMAGE_LAYER, ID_IMAGE_SOURCE)\nmap.setStyle(\n    Style.Builder()\n        .fromUri(TestStyles.AMERICANA)\n        .withSource(imageSource)\n        .withLayer(layer)\n) { style: Style? -&gt;\n    runnable = RefreshImageRunnable(imageSource, handler)\n    runnable?.let {\n        handler.postDelayed(it, 100)\n    }\n}\n</code></pre> Updating the image source<pre><code>imageSource.setImage(drawables[drawableIndex++]!!)\nif (drawableIndex &gt; 3) {\n    drawableIndex = 0\n}\nhandler.postDelayed(this, 1000)\n</code></pre>"},{"location":"styling/animated-symbol-layer/","title":"Animated SymbolLayer","text":"<p>Note</p> <p>You can find the full source code of this example in <code>AnimatedSymbolLayerActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p> <p>Notice that there are (red) cars randomly moving around, and a (yellow) taxi that is always heading to the passenger (indicated by the M symbol), which upon arrival hops to a different location again. We will focus on the passanger and the taxi, because the cars randomly moving around follow a similar pattern.</p> <p>In a real application you would of course retrieve the locations from some sort of external API, but for the purposes of this example a random latitude longtitude pair within bounds of the currently visible screen will do.</p> Getter method to get a random location on the screen<pre><code>private val latLngInBounds: LatLng\n    get() {\n        val bounds = maplibreMap.projection.visibleRegion.latLngBounds\n        val generator = Random()\n\n        val randomLat = bounds.latitudeSouth + generator.nextDouble() * (bounds.latitudeNorth - bounds.latitudeSouth)\n        val randomLon = bounds.longitudeWest + generator.nextDouble() * (bounds.longitudeEast - bounds.longitudeWest)\n\n        return LatLng(randomLat, randomLon)\n    }\n</code></pre> Adding a passenger at a random location (on screen)<pre><code>private fun addPassenger(style: Style) {\n    passenger = latLngInBounds\n    val featureCollection = FeatureCollection.fromFeatures(\n        arrayOf(\n            Feature.fromGeometry(\n                Point.fromLngLat(\n                    passenger!!.longitude,\n                    passenger!!.latitude\n                )\n            )\n        )\n    )\n    style.addImage(\n        PASSENGER,\n        ResourcesCompat.getDrawable(resources, R.drawable.icon_burned, theme)!!\n    )\n    val geoJsonSource = GeoJsonSource(PASSENGER_SOURCE, featureCollection)\n    style.addSource(geoJsonSource)\n    val symbolLayer = SymbolLayer(PASSENGER_LAYER, PASSENGER_SOURCE)\n    symbolLayer.withProperties(\n        PropertyFactory.iconImage(PASSENGER),\n        PropertyFactory.iconIgnorePlacement(true),\n        PropertyFactory.iconAllowOverlap(true)\n    )\n    style.addLayerBelow(symbolLayer, RANDOM_CAR_LAYER)\n}\n</code></pre> <p>Adding the taxi on screen is done very similarly.</p> Adding the taxi with bearing<pre><code>private fun addTaxi(style: Style) {\n    val latLng = latLngInBounds\n    val properties = JsonObject()\n    properties.addProperty(PROPERTY_BEARING, Car.getBearing(latLng, passenger))\n    val feature = Feature.fromGeometry(\n        Point.fromLngLat(\n            latLng.longitude,\n            latLng.latitude\n        ),\n        properties\n    )\n    val featureCollection = FeatureCollection.fromFeatures(arrayOf(feature))\n    taxi = Car(feature, passenger, duration)\n    style.addImage(\n        TAXI,\n        (ResourcesCompat.getDrawable(resources, R.drawable.ic_taxi_top, theme) as BitmapDrawable).bitmap\n    )\n    taxiSource = GeoJsonSource(TAXI_SOURCE, featureCollection)\n    style.addSource(taxiSource!!)\n    val symbolLayer = SymbolLayer(TAXI_LAYER, TAXI_SOURCE)\n    symbolLayer.withProperties(\n        PropertyFactory.iconImage(TAXI),\n        PropertyFactory.iconRotate(Expression.get(PROPERTY_BEARING)),\n        PropertyFactory.iconAllowOverlap(true),\n        PropertyFactory.iconIgnorePlacement(true)\n    )\n    style.addLayer(symbolLayer)\n}\n</code></pre> <p>For animating the taxi we use a <code>ValueAnimator</code>.</p> Animate the taxi driving towards the passenger<pre><code>private fun animateTaxi(style: Style) {\n    val valueAnimator = ValueAnimator.ofObject(LatLngEvaluator(), taxi!!.current, taxi!!.next)\n    valueAnimator.addUpdateListener(object : AnimatorUpdateListener {\n        private var latLng: LatLng? = null\n        override fun onAnimationUpdate(animation: ValueAnimator) {\n            latLng = animation.animatedValue as LatLng\n            taxi!!.current = latLng\n            updateTaxiSource()\n        }\n    })\n    valueAnimator.addListener(object : AnimatorListenerAdapter() {\n        override fun onAnimationEnd(animation: Animator) {\n            super.onAnimationEnd(animation)\n            updatePassenger(style)\n            animateTaxi(style)\n        }\n    })\n    valueAnimator.addListener(object : AnimatorListenerAdapter() {\n        override fun onAnimationStart(animation: Animator) {\n            super.onAnimationStart(animation)\n            taxi!!.feature.properties()!!\n                .addProperty(\"bearing\", Car.getBearing(taxi!!.current, taxi!!.next))\n        }\n    })\n    valueAnimator.duration = (7 * taxi!!.current!!.distanceTo(taxi!!.next!!)).toLong()\n    valueAnimator.interpolator = AccelerateDecelerateInterpolator()\n    valueAnimator.start()\n    animators.add(valueAnimator)\n}\n</code></pre>"},{"location":"styling/building-layer/","title":"Building Layer","text":"<p>Note</p> <p>You can find the full source code of this example in <code>BuildingFillExtrusionActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example will show how to add a Fill Extrusion layer to a style.</p> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p> <p>We use the OpenFreeMap Bright style which, unlike OpenFreeMap Libery, does not have a fill extrusion layer by default. However, if you inspect this style with Maputnik you will find that the multipolygons in the  <code>building</code> layer (of the <code>openfreemap</code> source) each have <code>render_min_height</code> and <code>render_height</code> properties.</p> Setting up the fill extrusion layer<pre><code>val fillExtrusionLayer = FillExtrusionLayer(\"building-3d\", \"openmaptiles\")\nfillExtrusionLayer.sourceLayer = \"building\"\nfillExtrusionLayer.setFilter(\n    Expression.all(\n        Expression.has(\"render_height\"),\n        Expression.has(\"render_min_height\")\n    )\n)\nfillExtrusionLayer.minZoom = 15f\nfillExtrusionLayer.setProperties(\n    PropertyFactory.fillExtrusionColor(Color.LTGRAY),\n    PropertyFactory.fillExtrusionHeight(Expression.get(\"render_height\")),\n    PropertyFactory.fillExtrusionBase(Expression.get(\"render_min_height\")),\n    PropertyFactory.fillExtrusionOpacity(0.9f)\n)\nstyle.addLayer(fillExtrusionLayer)\n</code></pre> Changing the light direction<pre><code>isInitPosition = !isInitPosition\nif (isInitPosition) {\n    light!!.position = Position(1.5f, 90f, 80f)\n} else {\n    light!!.position = Position(1.15f, 210f, 30f)\n}\n</code></pre> Changing the light color<pre><code>isRedColor = !isRedColor\nlight!!.setColor(ColorUtils.colorToRgbaString(if (isRedColor) Color.RED else Color.BLUE))\n</code></pre>"},{"location":"styling/circle-layer/","title":"Circle Layer (with Clustering)","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CircleLayerActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example we will add a circle layer for a GeoJSON source. We also show how you can use the cluster property of a GeoJSON source.</p> <p>Create a <code>GeoJsonSource</code> instance, pass a unique identifier for the source and the URL where the GeoJSON is available. Next add the source to the style.</p> Setting up the GeoJSON source<pre><code>try {\n    source = GeoJsonSource(SOURCE_ID, URI(URL_BUS_ROUTES))\n} catch (exception: URISyntaxException) {\n    Timber.e(exception, \"That's not an url... \")\n}\nstyle.addSource(source!!)\n</code></pre> <p>Now you can create a <code>CircleLayer</code>, pass it a unique identifier for the layer and the source identifier of the GeoJSON source just created. You can use a <code>PropertyFactory</code> to pass circle layer properties. Lastly add the layer to your style.</p> Create circle layer a small orange circle for each bus stop<pre><code>layer = CircleLayer(LAYER_ID, SOURCE_ID)\nlayer!!.setProperties(\n    PropertyFactory.circleColor(Color.parseColor(\"#FF9800\")),\n    PropertyFactory.circleRadius(2.0f)\n)\nstyle.addLayer(layer!!)\n</code></pre>"},{"location":"styling/circle-layer/#clustering","title":"Clustering","text":"<p>Next we will show you how you can use clustering. Create a <code>GeoJsonSource</code> as before, but with some additional options to enable clustering.</p> Setting up the clustered GeoJSON source<pre><code>style.addSource(\n    GeoJsonSource(\n        SOURCE_ID_CLUSTER,\n        URI(URL_BUS_ROUTES),\n        GeoJsonOptions()\n            .withCluster(true)\n            .withClusterMaxZoom(14)\n            .withClusterRadius(50)\n    )\n)\n</code></pre> <p>When enabling clustering some special attributes will be available to the points in the newly created layer. One is <code>cluster</code>, which is true if the point indicates a cluster. We want to show a bus stop for points that are not clustered.</p> Add a symbol layers for points that are not clustered<pre><code>val unclustered = SymbolLayer(\"unclustered-points\", SOURCE_ID_CLUSTER)\nunclustered.setProperties(\n    PropertyFactory.iconImage(\"bus-icon\"),\n)\nunclustered.setFilter(\n    Expression.neq(Expression.get(\"cluster\"), true)\n)\nstyle.addLayer(unclustered)\n</code></pre> <p>Next we define which point amounts correspond to which colors. More than 150 points will get a red circle, clusters with 21-150 points will be green and clusters with 20 or less points will be green.</p> Define different colors for different point amounts<pre><code>val layers = arrayOf(\n    150 to ResourcesCompat.getColor(\n        resources,\n        R.color.redAccent,\n        theme\n    ),\n    20 to ResourcesCompat.getColor(resources, R.color.greenAccent, theme),\n    0 to ResourcesCompat.getColor(\n        resources,\n        R.color.blueAccent,\n        theme\n    )\n)\n</code></pre> <p>Lastly we iterate over the array of <code>Pair</code>s to create a <code>CircleLayer</code> for each element.</p> Add different circle layers for clusters of different point amounts<pre><code>for (i in layers.indices) {\n    // Add some nice circles\n    val circles = CircleLayer(\"cluster-$i\", SOURCE_ID_CLUSTER)\n    circles.setProperties(\n        PropertyFactory.circleColor(layers[i].second),\n        PropertyFactory.circleRadius(18f)\n    )\n\n    val pointCount = Expression.toNumber(Expression.get(\"point_count\"))\n    circles.setFilter(\n        if (i == 0) {\n            Expression.all(\n                Expression.has(\"point_count\"),\n                Expression.gte(\n                    pointCount,\n                    Expression.literal(layers[i].first)\n                )\n            )\n        } else {\n            Expression.all(\n                Expression.has(\"point_count\"),\n                Expression.gt(\n                    pointCount,\n                    Expression.literal(layers[i].first)\n                ),\n                Expression.lt(\n                    pointCount,\n                    Expression.literal(layers[i - 1].first)\n                )\n            )\n        }\n    )\n\n    style.addLayer(circles)\n}\n</code></pre>"},{"location":"styling/custom-sprite/","title":"Add Custom Sprite","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CustomSpriteActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example showcases adding a sprite image and using it in a Symbol Layer.</p> <pre><code>// Add an icon to reference later\nstyle.addImage(\n    CUSTOM_ICON,\n    BitmapFactory.decodeResource(\n        resources,\n        R.drawable.ic_car_top\n    )\n)\n\n// Add a source with a geojson point\npoint = Point.fromLngLat(13.400972, 52.519003)\nsource = GeoJsonSource(\n    \"point\",\n    FeatureCollection.fromFeatures(arrayOf(Feature.fromGeometry(point)))\n)\nmaplibreMap.style!!.addSource(source!!)\n\n// Add a symbol layer that references that point source\nlayer = SymbolLayer(\"layer\", \"point\")\nlayer.setProperties( // Set the id of the sprite to use\n    PropertyFactory.iconImage(CUSTOM_ICON),\n    PropertyFactory.iconAllowOverlap(true),\n    PropertyFactory.iconIgnorePlacement(true)\n)\n\n// lets add a circle below labels!\nmaplibreMap.style!!.addLayerBelow(layer, \"water-intermittent\")\nfab.setImageResource(R.drawable.ic_directions_car_black)\n</code></pre>"},{"location":"styling/data-driven-style/","title":"Data Driven Style","text":"<p>Note</p> <p>You can find the full source code of this example in <code>DataDrivenStyleActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example we will look at various types of data-driven styling.</p> <p>The examples with 'Source' in the title apply data-driven styling the parks of Amsterdam. Those examples often are based on the somewhat arbitrary <code>stroke-width</code> property part of the GeoJSON features. These examples are therefore most interesting to learn about the Kotlin API that can be used for data-driven styling.</p> <p>Tip</p> <p>Refer to the MapLibre Style Spec for more information about expressions such as <code>interpolate</code> and <code>step</code>.</p>"},{"location":"styling/data-driven-style/#exponential-zoom-function","title":"Exponential Zoom Function","text":"<pre><code>layer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.interpolate(\n            Expression.exponential(0.5f),\n            Expression.zoom(),\n            Expression.stop(1, Expression.color(Color.RED)),\n            Expression.stop(5, Expression.color(Color.BLUE)),\n            Expression.stop(10, Expression.color(Color.GREEN))\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#interval-zoom-function","title":"Interval Zoom Function","text":"<pre><code>layer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.step(\n            Expression.zoom(),\n            Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f),\n            Expression.stop(1, Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f)),\n            Expression.stop(5, Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f)),\n            Expression.stop(10, Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f))\n        )\n    )\n)\n</code></pre> Equivalent JSON<pre><code>[\"step\",[\"zoom\"],[\"rgba\",0.0,255.0,255.0,1.0],1.0,[\"rgba\",255.0,0.0,0.0,1.0],5.0,[\"rgba\",0.0,0.0,255.0,1.0],10.0,[\"rgba\",0.0,255.0,0.0,1.0]]\n</code></pre>"},{"location":"styling/data-driven-style/#exponential-source-function","title":"Exponential Source Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.interpolate(\n            Expression.exponential(0.5f),\n            Expression.get(\"stroke-width\"),\n            Expression.stop(1f, Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f)),\n            Expression.stop(5f, Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f)),\n            Expression.stop(10f, Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f))\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#categorical-source-function","title":"Categorical Source Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.match(\n            Expression.get(\"name\"),\n            Expression.literal(\"Westerpark\"),\n            Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n            Expression.literal(\"Jordaan\"),\n            Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n            Expression.literal(\"Prinseneiland\"),\n            Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f),\n            Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f)\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#identity-source-function","title":"Identity Source Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillOpacity(\n        Expression.get(\"fill-opacity\")\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#interval-source-function","title":"Interval Source Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.step(\n            Expression.get(\"stroke-width\"),\n            Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f),\n            Expression.stop(1f, Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f)),\n            Expression.stop(2f, Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f)),\n            Expression.stop(3f, Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f))\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#composite-exponential-function","title":"Composite Exponential Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.interpolate(\n            Expression.exponential(1f),\n            Expression.zoom(),\n            Expression.stop(\n                12,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(0.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f))\n                )\n            ),\n            Expression.stop(\n                15,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(255.0f, 255.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(211.0f, 211.0f, 211.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f))\n                )\n            ),\n            Expression.stop(\n                18,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(0.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(128.0f, 128.0f, 128.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f))\n                )\n            )\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#identity-source-function_1","title":"Identity Source Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillOpacity(\n        Expression.get(\"fill-opacity\")\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#composite-interval-function","title":"Composite Interval Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.interpolate(\n            Expression.linear(),\n            Expression.zoom(),\n            Expression.stop(\n                12,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(0.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f))\n                )\n            ),\n            Expression.stop(\n                15,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(255.0f, 255.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(211.0f, 211.0f, 211.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f))\n                )\n            ),\n            Expression.stop(\n                18,\n                Expression.step(\n                    Expression.get(\"stroke-width\"),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.stop(1f, Expression.rgba(0.0f, 0.0f, 0.0f, 1.0f)),\n                    Expression.stop(2f, Expression.rgba(128.0f, 128.0f, 128.0f, 1.0f)),\n                    Expression.stop(3f, Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f))\n                )\n            )\n        )\n    )\n)\n</code></pre>"},{"location":"styling/data-driven-style/#composite-categorical-function","title":"Composite Categorical Function","text":"<pre><code>val layer = maplibreMap.style!!.getLayerAs&lt;FillLayer&gt;(AMSTERDAM_PARKS_LAYER)!!\nlayer.setProperties(\n    PropertyFactory.fillColor(\n        Expression.step(\n            Expression.zoom(),\n            Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f),\n            Expression.stop(\n                7f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                8f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                9f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                10f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                11f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                12f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                13f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                14f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.literal(\"Jordaan\"),\n                    Expression.rgba(0.0f, 255.0f, 0.0f, 1.0f),\n                    Expression.literal(\"PrinsenEiland\"),\n                    Expression.rgba(0.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                15f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                16f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                17f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                18f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.literal(\"Jordaan\"),\n                    Expression.rgba(0.0f, 255.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                19f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                20f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                21f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(255.0f, 0.0f, 0.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            ),\n            Expression.stop(\n                22f,\n                Expression.match(\n                    Expression.get(\"name\"),\n                    Expression.literal(\"Westerpark\"),\n                    Expression.rgba(0.0f, 0.0f, 255.0f, 1.0f),\n                    Expression.rgba(255.0f, 255.0f, 255.0f, 1.0f)\n                )\n            )\n        )\n    )\n)\n</code></pre>"},{"location":"styling/distance-expression/","title":"Distance Expression","text":"<p>Note</p> <p>You can find the full source code of this example in <code>DistanceExpressionActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows how you can modify a style to only show certain features within a certain distance to a point. For this the distance expression is used.</p> <p>Map data OpenStreetMap. \u00a9 OpenMapTiles.</p> <p>First we add a fill layer and a GeoJSON source.</p> <pre><code>val center = Point.fromLngLat(lon, lat)\nval circle = TurfTransformation.circle(center, 150.0, TurfConstants.UNIT_METRES)\nmaplibreMap.setStyle(\n    Style.Builder()\n        .fromUri(TestStyles.OPENFREEMAP_BRIGHT)\n        .withSources(\n            GeoJsonSource(\n                POINT_ID,\n                Point.fromLngLat(lon, lat)\n            ),\n            GeoJsonSource(CIRCLE_ID, circle)\n        )\n        .withLayerBelow(\n            FillLayer(CIRCLE_ID, CIRCLE_ID)\n                .withProperties(\n                    fillOpacity(0.5f),\n                    fillColor(Color.parseColor(\"#3bb2d0\"))\n                ),\n            \"poi\"\n        )\n</code></pre> <p>Next, we only show features from symbol layers that are less than a certain distance from the point. All symbol layers whose identifier does not start with <code>poi</code> are completely hidden.</p> <pre><code>for (layer in style.layers) {\n    if (layer is SymbolLayer) {\n        if (layer.id.startsWith(\"poi\")) {\n            layer.setFilter(lt(\n                distance(\n                    Point.fromLngLat(lon, lat)\n                ),\n                150\n            ))\n        } else {\n            layer.setProperties(visibility(NONE))\n        }\n    }\n}\n</code></pre>"},{"location":"styling/draggable-marker/","title":"Draggable Marker","text":"<p>Note</p> <p>You can find the full source code of this example in <code>DraggableMarkerActivity.kt</code> of the MapLibreAndroidTestApp.</p>"},{"location":"styling/draggable-marker/#adding-a-marker-on-tap","title":"Adding a marker on tap","text":"Adding a tap listener to the map to add a marker on tap<pre><code>maplibreMap.addOnMapClickListener {\n    // Adding a marker on map click\n    val features = maplibreMap.queryRenderedSymbols(it, layerId)\n    if (features.isEmpty()) {\n        addMarker(it)\n    } else {\n        // Displaying marker info on marker click\n        Snackbar.make(\n            mapView,\n            \"Marker's position: %.4f, %.4f\".format(it.latitude, it.longitude),\n            Snackbar.LENGTH_LONG\n        )\n            .show()\n    }\n\n    false\n}\n</code></pre>"},{"location":"styling/draggable-marker/#allowing-markers-to-be-dragged","title":"Allowing markers to be dragged","text":"<p>This is slightly more involved, as we implement it by implementing a <code>DraggableSymbolsManager</code> helper class.</p> <p>This class is initialized and we pass a few callbacks when when markers are start or end being dragged.</p> <pre><code>draggableSymbolsManager = DraggableSymbolsManager(\n    mapView,\n    maplibreMap,\n    featureCollection,\n    source,\n    layerId,\n    actionBarHeight,\n    0\n)\n\n// Adding symbol drag listeners\ndraggableSymbolsManager?.addOnSymbolDragListener(object : DraggableSymbolsManager.OnSymbolDragListener {\n    override fun onSymbolDragStarted(id: String) {\n        binding.draggedMarkerPositionTv.visibility = View.VISIBLE\n        Snackbar.make(\n            mapView,\n            \"Marker drag started (%s)\".format(id),\n            Snackbar.LENGTH_SHORT\n        )\n            .show()\n    }\n\n    override fun onSymbolDrag(id: String) {\n        val point = featureCollection.features()?.find {\n            it.id() == id\n        }?.geometry() as Point\n        binding.draggedMarkerPositionTv.text = \"Dragged marker's position: %.4f, %.4f\".format(point.latitude(), point.longitude())\n    }\n\n    override fun onSymbolDragFinished(id: String) {\n        binding.draggedMarkerPositionTv.visibility = View.GONE\n        Snackbar.make(\n            mapView,\n            \"Marker drag finished (%s)\".format(id),\n            Snackbar.LENGTH_SHORT\n        )\n            .show()\n    }\n})\n</code></pre> <p>The implementation of <code>DraggableSymbolsManager</code> follows. In its initializer we define a handler for when a user long taps on a marker. This then starts dragging that marker. It does this by temporarily suspending all other gestures.</p> <p>We create a custom implementation of <code>MoveGestureDetector.OnMoveGestureListener</code> and pass this to an instance of <code>AndroidGesturesManager</code> linked to the map view.</p> <p>Tip</p> <p>See maplibre-gestures-android for the implementation details of the gestures library used by MapLibre Android.</p> <pre><code>/**\n * A manager, that allows dragging symbols after they are long clicked.\n * Since this manager lives outside of the Maps SDK, we need to intercept parent's motion events\n * and pass them with [DraggableSymbolsManager.onParentTouchEvent].\n * If we were to try and overwrite [AppCompatActivity.onTouchEvent], those events would've been\n * consumed by the map.\n *\n * We also need to setup a [DraggableSymbolsManager.androidGesturesManager],\n * because after disabling map's gestures and starting the drag process\n * we still need to listen for move gesture events which map won't be able to provide anymore.\n *\n * @param mapView the mapView\n * @param maplibreMap the maplibreMap\n * @param symbolsCollection the collection that contains all the symbols that we want to be draggable\n * @param symbolsSource the source that contains the [symbolsCollection]\n * @param symbolsLayerId the ID of the layer that the symbols are displayed on\n * @param touchAreaShiftX X-axis padding that is applied to the parent's window motion event,\n * as that window can be bigger than the [mapView].\n * @param touchAreaShiftY Y-axis padding that is applied to the parent's window motion event,\n * as that window can be bigger than the [mapView].\n * @param touchAreaMaxX maximum value of X-axis motion event\n * @param touchAreaMaxY maximum value of Y-axis motion event\n */\nclass DraggableSymbolsManager(\n    mapView: MapView,\n    private val maplibreMap: MapLibreMap,\n    private val symbolsCollection: FeatureCollection,\n    private val symbolsSource: GeoJsonSource,\n    private val symbolsLayerId: String,\n    private val touchAreaShiftY: Int = 0,\n    private val touchAreaShiftX: Int = 0,\n    private val touchAreaMaxX: Int = mapView.width,\n    private val touchAreaMaxY: Int = mapView.height\n) {\n\n    private val androidGesturesManager: AndroidGesturesManager = AndroidGesturesManager(mapView.context, false)\n    private var draggedSymbolId: String? = null\n    private val onSymbolDragListeners: MutableList&lt;OnSymbolDragListener&gt; = mutableListOf()\n\n    init {\n        maplibreMap.addOnMapLongClickListener {\n            // Starting the drag process on long click\n            draggedSymbolId = maplibreMap.queryRenderedSymbols(it, symbolsLayerId).firstOrNull()?.id()?.also { id -&gt;\n                maplibreMap.uiSettings.setAllGesturesEnabled(false)\n                maplibreMap.gesturesManager.moveGestureDetector.interrupt()\n                notifyOnSymbolDragListeners {\n                    onSymbolDragStarted(id)\n                }\n            }\n            false\n        }\n\n        androidGesturesManager.setMoveGestureListener(MyMoveGestureListener())\n    }\n\n    inner class MyMoveGestureListener : MoveGestureDetector.OnMoveGestureListener {\n        override fun onMoveBegin(detector: MoveGestureDetector): Boolean {\n            return true\n        }\n\n        override fun onMove(detector: MoveGestureDetector, distanceX: Float, distanceY: Float): Boolean {\n            if (detector.pointersCount &gt; 1) {\n                // Stopping the drag when we don't work with a simple, on-pointer move anymore\n                stopDragging()\n                return true\n            }\n\n            // Updating symbol's position\n            draggedSymbolId?.also { draggedSymbolId -&gt;\n                val moveObject = detector.getMoveObject(0)\n                val point = PointF(moveObject.currentX - touchAreaShiftX, moveObject.currentY - touchAreaShiftY)\n\n                if (point.x &lt; 0 || point.y &lt; 0 || point.x &gt; touchAreaMaxX || point.y &gt; touchAreaMaxY) {\n                    stopDragging()\n                }\n\n                val latLng = maplibreMap.projection.fromScreenLocation(point)\n\n                symbolsCollection.features()?.indexOfFirst {\n                    it.id() == draggedSymbolId\n                }?.also { index -&gt;\n                    symbolsCollection.features()?.get(index)?.also { oldFeature -&gt;\n                        val properties = oldFeature.properties()\n                        val newFeature = Feature.fromGeometry(\n                            Point.fromLngLat(latLng.longitude, latLng.latitude),\n                            properties,\n                            draggedSymbolId\n                        )\n                        symbolsCollection.features()?.set(index, newFeature)\n                        symbolsSource.setGeoJson(symbolsCollection)\n                        notifyOnSymbolDragListeners {\n                            onSymbolDrag(draggedSymbolId)\n                        }\n                        return true\n                    }\n                }\n            }\n\n            return false\n        }\n\n        override fun onMoveEnd(detector: MoveGestureDetector, velocityX: Float, velocityY: Float) {\n            // Stopping the drag when move ends\n            stopDragging()\n        }\n    }\n\n    private fun stopDragging() {\n        maplibreMap.uiSettings.setAllGesturesEnabled(true)\n        draggedSymbolId?.let {\n            notifyOnSymbolDragListeners {\n                onSymbolDragFinished(it)\n            }\n        }\n        draggedSymbolId = null\n    }\n\n    fun onParentTouchEvent(ev: MotionEvent?) {\n        androidGesturesManager.onTouchEvent(ev)\n    }\n\n    private fun notifyOnSymbolDragListeners(action: OnSymbolDragListener.() -&gt; Unit) {\n        onSymbolDragListeners.forEach(action)\n    }\n\n    fun addOnSymbolDragListener(listener: OnSymbolDragListener) {\n        onSymbolDragListeners.add(listener)\n    }\n\n    fun removeOnSymbolDragListener(listener: OnSymbolDragListener) {\n        onSymbolDragListeners.remove(listener)\n    }\n\n    interface OnSymbolDragListener {\n        fun onSymbolDragStarted(id: String)\n        fun onSymbolDrag(id: String)\n        fun onSymbolDragFinished(id: String)\n    }\n}\n</code></pre>"},{"location":"styling/live-realtime-data/","title":"Add live realtime data","text":"<p>Note</p> <p>You can find the full source code of this example in <code>RealTimeGeoJsonActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example you will learn how to add a live GeoJSON source. We have set up a lambda function that returns a new GeoJSON point every time it is called.</p> <p>First we will create a <code>GeoJSONSource</code>.</p> Adding GeoJSON source<pre><code>try {\n    style.addSource(GeoJsonSource(ID_GEOJSON_SOURCE, URI(URL_GEOJSON_SOURCE)))\n} catch (malformedUriException: URISyntaxException) {\n    Timber.e(malformedUriException, \"Invalid URL\")\n}\n</code></pre> <p>Next we will create a <code>SymbolLayer</code> that uses the source.</p> Adding a SymbolLayer source<pre><code>val layer = SymbolLayer(ID_GEOJSON_LAYER, ID_GEOJSON_SOURCE)\nlayer.setProperties(\n    PropertyFactory.iconImage(\"plane\"),\n    PropertyFactory.iconAllowOverlap(true)\n)\nstyle.addLayer(layer)\n</code></pre> <p>We use define a <code>Runnable</code> and use <code>android.os.Handler</code> with a <code>android.os.Looper</code> to update the GeoJSON source every 2 seconds.</p> Defining a Runnable for updating the GeoJSON source<pre><code>private inner class RefreshGeoJsonRunnable(\n    private val maplibreMap: MapLibreMap,\n    private val handler: Handler\n) : Runnable {\n    override fun run() {\n        val geoJsonSource = maplibreMap.style!!.getSource(ID_GEOJSON_SOURCE) as GeoJsonSource\n        geoJsonSource.setUri(URL_GEOJSON_SOURCE)\n        val features = geoJsonSource.querySourceFeatures(null)\n        setIconRotation(features)\n        handler.postDelayed(this, 2000)\n    }\n}\n</code></pre>"},{"location":"styling/live-realtime-data/#bonus-set-icon-rotation","title":"Bonus: set icon rotation","text":"<p>You can set the icon rotation of the icon when ever the point is updated based on the last two points.</p> Defining a Runnable for updating the GeoJSON source<pre><code>if (features.size != 1) {\n    Timber.e(\"Expected only one feature\")\n    return\n}\n\nval feature = features[0]\nval geometry = feature.geometry()\nif (geometry !is Point) {\n    Timber.e(\"Expected geometry to be a point\")\n    return\n}\n\nif (lastLocation == null) {\n    lastLocation = geometry\n    return\n}\n\nmaplibreMap.style!!.getLayer(ID_GEOJSON_LAYER)!!.setProperties(\n    PropertyFactory.iconRotate(calculateRotationAngle(lastLocation!!, geometry)),\n)\n</code></pre>"}]}