<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coordinate System - MapLibre Native Developer Documentation</title>


        <!-- Custom HTML head -->
        <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6.0/+esm';
        
        const darkThemes = ['ayu', 'navy', 'coal'];
        const lightThemes = ['light', 'rust'];
        
        const classList = document.getElementsByTagName('html')[0].classList;
        
        let lastThemeWasLight = true;
        for (const cssClass of classList) {
            if (darkThemes.includes(cssClass)) {
                lastThemeWasLight = false;
                break;
            }
        }
        
        const theme = lastThemeWasLight ? 'default' : 'dark';
        mermaid.initialize({ startOnLoad: true, theme });
        
        // Simplest way to make mermaid re-render the diagrams in the new theme is via refreshing the page
        
        for (const darkTheme of darkThemes) {
            document.getElementById(darkTheme).addEventListener('click', () => {
                if (lastThemeWasLight) {
                    window.location.reload();
                }
            });
        }
        
        for (const lightTheme of lightThemes) {
            document.getElementById(lightTheme).addEventListener('click', () => {
                if (!lastThemeWasLight) {
                    window.location.reload();
                }
            });
        }
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../diff.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MapLibre Native Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<p>Before we jump into the coordinate system of MapLibre Native, let's
quickly review the concepts of translating a position on the face of
Earth to a map tile. This is not a comprehensive refresher of coordinate
reference systems or rendering basics. Rather this intends to guide the
reader on what we want to achieve in this section.</p>
<p>We start from <em>Earth</em>, which is a geoid which is mathematically
expensive to use as a reference coordinate system. Thus, we approximate
the earth to reference ellipsoids or datum. For this documents' scope,
WGS84 is used as the canonical datum. Our goal is to represent
geometries defined by WGS84 longitude, latitude pair coordinates to a
map tile.</p>
<p>Instead of translating a full geometry, in the following subsections, we
will project a WGS 84 point to a map tile rendered in MapLibre
Native.</p>
<h4 id="world-vs-earth"><a class="header" href="#world-vs-earth">World vs Earth</a></h4>
<p>This document uses the word <em>Earth</em> when it refers to the planet in
which we all live in and make map tiles for. This document uses the word
<em>World</em> to denote the world MapLibre Native renders. The word <em>world</em>
in rendering terms mean the <em>world</em> to render. It could be a set of
cones and boxes, a modeled city, anything composed of 3D objects.
MapLibre Native renders map tiles in a range of zoom levels on a 3D
plane. Map tiles are already produced from a WGS84 ellipsoid. Therefore,
when this document uses the word <em>World,</em> it means the 3D plane
containing a set of map tiles to be rendered, not the <em>Earth</em>.</p>
<h4 id="transformations"><a class="header" href="#transformations">Transformations</a></h4>
<p>MapLibre Native requires a series of coordinate transformations to render a
geometry from map tile. This is where we refresh our rendering knowledge
a bit. To render anything through a GPU:</p>
<ol>
<li>
<p>Design and define model in the <em>Local Space</em>. We call anything that
needs to be renderer a <em>model.</em> In the Local space, a model lives in
its own coordinate system. For MapLibre Native, in local space
each individual tile is modeled. This map tile is already populated
by a map tile generation process. The longitude, latitude bound per
tile is now translated to pixel bounds in this local space.</p>
</li>
<li>
<p>When model matrix is applied to local space, as in a camera is
applied, <em>Local Space</em> transforms to <em>World Space</em>. In this space,
the model coordinates are relative to the world's origin. In this
space all the individual map tiles to be rendered are introduced in
the world space.</p>
</li>
<li>
<p>The <em>World Space</em> is not seen from a viewpoint of a camera. When we
see the <em>world</em> from a viewpoint of a camera, view matrix
transformation is applied. Cameras can see the world up to a
distance like human eyes can. To emulate that we apply <em>Projection
Matrix</em> to <em>View Space</em> and end up in <em>Clip Space</em><sup class="footnote-reference" id="fr-8-1"><a href="#footnote-8">1</a></sup>.</p>
</li>
<li>
<p>Finally, the <em>World Space</em> is transformed to device screen by
applying viewport transform matrix.</p>
</li>
</ol>
<p>Going forward, scoping our discussion only to MapLibre Native, we
will talk mostly about two categories of coordinate systems:</p>
<ol>
<li>
<p>World Coordinates</p>
</li>
<li>
<p>Device Coordinates</p>
</li>
</ol>
<p>World Coordinates are defined in <em>World Space</em>. This speaks of how <em>this
world defines itself in a three-dimensional space</em>.<sup class="footnote-reference" id="fr-9-1"><a href="#footnote-9">2</a></sup> On the other
hand, device coordinates are used through View, Clip, and Screen Space.
The purpose of this set of coordinates is to define how the world will
be projected on a screen. Device Coordinates define <em>how a world will be
projected on a screen.</em></p>
<p>The unit of measurement will be pixels in this document. When the map
tiles are generated by a system, the unit of distance in each tile is
measured in degree angles instead of meters. Because angular distance
stays the same if we move the angle across the axis of earth.</p>
<p>Figure 2 shows rendering map tile through the rendering spaces and
transformations below:</p>
<p><img src="media/rendering-spaces-and-transformations-for-map-tiles.png" alt="" />
<em>Figure 2: Rendering Spaces and Transformations for Map Tiles</em></p>
<h2 id="world-coordinates"><a class="header" href="#world-coordinates">World Coordinates</a></h2>
<p>World Coordinates for maps start with <em>Geographic Coordinate Systems</em>.
<em>Geographic Coordinate Systems</em> use the three-dimensional model of the
earth (ellipsoid) to define specific locations on the surface to create
a grid. Traditional longitude, and latitude coordinate pair to define a
location is an example of using geographic coordinates. EPSG: 4326
(WGS84) is the reference <em>Geographic Coordinate System</em> that most of the
world's geospatial data is defined and stored<sup class="footnote-reference" id="fr-10-1"><a href="#footnote-10">3</a></sup> in. There is no way
to visualize the WGS84 coordinate system on a two-dimensional plane, in
this case, the map.</p>
<p>Projections are used to translate WGS84 coordinates to a plane. To be
specific, projections are used to translate a location on the ellipsoid
to a two-dimensional square. EPSG:3857<sup class="footnote-reference" id="fr-11-1"><a href="#footnote-11">4</a></sup> or projected
<em>Pseudo-Mercator Coordinate System</em> is such a coordinate system.
EPSG:3857 is used by MapLibre Native as a default coordinate system
to display maps. This system takes WGS84 coordinates and projects them
into sphere. This stretches out the landmass in the hemispheres but
mathematically makes it simpler to project a location back to a 2D
plane. As in, a sphere divided into angular equidistant grid produces
rectangular grids when projected into a 2D plane. The philosophy behind
this was to make rendering maps easy, as in drawing 2D squares on a
plane is computationally trivial.</p>
<p>Our world can be now broken down into these squares or tiles as we will
call it going forward. This system imagines the world as a giant grid of
tiles. Each tile has a fixed size defined in pixels.</p>
<pre><code>worldSize = tileSize * number of tiles across a single dimension
</code></pre>
<p>For brevity, this document assumes the reader knows that map tiles are
divided into a range of zoom levels. And each tile in zoom N gets
divided into 4 tiles in zoom N+1. A tile size of 512 pixels and zoom
level 11 will deduce <em>worldSize</em> to be the following:</p>
<pre><code>worldSize = 512 * 2^11 = 1048576
</code></pre>
<p>Although each tile breaks into 4 in the next zoom level, we used a power
of 2. This is because X and Y both dimensions expand with a factor of 2.</p>
<p>Example: We start from translating a WGS84 location with longitude
-77.035915 and latitude 38.889814. To translate a degree longitude
relies on normalizing the latitude range <code>[-180, 180]</code> to <code>[0, 1048576]</code>. This means the X pixel value of a specific tile requires
shifting our coordinate by 180. For example, a location with longitude
-77.035915 becomes*:*</p>
<pre><code>X = (180 + longitude) / 360 * worldSize
= (180 + -77.035915) / 360 * 1048576
= 299,904
</code></pre>
<p>Finding the X coordinate is easy to compute. But the Y requires a more
than normalizing the range. This is due to the aforementioned space
stretching in the hemispheres<sup class="footnote-reference" id="fr-12-1"><a href="#footnote-12">5</a></sup>. Latitude value (Y) defined in WGS84
will not be the same position after stretching. The computation looks
like the following if the latitude was 38.889814:</p>
<pre><code>y = ln(tan(45 + latitude / 2))
= ln(tan(45 + 38.889814/ 2))
= 0.73781742861
</code></pre>
<p>Now, to compute the pixel value for y:</p>
<pre><code>Y = (180 - y * (180 / π)) / 360 * worldSize
= (180 - 42.27382˚) / 360 * 1048576
= 401,156
</code></pre>
<h3 id="tile-coordinates"><a class="header" href="#tile-coordinates">Tile Coordinates</a></h3>
<p>Our next pursuit is to translate <em>World Coordinates to Tile
Coordinates</em>. Because we want to know where exactly inside a map tile a
location (longitude, latitude) coordinate gets rendered and vice versa.
This system creates different pixel ranges per zoom level. So, we append
the zoom level along with the X and Y pixel values. Dividing the pixel
values with the tile size normalizes the X and Y value <em>per tile</em>. This
means <code>(x:299,904, y:401,156, z:11)</code> becomes <code>(585.7471, 783.5067, z11)</code>.</p>
<p>We divide our X and Y pixel value by tile size because we want to know
the starting coordinates of each tile instead of individual location
coordinates. This helps in drawing a tile. If we now <em>floor</em> the
components to integers, we get <code>(585/783/11)</code>. This marks an individual
tile's X, Y, and Z.</p>
<p>To reach our goal of translating a location to a coordinate inside a
tile, we need to know what is the <em>extent</em> of the tile. MapLibre
Native follows Mapbox Vector Tile (MVT) spec. Following said spec,
MapLibre Native internally normalizes each tile to an <em>extent</em> of
8192. Tile extent describes the width and height of the tile in integer
coordinates. This means a tile coordinate can have higher precision than
a pixel. Because normally a tile has a height and width of 512 pixels.
In this case, with an extent of 8192, each <em><strong>Tile Coordinate</strong></em> has a
precision of <code>512/8192 = 1/16</code>th of a pixel. Tile <em>extent</em> origin (0,0)
is on top left corner of the tile, and the (Xmax, Ymax) is on the bottom
right. This means (8192, 8192) <em>tile coordinate</em> will be in the bottom
right. Any coordinate greater or lesser than the <em>extent</em> range is
considered outside the <em>extent</em> of the tile. Geometries that extend past
the tile's area as defined by the extent are often used as a <em>buffer</em>
for rendering features that overlap multiple adjacent tiles.</p>
<p>To finally deduce the <em><strong>Tile Coordinates</strong></em> we multiply the remainder
of our Tile components with <em>extent:</em></p>
<pre><code>(585.7471, 783.5067, z11) -&gt; (.7471 * 8192, .5067 * 8192) = (x:
6120, y: 4151)
</code></pre>
<p>This makes the <em><strong>Tile</strong></em> to be <code>(585/783/11)</code> and <em><strong>Tile Coordinates</strong></em>
to be <code>(x: 6120, y: 4151)</code> for WGS84 location with longitude -77.035915,
and latitude 38.889814.</p>
<p>After defining <em><strong>Tile Coordinates</strong></em>, our pursuit continues to
translate these coordinates to native device coordinates. To reiterate
our progress in the perspective of rendering, we just defined our local
space with tile coordinates. Local coordinates are the coordinates of
the object to be rendered relative to its local origin<sup class="footnote-reference" id="fr-13-1"><a href="#footnote-13">6</a></sup>. In this
case, the objects are the map tiles. The next step in traditional
rendering workflow is to translate object coordinates to world
coordinates. This is important to understand if we are to render
multiple objects in the world. If we treat all tiles in a zoom level
being rendered in a single 3D horizontal plane, then the World Space has
only one object. And in MapLibre Native, this plane has an origin of (0,0),
positioned on the top left.</p>
<h2 id="device-coordinates"><a class="header" href="#device-coordinates">Device Coordinates</a></h2>
<p>World space for MapLibre Native contains a plane in 3D with all the
tiles for any specific zoom level. Map tiles are hierarchical in nature.
As in they have different zoom levels. MapLibre Native internally
stores a tree object that mimics a tile pyramid. However, it does not
create a hierarchy of 3D planes where each plane mimics one zoom level.
It reuses the same 3D plane to re-render the tiles in the requested zoom
level at a time.</p>
<p>The journey towards rendering the tiles in the device screen from the
world space starts with <em>View Matrix</em>, as defined in the world space.
The key part here is the <em>camera</em>. A <em>view matrix</em> is a matrix that
scales, rotates, and translates<sup class="footnote-reference" id="fr-14-1"><a href="#footnote-14">7</a></sup> the world space from the view of
the camera. To add the perspective of the camera, we apply the
<em>Projection Matrix</em>. In MapLibre Native, a camera initialization
requires map center, bearing, and pitch.</p>
<p><em>Initializing the map with a center (lon, lat) does not translate or
move the 3D plane with tiles, rather moves the camera atop the defined
position named center. In the rendering world, this is not the center of
the 3D plane we render tiles on, rather the position of the camera.</em></p>
<p><img src="media/perspective-frustum.png" alt="" />
<em>Figure 3: Perspective Frustum (Sourced from learnopengl.com)</em></p>
<p>The benefit of tile coordinates continues here. The camera representation
we use here, to be specific the view matrix, can directly take the tile
coordinates to move the camera to a particular tile in a zoom level.
Once a tile is built, the GPU can quickly draw the same tile with different
bearing, pan, pitch, and zoom parameters<sup class="footnote-reference" id="fr-15-1"><a href="#footnote-15">8</a></sup>.</p>
<p>If we keep following Figure 2, we see we need to also add a projection
matrix. And MapLibre Native uses a <em>perspective projection</em>.
Perspective projection matrix introduces the sense of depth perspective
through the camera. As in objects further from the camera will look
smaller and objects closer to the camera will look bigger. This
perspective component is defined by parameter <em>w.</em> That is why the
shaders that MapLibre Native at the time of writing uses 4
dimensional vectors over 3 dimensional vectors. The 4^th^ dimension is
this parameter <em>w</em>. Therefore, theoretically a GL coordinate is of the
form <code>(x, y, z, w)</code>.</p>
<p>Before we jump into the transformations, let's revisit an example
scenario:</p>
<pre><code>zoom: 11.6
map center: (38.891, -77.0822)
bearing: -23.2 degrees
pitch: 45 degrees
tile: 585/783/11
</code></pre>
<p>On top of this, MapLibre Native uses a field of view of 36.87 degrees
or 0.6435011087932844 radians. This is somewhat arbitrary. The altitude
of the camera used to be defined as 1.5 screen heights above the ground.
The ground is the 3D plane that paints the map tiles. The field of view
is derived from the following formula:</p>
<pre><code>fov = 2 * arctan((height / 2) / (height * 1.5))
</code></pre>
<p>Factoring only the transformations of zoom, map center, bearing, pitch,
and tile in, with a viewport of 862 by 742 pixels, the projection matrix
will look like<sup class="footnote-reference" id="fr-16-1"><a href="#footnote-16">9</a></sup>:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>x</strong></th><th><strong>y</strong></th><th><strong>z</strong></th><th><strong>w</strong></th></tr></thead><tbody>
<tr><td><strong>x</strong></td><td>0.224</td><td>-0.079</td><td>-0.026</td><td>-0.026</td></tr>
<tr><td><strong>y</strong></td><td>-0.096</td><td>-0.184</td><td>-0.062</td><td>-0.061</td></tr>
<tr><td><strong>z</strong></td><td>0.000</td><td>0.108</td><td>-0.036</td><td>-0.036</td></tr>
<tr><td><strong>w</strong></td><td>-503.244</td><td>1071.633</td><td>1469.955</td><td>1470.211</td></tr>
</tbody></table>
</div>
<p>To use our <em>tile coordinates,</em> we will turn it to a 4D vector of
(x,y,z,w) with neutral w value 1. For brevity we used z value of 0. For
buildings and extrusions z value will not be 0. But this document does
not cover that.</p>
<p>So, tile coordinate <code>(x: 6120, y: 4151, z:0, w:1)</code> will transform to the
following due to a vector multiplication with the projection matrix:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>x</strong></th><th><strong>y</strong></th><th><strong>z</strong></th><th><strong>w</strong></th></tr></thead><tbody>
<tr><td><strong>x = 6120</strong></td><td>0.2240.224 * 6120 = 1370.88</td><td>-0.079 * 6120 = -483.48</td><td>-0.026 * 6120 = -159.12</td><td>-0.026 * 6120 = -159.12</td></tr>
<tr><td><strong>z = 4151</strong></td><td>-0.096 * 4151 = -398.496</td><td>-0.184 * 4151 = -763.784</td><td>-0.062 * 4151 = -257.362</td><td>-0.061 * 4151 = 253.311</td></tr>
<tr><td><strong>z = 0</strong></td><td>0.000 * 0 = 0</td><td>0.108 * 0 = 0</td><td>-0.036 * 0 = 0</td><td>-0.036 * 0 = 0</td></tr>
<tr><td><strong>w = 1</strong></td><td>-503.244 * 1 = -503.244</td><td>1071.633 * 1 = 1071.633</td><td>1469.955 * 1 = 1469.955</td><td>1470.211 * 1 = 1470.211</td></tr>
<tr><td><strong>Final Vector</strong></td><td>469.14</td><td>-175.631</td><td>1053.473</td><td>1057.78</td></tr>
</tbody></table>
</div>
<p>The finalized vector is off from what we have expected with the result
from the simulation. This is due to multiplying with low precision.</p>
<p>The final vector will be <code>(x: 472.1721, y: -177.8471, z: 1052.9670, w: 1053.7176)</code>. This is not perspective normalized. Perspective
normalization happens when we divide all the components of this vector
with perspective component <em>w</em>.</p>
<pre><code>(472.1721 / 1053.72, -177.8471 / 1053.72, 1052.9670 / 1053.72)
= (x: 0.4481, y: -0.1688, z: 0.9993)
</code></pre>
<p>Doing this will take us into <em>clip space.</em> Clip coordinates contain all
the tile coordinates we wish to render in MapLibre Native but only in
a normalized coordinate space of <code>[-1.0, 1.0]</code>.</p>
<p>All that is left now is to translate this to viewport coordinates.
Following Figure 2, we use <em>viewport transform</em> to produce these
coordinates:</p>
<pre><code>Pixel Coordinates: (NormalizedX * width + width / 2, height / 2 -
NormalizedY * height)
 = (0.4481 * 862 + 431, 371 - (-0.1688 * 742))
 = (x: 624, y: 434)
</code></pre>
<p>These are our viewport screen coordinates where our desired WGS84
location longitude -77.035915 and latitude 38.889814 will be rendered.</p>
<hr />
<hr>
<ol class="footnote-definition"><li id="footnote-8">
<p>Clip coordinates are normalized to -1.0 to 1.0. For brevity, this
document does not dive deep into 3D rendering basics. <a href="#fr-8-1">↩</a></p>
</li>
<li id="footnote-9">
<p>For brevity, this document is assuming the world we live in is
three dimensional. <a href="#fr-9-1">↩</a></p>
</li>
<li id="footnote-10">
<p>For brevity, this document does not dive deep into reference
ellipsoids to approximates earth, also known as Datums. EPSG:4326 or
WGS84 is such a Datum or reference ellipsoid. <a href="#fr-10-1">↩</a></p>
</li>
<li id="footnote-11">
<p>There are other coordinate systems such as EPSG:54001 that uses
equirectangles over squares to project the WGS84 coordinates. This
document focuses on EPSG:3857 because MapLibre Native uses it by
default. <a href="#fr-11-1">↩</a></p>
</li>
<li id="footnote-12">
<p>This document scopes out the trigonometric proof of this
translation for brevity. To know more:
<a href="https://en.wikipedia.org/wiki/Web_Mercator_projection">https://en.wikipedia.org/wiki/Web_Mercator_projection</a> <a href="#fr-12-1">↩</a></p>
</li>
<li id="footnote-13">
<p>For brevity, this document does not speak in depth of rendering
basics in regards to coordinate systems. For more, please check:
<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">https://learnopengl.com/Getting-started/Coordinate-Systems</a> <a href="#fr-13-1">↩</a></p>
</li>
<li id="footnote-14">
<p>Scale, rotate, and translate are common rendering transformation
used to produce model, view, and projection matrices. These
operations are applied right to left. As in translate first, rotate
second, and scale last. Matrix multiplications are not commutative,
so order of operation matters. <a href="#fr-14-1">↩</a></p>
</li>
<li id="footnote-15">
<p>The piece of code we run on GPU is called a shader. We will see
more how shaders influence MapLibre Native rendering later in the
document. <a href="#fr-15-1">↩</a></p>
</li>
<li id="footnote-16">
<p>Matrix and examples produced from Chris Loers work hosted in:
<a href="https://chrisloer.github.io/mapbox-gl-coordinates/#11.8/38.895/-77.0757/40/60">https://chrisloer.github.io/mapbox-gl-coordinates/#11.8/38.895/-77.0757/40/60</a> <a href="#fr-16-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design/ten-thousand-foot-view.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../design/expressions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design/ten-thousand-foot-view.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../design/expressions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
