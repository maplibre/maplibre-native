<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MapLibre Native Developer Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6.0/+esm';
        
        const darkThemes = ['ayu', 'navy', 'coal'];
        const lightThemes = ['light', 'rust'];
        
        const classList = document.getElementsByTagName('html')[0].classList;
        
        let lastThemeWasLight = true;
        for (const cssClass of classList) {
            if (darkThemes.includes(cssClass)) {
                lastThemeWasLight = false;
                break;
            }
        }
        
        const theme = lastThemeWasLight ? 'default' : 'dark';
        mermaid.initialize({ startOnLoad: true, theme });
        
        // Simplest way to make mermaid re-render the diagrams in the new theme is via refreshing the page
        
        for (const darkTheme of darkThemes) {
            document.getElementById(darkTheme).addEventListener('click', () => {
                if (lastThemeWasLight) {
                    window.location.reload();
                }
            });
        }
        
        for (const lightTheme of lightThemes) {
            document.getElementById(lightTheme).addEventListener('click', () => {
                if (!lastThemeWasLight) {
                    window.location.reload();
                }
            });
        }
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-735396af.svg">
        <link rel="shortcut icon" href="favicon-e797cf1c.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="diff-a3e96580.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-7ea106a5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-fd1359ca.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">MapLibre Native Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em><a href="https://github.com/maplibre/maplibre-native">MapLibre Native</a></em> is a community led fork of <em>Mapbox GL Native</em>. It’s a C++ library that powers
vector maps in native applications on multiple platforms by taking stylesheets that conform to the <em><a href="https://maplibre.org/maplibre-style-spec/">MapLibre Style Specification</a></em>, a fork of the
Mapbox Style Spec. Since it is derived from Mapbox’s original work it also uses <em>Mapbox Vector Tile Specification</em> as its choice of vector tile format.</p>
<p>This documentation is intended for developers of MapLibre Native. If you are interested in <em>using</em> MapLibre Native, check out the <a href="https://github.com/maplibre/maplibre-native?tab=readme-ov-file#maplibre-native">main <code>README.md</code></a> on GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="platforms"><a class="header" href="#platforms">Platforms</a></h1>
<p>This page describes the platforms that MapLibre Native is available on.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>MapLibre Native uses a monorepo. Source code for all platforms lives in <a href="https://github.com/maplibre/maplibre-native"><code>maplibre/maplibre-native</code></a> on GitHub.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Source</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Android</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/android"><code>platform/android</code></a></td><td>Integrates with the C++ core via JNI.</td></tr>
<tr><td>iOS</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/ios"><code>platform/ios</code></a>, <a href="https://github.com/maplibre/maplibre-native/tree/main/platform/darwin"><code>platform/darwin</code></a></td><td>Integrates with the C++ core via Objective-C++.</td></tr>
<tr><td>Linux</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/linux"><code>platform/linux</code></a></td><td>Used for development. Also widely used in production for raster tile generation.</td></tr>
<tr><td>Windows</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/windows"><code>platform/windows</code></a></td><td></td></tr>
<tr><td>macOS</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/macos"><code>platform/macos</code></a>, <a href="https://github.com/maplibre/maplibre-native/tree/main/platform/darwin"><code>platform/darwin</code></a></td><td>Mainly used for development. There is some legacy AppKit code.</td></tr>
<tr><td>Node.js</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/node"><code>platform/node</code></a></td><td>Uses <a href="https://github.com/nodejs/nan">NAN</a>. Available as <a href="https://www.npmjs.com/package/@maplibre/maplibre-gl-native">@maplibre/maplibre-gl-native</a> on npm.</td></tr>
<tr><td>Qt</td><td><a href="https://github.com/maplibre/maplibre-native/tree/main/platform/qt">maplibre/maplibre-qt</a>, <a href="https://github.com/maplibre/maplibre-native"><code>platform/qt</code></a></td><td>Only platform that partially split to another repository.</td></tr>
</tbody>
</table>
</div>
<p>Of these, <strong>Android</strong> and <strong>iOS</strong> are considered <a href="https://github.com/maplibre/maplibre/blob/main/PROJECT_TIERS.md">core projects</a> of the MapLibre Organization.</p>
<h3 id="glfw"><a class="header" href="#glfw">GLFW</a></h3>
<p>You can find an app that uses GLFW in <a href="https://github.com/maplibre/maplibre-native/tree/main/platform/glfw"><code>platform/glfw</code></a>. It works on macOS, Linux and Windows. The app shows an interactive map that can be interacted with. Since GLFW adds relatively little complexity this app is used a lot for development. You can also learn about the C++ API by studying the source code of the GLFW app.</p>
<h2 id="rendering-backends"><a class="header" href="#rendering-backends">Rendering Backends</a></h2>
<p>Originally the project only supported OpenGL 2.0. In 2023, the <a href="https://github.com/maplibre/maplibre-native/blob/main/design-proposals/2022-10-27-rendering-modularization.md">renderer was modularized</a> allowing for the implementation of alternate rendering backends. The first alternate rendering backend that was implemented was <a href="https://maplibre.org/news/2024-01-19-metal-support-for-maplibre-native-ios-is-here/">Metal</a>, followed by <a href="https://maplibre.org/news/2024-12-12-maplibre-android-vulkan/">Vulkan</a>. In the future other rendering backends could be implemented such as WebGPU.</p>
<p>What platforms support which rendering backend can be found below.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>OpenGL ES 3.0</th><th>Vulkan 1.0</th><th>Metal</th><th>WebGPU</th></tr>
</thead>
<tbody>
<tr><td>Android</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>iOS</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr><td>Linux</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td></tr>
<tr><td>Windows</td><td>✅</td><td>❌</td><td>❌</td><td>❓</td></tr>
<tr><td>macOS</td><td>❌</td><td>✅</td><td>✅<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></td><td>✅</td></tr>
<tr><td>Node.js</td><td>✅</td><td>❌</td><td>✅<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></td><td>❌</td></tr>
<tr><td>Qt</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
</tbody>
</table>
</div>
<h2 id="build-tooling"><a class="header" href="#build-tooling">Build Tooling</a></h2>
<p>In 2023 we co-opted Bazel as a build tool (generator), mostly due to it having better support for iOS compared to CMake. Some platforms can use CMake as well as Bazel.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>CMake</th><th>Bazel</th></tr>
</thead>
<tbody>
<tr><td>Android</td><td>✅ (via Gradle)</td><td>❌</td></tr>
<tr><td>iOS</td><td>✅<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></td><td>✅</td></tr>
<tr><td>Linux</td><td>✅</td><td>✅</td></tr>
<tr><td>Windows</td><td>✅</td><td>✅</td></tr>
<tr><td>macOS</td><td>✅</td><td>✅</td></tr>
<tr><td>Node.js</td><td>✅</td><td>❌</td></tr>
<tr><td>Qt</td><td>✅</td><td>❌</td></tr>
</tbody>
</table>
</div>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p>Requires MoltenVK. Only available when built via CMake. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Issue reported, see <a href="https://github.com/maplibre/maplibre-native/issues/2928">#2928</a>. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Some targets are supported, see <a href="platforms/ios/README.html#cmake">here</a>. <a href="#fr-3-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maplibre-android-developer-guide"><a class="header" href="#maplibre-android-developer-guide">MapLibre Android Developer Guide</a></h1>
<p>These instructions are for developers interested in making code-level contributions to MapLibre Native for Android.</p>
<h2 id="getting-the-source"><a class="header" href="#getting-the-source">Getting the source</a></h2>
<p>Clone the git repository and pull in submodules:</p>
<pre><code class="language-bash">git clone git@github.com:maplibre/maplibre-native.git
cd maplibre-native
git submodule update --init --recursive
cd platform/android
</code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p><a href="https://developer.android.com/studio">Android Studio</a> needs to be installed.</p>
<p>Open the <code>platform/android</code> directory to get started.</p>
<h2 id="setting-an-api-key"><a class="header" href="#setting-an-api-key">Setting an API Key</a></h2>
<p><em>The test application (used for development purposes) uses MapTiler vector tiles, which require a MapTiler account and API key.</em></p>
<p>With the first Gradle invocation, Gradle will take the value of the <code>MLN_API_KEY</code> environment variable and save it to <code>MapLibreAndroidTestApp/src/main/res/values/developer-config.xml</code>. If the environment variable wasn’t set, you can edit <code>developer-config.xml</code> manually and add your API key to the <code>api_key</code> resource.</p>
<h2 id="running-the-testapp"><a class="header" href="#running-the-testapp">Running the TestApp</a></h2>
<p>Run the configuration for the <code>MapLibreAndroidTestApp</code> module and select a device or emulator to deploy on.</p>
<p align="left">
  <img src="https://github.com/maplibre/maplibre-native/assets/649392/5494925e-8cbb-4d5d-8033-8a2f141ede3c" alt="Android TestApp menu" width="15%">   <img src="https://github.com/maplibre/maplibre-native/assets/649392/f169db51-615d-4fca-b297-ac6197bec674" alt="Android TestApp showing Demotiles" width="15%">
</p>

<h2 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h2>
<p>All new code should be written in <a href="https://kotlinlang.org/">Kotlin</a>.</p>
<h2 id="style-checking"><a class="header" href="#style-checking">Style Checking</a></h2>
<p>To check Kotlin style, we use <a href="https://pinterest.github.io/ktlint/">ktlint</a>. This linter is based on the <a href="https://kotlinlang.org/docs/coding-conventions.html">official Kotlin coding conventions</a>. We intergrate with it using the <a href="https://github.com/jeremymailen/kotlinter-gradle">kotlinder</a> Gradle plugin.</p>
<p>To check the style of all Kotlin source files, use:</p>
<pre><code>$ ./gradlew checkStyle
</code></pre>
<p>To format all Kotlin source files, use:</p>
<pre><code>$ ./gradlew formatKotlin
</code></pre>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>See <a href="/profiling/tracy-profiling.html">Tracy Profiling</a> to understand how Tracy can be used for profiling.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maplibre-android-tests"><a class="header" href="#maplibre-android-tests">MapLibre Android Tests</a></h1>
<h2 id="render-tests"><a class="header" href="#render-tests">Render Tests</a></h2>
<p>To run the render tests for Android, run the configuration for the <code>androidRenderTest.app</code> module.</p>
<h3 id="filtering-render-tests"><a class="header" href="#filtering-render-tests">Filtering Render Tests</a></h3>
<p>You can filter the tests to run by passing a flag to the file <code>platform/android/src/test/render_test_runner.cpp</code>:</p>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; arguments = {..., "-f", "background-color/literal"};
</code></pre>
<h3 id="viewing-the-results"><a class="header" href="#viewing-the-results">Viewing the Results</a></h3>
<p>Once the application quits, use the Device Explorer to navigate to <code>/data/data/org.maplibre.render_test_runner/files</code>.</p>
<img width="980" alt="image" src="https://github.com/maplibre/maplibre-native/assets/649392/0dc42d4a-6221-46b6-8352-1eb24d466e91">
<p>Double click <code>android-render-test-runner-style.html</code>. Right click on the opened tab and select <em>Open In &gt; Browser</em>. You should see that a single render test passed.</p>
<img width="801" alt="image" src="https://github.com/maplibre/maplibre-native/assets/649392/33e88999-7787-492f-afd9-f5a3e3fd61f7">
<p>Alternatively to download (and open) the results from the command line, use:</p>
<pre><code>filename=android-render-test-runner-style.html
adb shell "run-as org.maplibre.render_test_runner cat files/metrics/$filename" &gt; $filename
open $filename
</code></pre>
<p>For Vulkan use</p>
<pre><code>filename=android-vulkan-render-test-runner-style.html
</code></pre>
<h3 id="updating-the-render-tests"><a class="header" href="#updating-the-render-tests">Updating the Render Tests</a></h3>
<p>Now let’s edit <code>metrics/integration/render-tests/background-color/literal/style.json</code>, change this line:</p>
<pre><code>        "background-color": "red"
</code></pre>
<p>to</p>
<pre><code>        "background-color": "yellow"
</code></pre>
<p>We need to make sure that the new <code>data.zip</code> with the data for the render tests is installed on the device. You can use the following commands:</p>
<pre><code>tar chf render-test/android/app/src/main/assets/data.zip --format=zip --files-from=render-test/android/app/src/main/assets/to_zip.txt
adb push render-test/android/app/src/main/assets/data.zip /data/local/tmp/data.zip
adb shell chmod 777 /data/local/tmp/data.zip
adb shell "run-as org.maplibre.render_test_runner unzip -o /data/local/tmp/data.zip -d files"
</code></pre>
<p>Rerun the render test app and reload the Device Explorer. When you re-open the HTML file with the results you should now see a failing test:</p>
<img width="685" alt="image" src="https://github.com/maplibre/maplibre-native/assets/649392/303ad75a-cf74-4b8c-927c-c9bd59a79de4">
<p>Now download the <code>actual.png</code> in <code>metrics/integration/render-tests/background-color/literal</code> with the Device Explorer. Replace the corresponding <code>expected.png</code> on your local file system. Upload the new render test data again and run the test app once more.</p>
<img width="800" alt="image" src="https://github.com/maplibre/maplibre-native/assets/649392/04734c6a-9cf1-489a-b9bb-8d857581261c">
<p>Of we don’t want to commit this change. But know you can add and debug (Android) render tests.</p>
<h2 id="instrumentation-tests"><a class="header" href="#instrumentation-tests">Instrumentation Tests</a></h2>
<p>To run the instrumentation tests, choose the “Instrumentation Tests” run configuration.</p>
<p>Your device needs remain unlocked for the duration of the tests.</p>
<h2 id="c-unit-tests"><a class="header" href="#c-unit-tests">C++ Unit Tests</a></h2>
<p>There is a separate Gradle project that contains a test app which runs the C++ Unit Tests. It does not depend on the Android platform implementations.</p>
<p>You can find the project in <code>test/android.</code> You can open this project in Android Studio and run the C++ Tests on an Android device or Simulator.</p>
<p>To run a particular set of tests you can modify the <code>--gtest_filter</code> flag in <code>platform/android/src/test/test_runner.cpp</code>. See the <a href="https://google.github.io/googletest/advanced.html#running-a-subset-of-the-tests">GoogleTest documentation</a> for details how to use this flag.</p>
<h3 id="aws-device-farm"><a class="header" href="#aws-device-farm">AWS Device Farm</a></h3>
<p>The instrumentation tests and C++ unit tests are running on AWS Device Farm. To see the results and the logs, go to:</p>
<p><a href="https://us-west-2.console.aws.amazon.com/devicefarm/home?region=us-east-1#/mobile/projects/20687d72-0e46-403e-8f03-0941850665bc/runs">https://us-west-2.console.aws.amazon.com/devicefarm/home?region=us-east-1#/mobile/projects/20687d72-0e46-403e-8f03-0941850665bc/runs</a>.</p>
<p>Use the following login details (this is a read-only account):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th></th></tr>
</thead>
<tbody>
<tr><td>Alias</td><td><code>maplibre</code></td></tr>
<tr><td>Username</td><td><code>maplibre</code></td></tr>
<tr><td>Password</td><td><code>maplibre</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="documentation-for-maplibre-android"><a class="header" href="#documentation-for-maplibre-android">Documentation for MapLibre Android</a></h1>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>We use Dokka for the MapLibre Android API documentation. The live documentation site can be found <a href="https://maplibre.org/maplibre-native/android/api/">here</a>.</p>
<h2 id="examples-documentation"><a class="header" href="#examples-documentation">Examples Documentation</a></h2>
<p>The documentation site with examples uses MkDocs along with <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a>. You can check out the site <a href="https://maplibre.org/maplibre-native/android/examples/">here</a>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>To build the Examples Documentation you need to have Docker installed.</p>
<p>From <code>platform/android</code>, run:</p>
<pre><code>make mkdocs
</code></pre>
<p>Next, visit <a href="http://localhost:8000/maplibre-native/android/examples/"><code>http://localhost:8000/maplibre-native/android/examples/</code></a>.</p>
<h3 id="snippets"><a class="header" href="#snippets">Snippets</a></h3>
<p>We use <a href="https://facelessuser.github.io/pymdown-extensions/extensions/snippets/#snippet-sections">a Markdown extension for snippets</a>. This way code can be referenced instead of copy pasted into the documentation. This avoids code examples from becoming out of date or failing to compile. The syntax is as follows:</p>
<pre><code class="language-kotlin">// --8&lt;-- [start:fun]
fun double(x: Int): Int {
    return 2 * x
}
// --8&lt;-- [end:fun]
</code></pre>
<p>Next, you’ll be able to reference that piece of code in Markdown like so:</p>
<pre><code>--8&lt;-- "example.kt:fun"
</code></pre>
<p>Where <code>example.kt</code> is the path to the file.</p>
<h3 id="static-assets"><a class="header" href="#static-assets">Static Assets</a></h3>
<p>Static assets are ideally uploaded to the <a href="https://maplibre-native.s3.eu-central-1.amazonaws.com/index.html#android-documentation-resources/">MapLibre Native S3 Bucket</a>.</p>
<p>Please open an issue with the ARN of your AWS account to get upload privileges.</p>
<p>You can use the macro <code>{{ s3_url("filename.example") }}</code> which will use a CDN instead of linking to the S3 bucket directly.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>We have created a rendering performance benchmark for Android. The logic for this benchmark is encapsulated in <code>BenchMarkActivity.kt</code>.</p>
<h2 id="styles"><a class="header" href="#styles">Styles</a></h2>
<p>We have hardcoded various styles, which you can override with a <code>developer-config.xml</code> by adding some XML with the following structure:</p>
<pre><code>&lt;array name="benchmark_style_names"&gt;
  &lt;item&gt;Americana&lt;/item&gt;
&lt;/array&gt;
&lt;array name="benchmark_style_urls"&gt;
  &lt;item&gt;https://americanamap.org/style.json&lt;/item&gt;
&lt;/array&gt;
</code></pre>
<h2 id="retrieving-results"><a class="header" href="#retrieving-results">Retrieving Results</a></h2>
<p>Results are logged to the console as they come in. After the benchmark is done running a <code>benchmark_results.json</code> file is generated. You can pull it off the device with for example adb:</p>
<pre><code>adb shell "run-as org.maplibre.android.testapp cat files/benchmark_results.json" \
  &gt; benchmark_results.json
</code></pre>
<h2 id="results"><a class="header" href="#results">Results</a></h2>
<p>The <code>benchmark_results.json</code> containing the benchmark results will have the following structure.</p>
<pre><code class="language-json">{
  "results": [
    {
      "styleName": "AWS Open Data Standard Light",
      "syncRendering": true,
      "thermalState": 0,
      "fps": 34.70237085812839,
      "avgEncodingTime": 19.818289053808947,
      "avgRenderingTime": 7.7432454899654255,
      "low1pEncodingTime": 91.72538138784371,
      "low1pRenderingTime": 26.573758581509203
    },
  ],
  "deviceManufacturer": "samsung",
  "model": "SM-G973F",
  "renderer": "drawable",
  "debugBuild": true,
  "gitRevision": "fc95b79880223e34c2ce80339f698d095e3d63cd",
  "timestamp": 1736454325393
}
</code></pre>
<p>The meaning of the keys is as follows.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>styleName</td><td>Name of the style being benchmarked</td></tr>
<tr><td>syncRendering</td><td>Whether synchronous rendering was used</td></tr>
<tr><td>thermalState</td><td>Thermal state of the device during benchmark</td></tr>
<tr><td>fps</td><td>Average frames per second achieved during the benchmark</td></tr>
<tr><td>avgEncodingTime</td><td>Average time taken for encoding in milliseconds</td></tr>
<tr><td>avgRenderingTime</td><td>Average time taken for rendering in milliseconds</td></tr>
<tr><td>low1pEncodingTime</td><td>1st percentile (worst case) encoding time in milliseconds</td></tr>
<tr><td>low1pRenderingTime</td><td>1st percentile (worst case) rendering time in milliseconds</td></tr>
<tr><td>deviceManufacturer</td><td>Manufacturer of the test device</td></tr>
<tr><td>model</td><td>Model number/name of the test device</td></tr>
<tr><td>renderer</td><td>Type of renderer used (<code>drawable</code> for Open GL ES, <code>vulkan</code> for Vulkan, <code>legacy</code> for the legacy Open GL ES rendering backend)</td></tr>
<tr><td>debugBuild</td><td>Whether the build was a debug build</td></tr>
<tr><td>gitRevision</td><td>Git commit hash of the code version</td></tr>
<tr><td>timestamp</td><td>Unix timestamp of when the benchmark was run</td></tr>
</tbody>
</table>
</div>
<h2 id="large-scale-benchmarks-on-aws-device-farm"><a class="header" href="#large-scale-benchmarks-on-aws-device-farm">Large Scale Benchmarks on AWS Device Farm</a></h2>
<p>Sometimes we do a large scale benchmark across a variety of devices on AWS Device Farm. We ran one such test in <a href="https://github.com/maplibre/maplibre-native/issues/2787#issuecomment-2466948888">November 2024</a> to compare the performance of the then new Vulkan rendering backend against the OpenGL ES backend. There are some scripts in the repo to kick off the tests and to collect and plot the results:</p>
<pre><code>scripts/aws-device-farm/aws-device-farm-run.sh
scripts/aws-device-farm/collect-benchmark-outputs.mjs
scripts/aws-device-farm/update-benchmark-db.mjs
scripts/aws-device-farm/plot-android-benchmark-results.py
</code></pre>
<h2 id="continuous-benchmarking"><a class="header" href="#continuous-benchmarking">Continuous Benchmarking</a></h2>
<p>We are running the Android benchmark on every merge with <code>main</code>.</p>
<p>You can find the results per commit <a href="https://maplibre-native.s3.eu-central-1.amazonaws.com/index.html#android-benchmark-render/">here</a> or pull them from our public S3 bucket:</p>
<pre><code>aws s3 sync s3://maplibre-native/android-benchmark-render/ .
</code></pre>
<h2 id="benchmarks-in-pull-request"><a class="header" href="#benchmarks-in-pull-request">Benchmarks in Pull Request</a></h2>
<p>To run the benchmarks (for Android) include the following line on a PR comment:</p>
<pre><code>!benchmark android
</code></pre>
<p>A file with the benchmark results will be added to the workflow summary, which you can compare with the previous results in the bucket.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-maplibre-android"><a class="header" href="#release-maplibre-android">Release MapLibre Android</a></h1>
<p>We make MapLibre Android releases as a downloadable asset on <a href="https://github.com/maplibre/maplibre-native/releases?q=android&amp;expanded=true">GitHub</a> as well as to <a href="https://central.sonatype.com/artifact/org.maplibre.gl/android-sdk/versions">Maven Central</a>. Specifically we make use of a Sonatype OSSHR repository provided by Maven Central.</p>
<p>Also see the current <a href="platforms/release-policy.html">release policy</a>.</p>
<h2 id="making-a-release"><a class="header" href="#making-a-release">Making a release</a></h2>
<p>To make an Android release, do the following:</p>
<ol>
<li>
<p>Prepare a PR.</p>
<ul>
<li>
<p>Update <a href="https://github.com/maplibre/maplibre-native/blob/main/platform/android/CHANGELOG.md"><code>CHANGELOG.md</code></a> in a PR, see for example <a href="https://github.com/maplibre/maplibre-native/pull/3194">this PR</a>. The changelog should contain links to all relevant PRs for Android since the last release. You can use the script below with a <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">GitHub access token</a> with the <code>public_repo</code> scope. You will need to filter out PRs that do not relate to Android and categorize PRs as features or bugfixes.</p>
<pre><code>GITHUB_ACCESS_TOKEN=... node scripts/generate-changelog.mjs android
</code></pre>
<p>The heading in the changelog must match <code>## &lt;VERSION&gt;</code> exactly, or it will not be picked up. For example, for version 9.6.0:</p>
<pre><code class="language-md">## 9.6.0
</code></pre>
</li>
<li>
<p>Update <code>android/VERSION</code> with the new version.</p>
</li>
</ul>
</li>
<li>
<p>Once the PR is merged, the <a href="https://github.com/maplibre/maplibre-native/blob/main/.github/workflows/android-release.yml"><code>android-release.yml</code></a> workflow will run automatically to make the release.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maplibre-ios-developer-guide"><a class="header" href="#maplibre-ios-developer-guide">MapLibre iOS Developer Guide</a></h1>
<h2 id="bazel"><a class="header" href="#bazel">Bazel</a></h2>
<p><a href="https://bazel.build/">Bazel</a> is used for building on iOS.</p>
<p>You can generate an Xcode project thanks to <a href="https://github.com/MobileNativeFoundation/rules_xcodeproj">rules_xcodeproj</a> intergration.</p>
<p>You need to install <a href="https://github.com/bazelbuild/bazelisk">bazelisk</a>, which is a wrapper around Bazel which ensures that the version specified in <code>.bazelversion</code> is used.</p>
<pre><code>brew install bazelisk
</code></pre>
<h3 id="creating-configbzl"><a class="header" href="#creating-configbzl">Creating <code>config.bzl</code></a></h3>
<p>Configure Bazel, otherwise the default config will get used.</p>
<pre><code>cp platform/darwin/bazel/example_config.bzl platform/darwin/bazel/config.bzl
</code></pre>
<p>You need to set your <code>BUNDLE_ID_PREFIX</code> to be unique (ideally use a domain that you own in reverse domain name notation).</p>
<p>You can keep leave the <code>APPLE_MOBILE_PROVISIONING_PROFILE_NAME</code> alone.</p>
<p>Set the Team ID to the Team ID of your Apple Developer Account (paid or unpaid both work). If you do not know your Team ID, go to your <a href="https://developer.apple.com/account">Apple Developer account</a>, log in, and scroll down to find your Team ID.</p>
<p>If you don’t already have a developer account, continue this guide and let Xcode generate a provisioning profile for you. You will need to update the Team ID later once a certificate is generated.</p>
<h2 id="create-the-xcode-project"><a class="header" href="#create-the-xcode-project">Create the Xcode Project</a></h2>
<p>Run the following commands:</p>
<pre><code>bazel run //platform/ios:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags="--//:renderer=metal"
xed platform/ios/MapLibre.xcodeproj
</code></pre>
<p>Then once in Xcode, click on “MapLibre” on the left, then “App” under Targets, then “Signing &amp; Capabilities” in the tabbed menu.
Confirm that no errors are shown.</p>
<img width="921" alt="image" src="https://github.com/polvi/maplibre-native/assets/649392/a1ef30cb-97fc-429a-acee-194436f3fb8a">
<p>Try to run the example App in the simulator and on a device to confirm your setup works.</p>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>The Bazel configuration files are the source of truth of the build configuration. All changes to the build settings need to be done through Bazel, not in Xcode.</p>
</blockquote>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<h4 id="provisioning-profiles"><a class="header" href="#provisioning-profiles">Provisioning Profiles</a></h4>
<p>If you get a Python <code>KeyError</code> when processing provisioning profiles, you probably have some <em>really</em> old or corrupted profiles.</p>
<p>Have a look through <code>~/Library/MobileDevice/Provisioning\ Profiles</code> and remove any expired profiles. Removing all profiles here can also resolve some issues.</p>
<h4 id="cleaning-bazel-environments"><a class="header" href="#cleaning-bazel-environments">Cleaning Bazel environments</a></h4>
<p>You should almost never have to do this, but sometimes problems can be solved with:</p>
<pre><code>bazel clean --expunge
</code></pre>
<h2 id="using-bazel-from-the-command-line"><a class="header" href="#using-bazel-from-the-command-line">Using Bazel from the Command Line</a></h2>
<p>It is also possible to build and run the test application in a simulator from the command line without opening Xcode.</p>
<pre><code>bazel run //platform/ios:App --//:renderer=metal
</code></pre>
<p>You can also build targets from the command line. For example, if you want to build your own XCFramework, see the ‘Build XCFramework’ step in the <a href=".github/workflows/ios-ci.yml">iOS CI workflow</a>.</p>
<h2 id="cmake"><a class="header" href="#cmake">CMake</a></h2>
<p>It is also possible to generate an Xcode project using CMake. As of February 2025, targets <code>mbgl-core</code>, <code>ios-sdk-static</code> and <code>app</code> (Objective-C development app) are supported.</p>
<pre><code>cmake --preset ios -DDEVELOPMENT_TEAM_ID=YOUR_TEAM_ID
xed build-ios/MapLibre\ Native.xcodeproj
</code></pre>
<h2 id="distribution"><a class="header" href="#distribution">Distribution</a></h2>
<p>MapLibre iOS is distributed as an XCFramework via the <a href="https://github.com/maplibre/maplibre-gl-native-distribution">maplibre/maplibre-gl-native-distribution</a> repository. See <a href="#release-maplibre-ios">Release MapLibre iOS</a> for the release process. Refer to the <a href="https://github.com/maplibre/maplibre-native/blob/main/.github/workflows/ios-ci.yml"><code>ios-ci.yml</code></a> workflow for an up-to-date recipe for building an XCFramework. As of February 2025 we use:</p>
<pre><code>bazel build --compilation_mode=opt --features=dead_strip,thin_lto --objc_enable_binary_stripping \
  --apple_generate_dsym --output_groups=+dsyms --//:renderer=metal //platform/ios:MapLibre.dynamic --embed_label=maplibre_ios_"$(cat VERSION)"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ios-tests"><a class="header" href="#ios-tests">iOS Tests</a></h1>
<h2 id="ios-unit-tests"><a class="header" href="#ios-unit-tests">iOS Unit Tests</a></h2>
<p>To run the iOS unit tests via XCTest, run tests for the <code>ios_test</code> target in Xcode
or use the following bazel command:</p>
<pre><code>bazel test //platform/ios/test:ios_test --test_output=errors --//:renderer=metal
</code></pre>
<h2 id="render-tests-1"><a class="header" href="#render-tests-1">Render Tests</a></h2>
<p>To run the render tests, run the <code>RenderTest</code> target from iOS.</p>
<p>When running in a simulator, use</p>
<pre><code># check for 'DataContainer' of the app with `*.maplibre.RenderTestApp` id
xcrun simctl listapps booted
</code></pre>
<p>to get the data directory of the render test app. This allows you to inspect test results. When adding new tests, the generated expectations and <code>actual.png</code> file can be copied into the source directory from here.</p>
<h2 id="c-unit-tests-1"><a class="header" href="#c-unit-tests-1">C++ Unit Tests</a></h2>
<p>Run the tests from the <code>CppUnitTests</code> target in Xcode to run the C++ Unit Tests on iOS.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ios-documentation"><a class="header" href="#ios-documentation">iOS Documentation</a></h1>
<p>We use <a href="https://www.swift.org/documentation/docc">DocC</a> for the MapLibre iOS documentation. The live documentation site can be found <a href="https://maplibre.org/maplibre-native/ios/latest/documentation/maplibre/">here</a>.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>You need to have <a href="https://github.com/aws/aws-cli">aws-cli</a> installed to download the resources from S3 (see below). Run the following command:</p>
<pre><code>aws s3 sync --no-sign-request "s3://maplibre-native/ios-documentation-resources" "platform/ios/MapLibre.docc/Resources"
</code></pre>
<p>Then, to build the documentation locally, run the following command:</p>
<pre><code>platform/ios/scripts/docc.sh preview
</code></pre>
<p>Resources like images should not be checked in but should be uploaded to the <a href="https://s3.eu-central-1.amazonaws.com/maplibre-native/index.html#ios-documentation-resources/">S3 Bucket</a>. You can share a <code>.zip</code> with all files that should be added in the PR.</p>
<p>If you want to get direct access you need an AWS account to get permissions to upload files. Create an account and authenticate with aws-cli. Share the account ARN that you can get with</p>
<pre><code>aws sts get-caller-identity
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The code samples in the documentation should ideally be compiled on CI so they do not go out of date.</p>
<p>Fence your example code with</p>
<pre><code class="language-swift">// #-example-code(LineTapMap)
...
// #-end-example-code
</code></pre>
<p>Prefix your documentation code block with</p>
<pre><code class="language-md">&lt;!-- include-example(LineTapMap) --&gt;

```swift
...
```
</code></pre>
<p>Then the code block will be updated when you run:</p>
<pre><code class="language-sh">node scripts/update-ios-examples.mjs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-maplibre-ios"><a class="header" href="#release-maplibre-ios">Release MapLibre iOS</a></h1>
<p>We make iOS releases to GitHub (a downloadable XCFramework), the <a href="https://swiftpackageindex.com/maplibre/maplibre-gl-native-distribution">Swift Package Index</a> and <a href="https://cocoapods.org/">CocoaPods</a>. Everyone with write access to the repository is able to make releases using the instructions below.</p>
<p>Also see the current <a href="platforms/release-policy.html">release policy</a>.</p>
<h2 id="making-a-release-1"><a class="header" href="#making-a-release-1">Making a release</a></h2>
<ol>
<li>
<p>Prepare a PR, see <a href="https://github.com/maplibre/maplibre-native/pull/3193">this PR</a> as an example.</p>
<ul>
<li>Update the <a href="https://github.com/maplibre/maplibre-native/blob/main/platform/ios/CHANGELOG.md">changelog</a>. The changelog should contain links to all relevant PRs for iOS since the last release. You can use the script below with a <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">GitHub access token</a> with the <code>public_repo</code> scope. You will need to filter out PRs that do not relate to iOS.
<pre><code>GITHUB_ACCESS_TOKEN=... node scripts/generate-changelog.mjs ios
</code></pre>
The heading in the changelog must match <code>## &lt;VERSION&gt;</code> exactly, or it will not be picked up. For example, for version 6.0.0:
<pre><code class="language-md">## 6.0.0
</code></pre>
</li>
<li>Update the <code>VERSION</code> file in <code>platform/ios/VERSION</code> with the version to be released. We use <a href="https://semver.org/">semantic versioning</a>, so any breaking changes require a major version bump. Use a minor version bump when functionality has been added in a backward compatible manner, and a patch version bump when the release contains only backward compatible bug fixes.</li>
</ul>
</li>
<li>
<p>Once the PR is merged the <code>ios-ci.yml</code> workflow will detect that the <code>VERSION</code> file is changed, and a release will be made automatically.</p>
</li>
</ol>
<h2 id="pre-release"><a class="header" href="#pre-release">Pre-release</a></h2>
<p>Run the <code>ios-ci</code> workflow. You can use the <a href="https://cli.github.com/manual/gh_workflow_run">GitHub CLI</a>:</p>
<pre><code>gh workflow run ios-ci.yml -f release=pre --ref main
</code></pre>
<p>Or run the workflow from the Actions tab on GitHub.</p>
<p>The items under the <code>## main</code> heading in <code>platform/ios/CHANGELOG.md</code> will be used as changelog for the pre-release.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="development-apps"><a class="header" href="#development-apps">Development Apps</a></h1>
<p>There are two iOS apps available in the repo that you can use for MapLibre Native development. One Objective-C based app and a Swift based app.</p>
<h2 id="objective-c-app"><a class="header" href="#objective-c-app">Objective-C App</a></h2>
<p>This app is available as “App” in the <a href="platforms/ios/README.html">generated Xcode project</a>.</p>
<p>The source code lives in <code>platform/ios/app</code>.</p>
<p>You can also build and run it from the command line with:</p>
<pre><code>bazel run --//:renderer=metal //platform/ios:App
</code></pre>
<p align="center">
  <img width="300" alt="Objective-C app screenshot" src="https://github.com/user-attachments/assets/aeb0cb5e-1f6c-439e-8668-22ee0a0b11f2" />
</p>

<h2 id="swift-app"><a class="header" href="#swift-app">Swift App</a></h2>
<p>The Swift App is mainly used to demo usage patterns in the <a href="#examples">example documentation</a>.</p>
<p>This app is available as “MapLibreApp” in the <a href="platforms/ios/README.html">generated Xcode project</a>.</p>
<p>The source code lives in <code>platform/ios/swift-app</code>.</p>
<p align="center">
  <img width="300" alt="Swift app screenshot" src="https://github.com/user-attachments/assets/87f4cea4-40dd-4744-a935-c7cebd6887f1" />
</p>

<p>You can also build and run it from the command line with:</p>
<pre><code>bazel run --//:renderer=metal //platform/ios/app-swift:MapLibreApp
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>MapLibre Native can be built for macOS. This is mostly used for development.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>There are some <a href="https://developer.apple.com/documentation/appkit">AppKit</a> APIs for macOS the source tree. However those are not actively maintained. There is an <a href="https://github.com/maplibre/maplibre-native/discussions/3414">discussion</a> on whether we should remove this code.</p>
</blockquote>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>platform/darwin</code></td><td>Shared code between macOS and iOS</td></tr>
<tr><td><code>platform/darwin/core</code></td><td>iOS/macOS specific implementations for interfaces part of the MapLibre Native C++ Core</td></tr>
<tr><td><code>platform/macos</code></td><td>macOS specific code</td></tr>
<tr><td><code>platform/macos/app</code></td><td>AppKit based example app</td></tr>
</tbody>
</table>
</div>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Clone the repo:</p>
<pre><code class="language-sh">git clone --recurse-submodules git@github.com:maplibre/maplibre-native.git
</code></pre>
<p>Make sure the following Homebrew packages are installed:</p>
<pre><code class="language-sh">brew install bazelisk webp libuv webp icu4c jpeg-turbo glfw libuv
brew link icu4c --force
</code></pre>
<p>You can get started building the project for macOS using either Bazel or CMake.</p>
<h2 id="bazel-1"><a class="header" href="#bazel-1">Bazel</a></h2>
<p>Configure Bazel (optional):</p>
<pre><code class="language-sh">cp platform/darwin/bazel/example_config.bzl platform/darwin/bazel/config.bzl
</code></pre>
<p>Run the GLFW app with a style of your choice:</p>
<pre><code class="language-sh">bazel run --//:renderer=metal //platform/glfw:glfw_app -- --style https://sgx.geodatenzentrum.de/gdz_basemapworld_vektor/styles/bm_web_wld_col.json
</code></pre>
<p>Create and open Xcode project:</p>
<pre><code class="language-sh">bazel run //platform/macos:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags="--//:renderer=metal"
xed platform/macos/MapLibre.xcodeproj
</code></pre>
<h2 id="cmake-1"><a class="header" href="#cmake-1">CMake</a></h2>
<p>Configure CMake:</p>
<pre><code class="language-sh">cmake --preset macos-metal
</code></pre>
<p>Build and run the render tests:</p>
<pre><code class="language-sh">cmake --build build-macos --target mbgl-render-test-runner
build-macos/mbgl-render-test-runner --manifestPath=metrics/macos-xcode11-release-style.json
</code></pre>
<p>Build and run the C++ Tests:</p>
<pre><code class="language-sh">cmake --build build-macos-metal --target mbgl-test-runner
npm install &amp;&amp; node test/storage/server.js  # required test server
# in another terminal
build-macos-metal/mbgl-test-runner
</code></pre>
<p>Create and open an Xcode project with CMake:</p>
<pre><code class="language-sh">cmake --preset macos-metal-xcode
xed build-macos-metal-xcode/MapLibre\ Native.xcodeproj
</code></pre>
<p>Configure project for Vulkan (make sure <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a> is installed):</p>
<pre><code class="language-sh">cmake --preset macos-vulkan
</code></pre>
<p>Build and run <code>mbgl-render</code> (simple command line utility for rendering maps):</p>
<pre><code class="language-sh">cmake --build build-macos-vulkan --target mbgl-render
build-macos-vulkan/bin/mbgl-render -z 7 -x -74 -y 41 --style https://americanamap.org/style.json
open out.png
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>This guide explains how to get started building and running MapLibre Native on Linux. The guide focusses on a Ubuntu 22.04 or later. The build process should give you a set of <code>.a</code> files that you can use to include MapLibre Native in other C++ projects, as well as a set of executables that you can run to render map tile images and test the project.</p>
<h2 id="clone-the-repo"><a class="header" href="#clone-the-repo">Clone the repo</a></h2>
<p>First, clone the repository. This repository uses <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodules</a>, that are required to build the project.</p>
<pre><code class="language-bash">git clone --recurse-submodules -j8 https://github.com/maplibre/maplibre-native.git
cd maplibre-native
</code></pre>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<pre><code class="language-bash"># Install build tools
apt install build-essential clang cmake ccache ninja-build pkg-config

# Install system dependencies
apt install libcurl4-openssl-dev libglfw3-dev libuv1-dev libpng-dev libicu-dev libjpeg-turbo8-dev libwebp-dev xvfb
</code></pre>
<p>Optional: <code>libsqlite3-dev</code> (when not found will use SQLite as vendored dependency).</p>
<p>When using Wayland (now default for <code>linux-opengl</code> preset): <code>libegl1-mesa-dev</code>.</p>
<h2 id="build-with-cmake"><a class="header" href="#build-with-cmake">Build with CMake</a></h2>
<pre><code class="language-bash">cmake --preset linux-opengl
cmake --build build-linux-opengl --target mbgl-render
</code></pre>
<h2 id="running-mbgl-render"><a class="header" href="#running-mbgl-render">Running <code>mbgl-render</code></a></h2>
<p>Running <code>mbgl-render --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json</code> should produce a map tile image with the default MapLibre styling from <a href="https://maplibre.org/">the MapLibre demo</a>.</p>
<p><img src="platforms/linux/images/sample-maplibre-style-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<pre><code class="language-bash">./build-linux-opengl/bin/mbgl-render --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --output out.png
xdg-open out.png
</code></pre>
<h3 id="headless-rendering"><a class="header" href="#headless-rendering">Headless rendering</a></h3>
<p>If you run <code>mbgl-render</code> inside a Docker or on a remote headless server, you will likely get this error because there is no X server running in the container.</p>
<blockquote>
<p><code>Error: Failed to open X display.</code></p>
</blockquote>
<p>You’ll need to simulate an X server to do any rendering. Install <code>xvfb</code> and <code>xauth</code> and run the following command:</p>
<pre><code class="language-bash">xvfb-run -a ./build-linux-opengl/bin/mbgl-render --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --output out.png
</code></pre>
<h3 id="using-your-own-styletiles"><a class="header" href="#using-your-own-styletiles">Using your own style/tiles</a></h3>
<p>You can also use the <code>mbgl-render</code> command to render images from your own style or tile set. To do so, you will need a data source and a style JSON file.</p>
<p>For the purposes of this exercise, you can use the <code>zurich_switzerland.mbtiles</code> from <a href="https://github.com/acalcutt/tileserver-gl/releases/download/test_data/zurich_switzerland.mbtiles">here</a>, and <a href="https://gist.github.com/louwers/d7607270cbd6e3faa05222a09bcb8f7d">this</a> following <code>style.json</code> file. Download both by running the commands below.</p>
<pre><code>wget https://github.com/acalcutt/tileserver-gl/releases/download/test_data/zurich_switzerland.mbtiles
wget https://gist.githubusercontent.com/louwers/d7607270cbd6e3faa05222a09bcb8f7d/raw/4e9532e1760717865df8aeff08f9bcf100f9e8c4/style.json
</code></pre>
<p>Note that this style is totally inadequate for any real use beyond testing your custom setup. Replace the source URL <code>mbtiles:///path/to/zurich_switzerland.mbtiles</code> with the actual path to your <code>.mbtiles</code> file. You can use this command if you downloaded both files to the working directory:</p>
<pre><code class="language-bash">sed -i "s#/path/to#$PWD#" style.json
</code></pre>
<p>Next, run the following command.</p>
<pre><code class="language-bash">./build-linux-opengl/bin/mbgl-render --style style.json --output out.png
</code></pre>
<p>This should produce an <code>out.png</code> image in your current directory with a barebones image of the world.</p>
<p><img src="platforms/linux/images/sample-barebones-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<h3 id="running-the-render-tests"><a class="header" href="#running-the-render-tests">Running the render tests</a></h3>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>For more information on the render tests see the <a href="#render-tests-2">dedicated Render Tests article</a>.</p>
</blockquote>
<p>To check that the output of the rendering is correct, we compare actual rendered PNGs for simple styles with expected PNGs. The content of the tests used to be stored in the MapLibre GL JS repository, which means that GL JS and Native are mostly pixel-identical in their rendering.</p>
<p>The directory structure of the render tests looks like:</p>
<pre><code>metrics/
  integration/
    render-tests/
      &lt;name-of-style-spec-feature&gt;/
        &lt;name-of-feature-value&gt;/
          expected.png
          style.json
</code></pre>
<p>After the render test run, the folder will also contain an <code>actual.png</code> file and a <code>diff.png</code> which is the difference between the expected and the actual image. There is a pixel difference threshold value which is used to decide if a render test passed or failed.</p>
<p>Run all render tests with:</p>
<pre><code>./build-linux-opengl/mbgl-render-test-runner --manifestPath metrics/linux-clang8-release-style.json
</code></pre>
<p>Or a single test with:</p>
<pre><code>./build-linux-opengl/mbgl-render-test-runner --manifestPath metrics/linux-clang8-release-style.json --filter "render-tests/fill-visibility/visible"
</code></pre>
<p>The render test results are summarized in a HTML website located next to the manifest file. For example, running <code>metrics/linux-clang8-release-style.json</code> produces a summary at <code>metrics/linux-clang8-release-style.html</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-with-docker"><a class="header" href="#building-with-docker">Building with Docker</a></h1>
<p>These steps will allow you to compile code as described <a href="platforms/linux/README.html">here</a> using a Docker container. All the steps should be executed from the root of the repository.</p>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>Not all platform builds are currently supported. Docker builds are a work in progress.</p>
</blockquote>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>You cannot build MapLibre native using both Docker and host methods at the same time. If you want to switch, you need to clean the repository first, e.g. by using this command:</p>
<pre><code class="language-bash">git clean -dxfi -e .idea -e .clwb -e .vscode
</code></pre>
</blockquote>
<h3 id="build-docker-image"><a class="header" href="#build-docker-image">Build Docker Image</a></h3>
<p>You must build your own Docker image, specific with your user and group IDs to ensure file permissions stay correct.</p>
<pre><code class="language-bash"># Build docker image from the repo __root__
# Specifying USER_UID and USER_GID allows container to create files with the same owner as the host user,
# and avoids having to pass -u $(id -u):$(id -g) to docker run.
docker build \
  -t maplibre-native-image \
  --build-arg USER_UID=$(id -u) \
  --build-arg USER_GID=$(id -g) \
  -f docker/Dockerfile \
  docker
</code></pre>
<h2 id="run-docker-container"><a class="header" href="#run-docker-container">Run Docker Container</a></h2>
<pre><code class="language-bash"># Run all build commands using the docker container.
# You can also execute build commands from inside the docker container by starting it without the build command.
docker run --rm -it -v "$PWD:/app/" -v "$PWD/docker/.cache:/home/ubuntu/.cache" maplibre-native-image
</code></pre>
<p>You can also use the container to run just one specific commands, e.g. <code>cmake</code> or <code>bazel</code>. Any downloaded dependencies will be cached in the <code>docker/.cache</code> directory.</p>
<pre><code class="language-bash">docker run --rm -it -v "$PWD:/app/" -v "$PWD/docker/.cache:/home/ubuntu/.cache" maplibre-native-image cmake ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>This guide explains how to build MapLibre Native in Windows.</p>
<p>The files produced by building <code>mbgl-core</code> target can be reused as libraries in other projects.</p>
<p>Some targets are executables (test runners and GLFW) and Node targets are shared libraries to be used in NodeJS applications.</p>
<p>Building with <a href="#building-with-microsoft-visual-studio">Microsoft Visual Studio</a> and <a href="#building-with-msys2">MSYS2</a> are supported.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-with-microsoft-visual-studio"><a class="header" href="#building-with-microsoft-visual-studio">Building with Microsoft Visual Studio</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>The build was tested with <code>Microsoft Visual Studio 2022</code>. Earlier versions are not guaranteed to work, but <code>Microsoft Visual Studio 2019</code> might work as well.</p>
<p>To install the required Visual Studio components, open Visual Studio Installer and check <code>Desktop Development with C++</code> option. Make sure <code>C++ CMake tools for Windows</code> is selected in the right pane. If <code>git</code> is not already installed, select <code>Git for Windows</code> option in <code>Individual Components</code>. When Visual Studio finishes the install process, everything is ready to start.</p>
<h2 id="downloading-sources"><a class="header" href="#downloading-sources">Downloading sources</a></h2>
<p>Open <code>x64 Native Tools Command Prompt for VS 2022</code> and then clone the repository:</p>
<pre><code class="language-cmd">git clone --config core.longpaths=true --depth 1 --recurse-submodules -j8 https://github.com/maplibre/maplibre-native.git
cd maplibre-native
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>The <code>core.longpaths=true</code> config is necessary, because without it a lot of <code>Filename too long</code> messages will come. If you have this configuration set globally (<code>git config --system core.longpaths=true</code>), you can omit the <code>--config core.longpaths=true</code> portion of the clone command.</p>
</blockquote>
<h2 id="configuring"><a class="header" href="#configuring">Configuring</a></h2>
<p>Configure the build with the following command, replacing <code>&lt;preset&gt;</code> with <code>opengl</code>, <code>egl</code> or <code>vulkan</code>, which are the rendering engines you can use. If you don’t know which one to choose, just use <code>opengl</code>:</p>
<pre><code class="language-cmd">cmake --preset windows-&lt;preset&gt;
</code></pre>
<p>It will take some time to build and install all components on which Maplibre depends.</p>
<h2 id="building-1"><a class="header" href="#building-1">Building</a></h2>
<p>Finally, build the project with the following command, again replacing <code>&lt;preset&gt;</code> with the value you choose in the configure step:</p>
<pre><code class="language-cmd">cmake --build build-windows-&lt;preset&gt;
</code></pre>
<h2 id="building-with-microsoft-visual-studio-1"><a class="header" href="#building-with-microsoft-visual-studio-1">Building with Microsoft Visual Studio</a></h2>
<p>Just add the <code>-G "Microsoft Visual Studio 17 2022"</code> (or the corresponding Visual Studio version you have) option from the configure command:</p>
<pre><code class="language-cmd">cmake --preset windows-&lt;preset&gt; -G "Microsoft Windows 2022"
</code></pre>
<p>Once configure is done, open the file <code>build-windows-&lt;preset&gt;\Mapbox GL Native.sln</code>. Build the target <code>ALL_BUILD</code> to build all targets, or pick a specific target. Don’t forget to pick a build configuration (<code>Release</code>, <code>RelWithDebInfo</code>, <code>MinSizeRel</code> or <code>Debug</code>), otherwise the project will be built with default configuration (<code>Debug</code>).</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>If all went well and target <code>mbgl-render</code> or <code>ALL_BUILD</code> was chosen, there should now be a <code>build-windows-&lt;preset&gt;\bin\mbgl-render.exe</code> binary that you can run to generate map tile images. To test that it is working properly, run the following command.</p>
<pre><code class="language-cmd">.\build-windows-&lt;preset&gt;\bin\mbgl-render.exe --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --output out.png
</code></pre>
<p>This should produce an <code>out.png</code> map tile image with the default MapLibre styling from <a href="https://maplibre.org/maplibre-gl-js/docs/examples/display-a-map/">the MapLibre demo</a>.</p>
<p><img src="platforms/windows/images/sample-maplibre-style-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<h3 id="using-your-own-styletiles-1"><a class="header" href="#using-your-own-styletiles-1">Using your own style/tiles</a></h3>
<p>You can also use the <code>mbgl-render</code> command to render images from your own style or tile set. To do so, you will need a data source and a style JSON file.</p>
<p>For the purposes of this exercise, you can use the <code>zurich_switzerland.mbtiles</code> from <a href="https://github.com/acalcutt/tileserver-gl/releases/download/test_data/zurich_switzerland.mbtiles">here</a>, and the following <code>style.json</code> file.</p>
<pre><code class="language-json">{
  "version": 8,
  "name": "Test style",
  "center": [
    8.54806714892635,
    47.37180823552663
  ],
  "sources": {
    "test": {
      "type": "vector",
      "url": "mbtiles:///path/to/zurich_switzerland.mbtiles"
    }
  },
  "layers": [
    {
      "id": "background",
      "type": "background",
      "paint": {
        "background-color": "hsl(47, 26%, 88%)"
      }
    },
    {
      "id": "water",
      "type": "fill",
      "source": "test",
      "source-layer": "water",
      "filter": [
        "==",
        "$type",
        "Polygon"
      ],
      "paint": {
        "fill-color": "hsl(205, 56%, 73%)"
      }
    },
    {
      "id": "admin_country",
      "type": "line",
      "source": "test",
      "source-layer": "boundary",
      "filter": [
        "all",
        [
          "&lt;=",
          "admin_level",
          2
        ],
        [
          "==",
          "$type",
          "LineString"
        ]
      ],
      "layout": {
        "line-cap": "round",
        "line-join": "round"
      },
      "paint": {
        "line-color": "hsla(0, 8%, 22%, 0.51)",
        "line-width": {
          "base": 1.3,
          "stops": [
            [
              3,
              0.5
            ],
            [
              22,
              15
            ]
          ]
        }
      }
    }
  ]
}
</code></pre>
<p>Note that this style is totally inadequate for any real use beyond testing your custom setup. Don’t forget to replace the source URL <code>"mbtiles:///path/to/zurich_switzerland.mbtiles"</code> with the actual path to your mbtiles file.</p>
<p>From your <code>maplibre-native</code> dir, run the following command.</p>
<pre><code class="language-cmd">.\build-windows-&lt;preset&gt;\bin\mbgl-render.exe --style path\to\style.json --output out.png
</code></pre>
<p>This should produce an <code>out.png</code> image in your current directory with a barebones image of the world.</p>
<p><img src="platforms/windows/images/sample-barebones-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-with-msys2"><a class="header" href="#building-with-msys2">Building with MSYS2</a></h1>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>You must have <a href="https://www.msys2.org/"><code>MSYS2</code></a> installed. Then launch an  window, which can be <code>UCRT64</code>, <code>CLANG64</code>, <code>CLANGARM64</code> or <code>MINGW64</code>.</p>
<p>You need to install the required packages:</p>
<pre><code class="language-sh">pacman -S --needed \
    git \
    ${MINGW_PACKAGE_PREFIX}-toolchain \
    ${MINGW_PACKAGE_PREFIX}-clang \
    ${MINGW_PACKAGE_PREFIX}-cmake \
    ${MINGW_PACKAGE_PREFIX}-angleproject \
    ${MINGW_PACKAGE_PREFIX}-curl-winssl \
    ${MINGW_PACKAGE_PREFIX}-dlfcn \
    ${MINGW_PACKAGE_PREFIX}-glfw \
    ${MINGW_PACKAGE_PREFIX}-icu \
    ${MINGW_PACKAGE_PREFIX}-libjpeg-turbo \
    ${MINGW_PACKAGE_PREFIX}-libpng \
    ${MINGW_PACKAGE_PREFIX}-libwebp \
    ${MINGW_PACKAGE_PREFIX}-libuv
</code></pre>
<p>Then everything is ready to start.</p>
<h2 id="downloading-sources-1"><a class="header" href="#downloading-sources-1">Downloading sources</a></h2>
<p>Just clone the repository:</p>
<pre><code class="language-sh">git clone --depth 1 --recurse-submodules -j8 https://github.com/maplibre/maplibre-native.git
cd maplibre-native
</code></pre>
<h2 id="configuring-1"><a class="header" href="#configuring-1">Configuring</a></h2>
<p>Configure the build with the following command, replacing <code>&lt;preset&gt;</code> with <code>opengl</code>, <code>egl</code> or <code>vulkan</code>, which are the rendering engines you can use. If you don’t know which one to choose, just use <code>opengl</code>:</p>
<pre><code class="language-sh">cmake --preset windows-&lt;preset&gt; -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++
</code></pre>
<h2 id="building-2"><a class="header" href="#building-2">Building</a></h2>
<p>Finally, build the project with the following command, again replacing <code>&lt;preset&gt;</code> with the value you choose in the configure step:</p>
<pre><code class="language-sh">cmake --build build-windows-&lt;preset&gt;
</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>If all went well and target <code>mbgl-render</code> or <code>ALL_BUILD</code> was chosen, there should now be a <code>build-windows-&lt;preset&gt;/bin/mbgl-render.exe</code> binary that you can run to generate map tile images. To test that it is working properly, run the following command.</p>
<pre><code class="language-sh">./build-windows-&lt;preset&gt;/bin/mbgl-render.exe --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --output out.png
</code></pre>
<p>This should produce an <code>out.png</code> map tile image with the default MapLibre styling from <a href="https://maplibre.org/maplibre-gl-js/docs/examples/display-a-map/">the MapLibre demo</a>.</p>
<p><img src="platforms/windows/images/sample-maplibre-style-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<h3 id="using-your-own-styletiles-2"><a class="header" href="#using-your-own-styletiles-2">Using your own style/tiles</a></h3>
<p>You can also use the <code>mbgl-render</code> command to render images from your own style or tile set. To do so, you will need a data source and a style JSON file.</p>
<p>For the purposes of this exercise, you can use the <code>zurich_switzerland.mbtiles</code> from <a href="https://github.com/acalcutt/tileserver-gl/releases/download/test_data/zurich_switzerland.mbtiles">here</a>, and the following <code>style.json</code> file.</p>
<pre><code class="language-json">{
  "version": 8,
  "name": "Test style",
  "center": [
    8.54806714892635,
    47.37180823552663
  ],
  "sources": {
    "test": {
      "type": "vector",
      "url": "mbtiles:///path/to/zurich_switzerland.mbtiles"
    }
  },
  "layers": [
    {
      "id": "background",
      "type": "background",
      "paint": {
        "background-color": "hsl(47, 26%, 88%)"
      }
    },
    {
      "id": "water",
      "type": "fill",
      "source": "test",
      "source-layer": "water",
      "filter": [
        "==",
        "$type",
        "Polygon"
      ],
      "paint": {
        "fill-color": "hsl(205, 56%, 73%)"
      }
    },
    {
      "id": "admin_country",
      "type": "line",
      "source": "test",
      "source-layer": "boundary",
      "filter": [
        "all",
        [
          "&lt;=",
          "admin_level",
          2
        ],
        [
          "==",
          "$type",
          "LineString"
        ]
      ],
      "layout": {
        "line-cap": "round",
        "line-join": "round"
      },
      "paint": {
        "line-color": "hsla(0, 8%, 22%, 0.51)",
        "line-width": {
          "base": 1.3,
          "stops": [
            [
              3,
              0.5
            ],
            [
              22,
              15
            ]
          ]
        }
      }
    }
  ]
}
</code></pre>
<p>Note that this style is totally inadequate for any real use beyond testing your custom setup. Don’t forget to replace the source URL <code>"mbtiles:///path/to/zurich_switzerland.mbtiles"</code> with the actual path to your mbtiles file.</p>
<p>From your <code>maplibre-native/</code> dir, run the following command.</p>
<pre><code class="language-sh">./build-windows-&lt;preset&gt;/bin/mbgl-render.exe --style path/to/style.json --output out.png
</code></pre>
<p>This should produce an <code>out.png</code> image in your current directory with a barebones image of the world.</p>
<p><img src="platforms/windows/images/sample-barebones-mbgl-render-out.png" alt="Sample image of world from mbgl-render command"></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-policy"><a class="header" href="#release-policy">Release Policy</a></h1>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>The following release policiy applies specifically to MapLibre <strong>Android</strong> and MapLibre <strong>iOS</strong>.</p>
</blockquote>
<ul>
<li>We use <a href="https://semver.org/">semantic versioning</a>. Breaking changes will always result in a major release.</li>
<li>Despite having extensive tests in place, as a FOSS project we have limited QA testing capabilities. When major changes took place we may opt to put out a pre-release to let the community help with testing.</li>
<li>In principle the <code>main</code> branch should always be in a releasable state.</li>
<li>The release process is automated and documented (see <a href="ios/release.html">Release MapLibre iOS</a> and <a href="android/release.html">Release MapLibre Android</a>). Anyone with write access should be able to push out a release.</li>
<li>There is no fixed release cadence, but you are welcome to request a release on any of the communication channels.</li>
<li>We do not have long-term support (LTS) releases.</li>
<li>If you need a feature or a bugfix ported to and old version of MapLibre, you need to do the backporting yourself (see steps below).</li>
</ul>
<h2 id="backporting"><a class="header" href="#backporting">Backporting</a></h2>
<p>We understand that MapLibre is used in large mission critical applications where updating to the latest version is not always immediately possible. We do not have the capacity to offer LTS releases, but we do want to facilitate backporting.</p>
<ol>
<li>Create an issue and request that a branch is created from the release you want to target. Also mention the feature or bugfix you want to backport.</li>
<li>Once the branch is created, make a PR that includes the feature or bugfix and that targets this branch. Also update the relevant changelog.</li>
<li>When the PR is approved and merged, a release is attempted. If the release workflow significantly changed and the release fails, you may need to help to backport changes to the release workflow as well.</li>
</ol>
<p>The branch names for older versions follow a pattern as follows: <code>platform-x.x.x</code> (e.g. <a href="https://github.com/maplibre/maplibre-native/tree/android-10.x.x"><code>android-10.x.x</code></a> for the MapLibre Native Android 10.x.x release series). These branches have some minimal branch protection (a pull request is required to push changes to them).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="render-tests-2"><a class="header" href="#render-tests-2">Render Tests</a></h1>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>See also <a href="android/android-tests.html#render-tests">Android Tests</a> and <a href="ios/ios-tests.html#render-tests">iOS Tests</a> for some platform-specific information on the render tests.</p>
</blockquote>
<p>Render tests verify the correctness and consistency of MapLibre Native’s rendering. Note that ‘render test’ is a bit of a misnomer, because there are various types of tests that do not really test rendering behavior that we sometimes call render tests. Examples are <a href="#metricsintergration">expression tests and query tests</a>. In addition, these ‘render tests’ allow a wide variety of operations and probes (which write out metrics) for things like GPU memory allocations, memory usage, network requests, FPS, so these tests are really quite a bit more versatile than just verifying rendering behavior.</p>
<h2 id="render-test-runner-cli-options"><a class="header" href="#render-test-runner-cli-options">Render Test Runner CLI Options</a></h2>
<p>When using CMake, the render test runner is an executable available as <code>mbgl-render-test-runner</code> in the build directory.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Option / Argument</th><th style="text-align: left">Description</th><th style="text-align: left">Required?</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>-h</code>, <code>--help</code></td><td style="text-align: left">Display the help menu and exit.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>-r</code>, <code>--recycle-map</code></td><td style="text-align: left">Toggle reusing the map object between tests. If set, the map object is reused; otherwise, it’s reset for each test.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>-s</code>, <code>--shuffle</code></td><td style="text-align: left">Toggle shuffling the order of tests based on the manifest file.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>-o</code>, <code>--online</code></td><td style="text-align: left">Toggle online mode. If set, tests can make network requests. By default (<code>--online</code> not specified), tests run in offline mode, forcing resource loading from the cache only.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>--seed &lt;uint32_t&gt;</code></td><td style="text-align: left">Set the seed for shuffling tests. Only relevant if <code>--shuffle</code> is also used. Defaults to <code>1</code> if <code>--shuffle</code> is used without <code>--seed</code>.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>-p</code>, <code>--manifestPath &lt;string&gt;</code></td><td style="text-align: left">Specifies the path to the test manifest JSON file, which defines test configurations, paths, and potentially filters/ignores.</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left"><code>-f</code>, <code>--filter &lt;string&gt;</code></td><td style="text-align: left">Provides a regular expression used to filter which tests (based on their path/ID) should be run. Only tests matching the regex will be executed.</td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: left"><code>-u</code>, <code>--update default | platform | metrics | rebaseline</code></td><td style="text-align: left">Sets the mode for updating test expectation results: <br> - <code>default</code>: Updates generic render test expectation images/JSON. <br> - <code>platform</code>: Updates platform-specific render test expectation images/JSON. <br> - <code>metrics</code>: Updates expected metrics for the configuration defined by the manifest. <br> - <code>rebaseline</code>: Updates or creates expected metrics for the configuration defined by the manifest.</td><td style="text-align: left">No</td></tr>
</tbody>
</table>
</div>
<h2 id="source-code-organization"><a class="header" href="#source-code-organization">Source Code Organization</a></h2>
<h3 id="render-test"><a class="header" href="#render-test"><code>render-test</code></a></h3>
<p>This directory contains the C++ source code for common render test runner, manifest parser and CLI tool.</p>
<ul>
<li><code>render-test/android</code>: standalone Gradle project with a app that runs the render test runner.</li>
<li><code>render-tests/ios</code>: source code for Objective-C app that encapsulates the render test runner.
property: <code>background-color</code>, <code>line-width</code>, etc., with a second level of directories below that for individual tests.</li>
</ul>
<h3 id="metrics"><a class="header" href="#metrics"><code>metrics</code></a></h3>
<p>The JSON files in this directory are the manifests (to be passed to render test CLI tool). This directory also contains many directories that store metrics used by the tests. Other files/directories include:</p>
<ul>
<li><code>cache-style.db</code>, <code>cache-metrics.db</code>: pre-populated cache (SQLite database file) so the tests can run offline. You may need to update this database when you need a new resource available during test executation.</li>
<li><code>binary-size</code>: binary-size checks. Not used right now, see <a href="https://github.com/maplibre/maplibre-native/issues/3379">#3379</a>.</li>
<li><code>expectations</code>: expectations for various platforms. E.g. <code>expectations/platform-android</code> is referenced by the <code>android-render-test-runner-metrics.json</code> manifest under its <code>expectation_paths</code> key.</li>
<li><code>ignores</code>: contains JSON files with as key a test path and as value a reason why a test is ignored. For example:
<pre><code>{
   "expression-tests/collator/accent-equals-de": "Locale-specific behavior changes based on platform."
}
</code></pre>
Manifests can have a key <code>ignore_paths</code> with an array of ignore files. For example:
<pre><code>{
   ...
   "ignore_paths": [
      "ignores/platform-all.json",
      "ignores/platform-linux.json",
      "ignores/platform-android.json"
   ],
   ...
}
</code></pre>
</li>
</ul>
<h4 id="metricsintergration"><a class="header" href="#metricsintergration"><code>metrics/intergration</code></a></h4>
<ul>
<li><code>data</code>, <code>geojson</code>, <code>glyphs</code>, <code>image</code>, <code>sprites</code>, <code>styles</code>, <code>tiles</code>, <code>tilesets</code>, <code>video</code>: various data used by the render tests.</li>
<li><code>expression-tests</code>: tests that verify the behavior of <a href="https://maplibre.org/maplibre-style-spec/expressions/">expressions</a> of the MapLibre Style Spec.</li>
<li><code>query-tests</code>: these tests test the behavior of the <code>queryRenderedFeatures</code> API which, as the name suggests, allow you to query the rendered features.</li>
<li><code>render-tests</code>: location of render tests. Each render test contains a <code>style.json</code> and an <code>expected.png</code> image. This directory tree is generally organized by <a href="https://maplibre.org/maplibre-style-spec/">style specification</a> properties.</li>
</ul>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>To run the entire integration test suite (both render or query tests), from within the maplibre-native directory on Linux run the command:</p>
<pre><code>./build/mbgl-render-test-runner --manifestPath metrics/linux-clang8-release-style.json
</code></pre>
<h3 id="running-specific-tests"><a class="header" href="#running-specific-tests">Running specific tests</a></h3>
<p>To run a subset of tests or an individual test, you can pass a specific subdirectory to the <code>mbgl-render-test-runner</code> executable. For example, to run all the tests for a given property, e.g. <code>circle-radius</code>:</p>
<pre><code>$ build-macos-vulkan/mbgl-render-test-runner --manifestPath=metrics/macos-xcode11-release-style.json -f 'circle-radius/.*'
* passed query-tests/circle-radius/feature-state
* passed query-tests/circle-radius/zoom-and-property-function
* passed query-tests/circle-radius/property-function
* passed query-tests/circle-radius/outside
* passed query-tests/circle-radius/tile-boundary
* passed query-tests/circle-radius/inside
* passed query-tests/circle-radius/multiple-layers
* passed render-tests/circle-radius/zoom-and-property-function
* passed render-tests/circle-radius/literal
* passed render-tests/circle-radius/property-function
* passed render-tests/circle-radius/default
* passed render-tests/circle-radius/function
* passed render-tests/circle-radius/antimeridian
13 passed (100.0%)
Results at: /Users/bart/src/maplibre-native/metrics/macos-xcode11-release-style.html
</code></pre>
<h2 id="writing-new-tests"><a class="header" href="#writing-new-tests">Writing new tests</a></h2>
<p>To add a new render test:</p>
<ol>
<li>
<p>Create a new directory <code>test/integration/render-tests/&lt;property-name&gt;/&lt;new-test-name&gt;</code></p>
</li>
<li>
<p>Create a new <code>style.json</code> file within that directory, specifying the map to load. Feel free to copy &amp; modify one of the existing <code>style.json</code> files from the <code>render-tests</code> subdirectories.</p>
</li>
<li>
<p>Generate an <code>expected.png</code> image from the given style with</p>
<pre><code>$ ./build/mbgl-render-test-runner --update default --manifestPath=... -f '&lt;property-name&gt;/&lt;new-test-name&gt;'
</code></pre>
</li>
<li>
<p>Manually inspect <code>expected.png</code> to verify it looks as expected.</p>
</li>
<li>
<p>Commit the new <code>style.json</code> and <code>expected.png</code>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>These notes are partially outdated since the <a href="https://github.com/maplibre/maplibre-native/blob/main/design-proposals/2022-10-27-rendering-modularization.md">renderer modularization</a>.</p>
</blockquote>
<h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This section is dedicated to documenting current state of MapLibre Native as of end 2022. <a href="#architectural-problems--recommendations">Architectural Problems and Recommendations</a> section notes recommendations for future improvements from an architectural perspective.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ten-thousand-foot-view"><a class="header" href="#ten-thousand-foot-view">Ten Thousand Foot View</a></h1>
<pre class="mermaid">graph TD
    subgraph Platform
        MV[Map View]
        MR[Map Renderer]
    end

    subgraph "MapLibre Native Core"
        M[Map]
        S[Style]
        L[Layers]
        I[Images]
        Glyphs
        R[Renderer]
        TW[TileWorker]
    end

    %% Platform Interactions
    MV -- initializes --&gt; MR
    MV -- Initializes --&gt; M

    %% Core Interactions
    MR -- runs the rendering loop --&gt; R
    R -- Renders Map --&gt; M
    L -- Fetches --&gt; S
    L -- Fetches --&gt; I
    R -- Sends messages to generate tiles --&gt; TW
    TW -- Prepares layers to be rendered --&gt; L
    L -- Fetches --&gt; Glyphs
</pre>

<p><em>Figure 1: MapLibre Native Components – Ten Thousand Foot view</em></p>
<p>From ten thousand foot, MapLibre Native is composed of <em>Map View</em> and a
<em>Renderer</em>. MapLibre Native supports iOS, Android, Linux, QT, MacOS,
and nodeJS at the time of writing. Each of these <em>platforms</em> have their
own <em>Map View</em> and <em>Map Renderer</em> component. A <em>Map Renderer</em> talks to a
shared codebase that renders map by using device GPU. This shared piece
of code at the time of writing supports OpenGL as its choice of
rendering API.</p>
<p>Apart from the platform code, <em>MapLibre Native</em> offers shared
implementation for <em>Style, Layers, Text, Glyphs</em>, and <em>Tiles</em>.</p>
<p>To summarize:</p>
<ol>
<li>
<p><em><strong>Map View</strong></em> is responsible for viewing a <em>slippy map,</em> a term
referring to web maps which lets a user zoom and pan around. Each
platform has its own <em>Map View</em>.</p>
</li>
<li>
<p><em><strong>Map Renderer</strong></em> is composed of two parts, one is a platform
specific map rendering loop. The other is a cross-platform renderer
backend, denoted as <em>Renderer</em> in Figure 1.</p>
</li>
<li>
<p>A <em>map renderer</em> uses a <em><strong>Tile Worker</strong></em> to render individual map
tile. It uses an <em><strong>Actor Framework</strong></em> to send messages to a <em><strong>Tile
Worker</strong></em> to produce said tiles.</p>
</li>
<li>
<p>A <em>tile worker</em> prepares a tile one layer at a time. A map tile is
composed of multiple <em>layers</em>.</p>
</li>
<li>
<p>A <em><strong>Layer</strong></em> requires <em><strong>Style</strong></em>, <em><strong>Glyphs</strong></em>, and <em><strong>Sprites</strong></em>
for to be ready for rendering. Features rendered in a <em><strong>Layer</strong></em>
come from data sources. And a <em><strong>Layer</strong></em> is composed of tiles produced
from said features.</p>
</li>
</ol>
<p>We will look a bit more into these components going forward<sup class="footnote-reference" id="fr-1-1-1"><a href="#footnote-1-1">1</a></sup>.</p>
<h3 id="map-view"><a class="header" href="#map-view">Map View</a></h3>
<p>A <em>Map View</em> is a reusable map viewer that renders a raster or vector
map in different platform specific viewports. It bears the standard of
common map configuration across the platforms. These ranges from map
viewport size, pixel ratio, tileset URL, style, collision configuration
for text, and annotations<sup class="footnote-reference" id="fr-2-1-1"><a href="#footnote-2-1">2</a></sup>. A <em>Map View</em> does not contain any
rendering capability of its own. It publishes and listens to events
through observers<sup class="footnote-reference" id="fr-3-1-1"><a href="#footnote-3-1">3</a></sup>.</p>
<p>Figure 1 does not display the explicit use of observers for brevity.</p>
<h4 id="observers"><a class="header" href="#observers">Observers</a></h4>
<p>Observers are a group of components that listen and publish events from
and to a <em>Map View</em>. Observer come in two major flavours across
platforms – a <em>map observer</em> and a <em>rendering observer</em>. A <em>map
observer</em> is responsible for handling events for map configuration
changes. This includes events for loading and updating <em>style</em>, events
for map becoming idle, events initialization and completion of
rendering, and events for camera orientation changes. On the other hand,
a rendering observer deals with events that are directly related to
frame-by-frame map rendering. A rendering observer might publish a
rendering event to map observers but they are usually rendering
initialization or completion events. One key thing to remember here is a
map configuration can lead to rendering changes such as camera switch,
map center change, viewport size change, zoom, and pitch change.</p>
<h3 id="style"><a class="header" href="#style">Style</a></h3>
<p>Style component embodies a <em>MapLibre Style Document</em>. A style document
is a JSON object that defines the visual appearance of a map through the
order to draw it in, what to draw, and how to style the data while
drawing it. Style sub-component is composed of classes and functions
that allows downloading, and configuring a style. A style can be fetched
from a remote HTTP resource or configured locally. The style component
also carries a <em>Sprite Loader</em> to load sprites, remote HTTP URL for
glyphs, layers to draw and sources of data to draw. A <em>sprite</em> is a
single image that contains all the <em>icons</em> included in a style. Layers
are composed of sources where a source could be a vector tile set,
raster tile set, or GeoJSON data</p>
<p><em>To complete initialization of a map component, we need to initialize a
map, style with source and layers, and observers.</em></p>
<h3 id="layer"><a class="header" href="#layer">Layer</a></h3>
<p><em>Layer</em> is an overloaded terminology in the MapLibre Native’s
context. <em>Layer</em> can mean any of the following:</p>
<ol>
<li>
<p>From the point of view of data that needs to be rendered on map,
each map tile is composed of <em>layers</em> of data. Each layer, in this
context, contains <em>features</em><sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> to be rendered in a map. These
features are defined by a <em>source.</em> Each <em>layer</em> is tied to a
<em>source</em>.</p>
</li>
<li>
<p>From the point of view of <em>style</em>, a style’s layer property list all
the <em>layers</em> available in that <em>style</em>. A single style sheet can be
applied atop one or many layers. This layer definition converges
data to be rendered and the style to be applied on said layer.</p>
</li>
</ol>
<p>When this document uses the word layer in context of rendering, it
refers to the definition mentioned in 2.</p>
<h3 id="glyphs"><a class="header" href="#glyphs">Glyphs</a></h3>
<p>A <em>glyph</em> is a single representation of a character. A font is a map of
characters<sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup>. Map tiles use labels of text to show name of cities,
administrative boundaries, or street names. Map tiles also need to show
icons for amenities like bus stops and parks. A map style uses character
map from fonts to display labels and icons. Collectively these are
called <em>glyphs.</em></p>
<p><em>Glyphs</em> require resizing, rotation, and a halo for clarity in nearly every
interaction with the map. To achieve this, all <em>glyphs</em> are pre-rendered
in a shared texture, called <em>texture atlas</em>. This atlas is packed inside
protobuf container. Each element of the atlas is an individual texture
representing the SDF of the character to render.</p>
<p>Each <em>glyph</em> bitmap inside is a field of floats, named signed distance. It
represents how a <em>glyph</em> should be drawn by the GPU. Each <em>glyph</em> is of font
size 24 that stores the distance to the next outline in every pixel. Easily
put if the pixel is inside the <em>glyph</em> outline it has a value between <code>192-255</code>.
Every pixel outside the <em>glyph</em> outline has a value between <code>0-191</code>. This creates
a black and white atlas of all the <em>glyphs</em> inside.</p>
<p>This document currently does not have a dedicated section on text rendering.
When it does, we will dive more into <em>glyph</em> rendering.</p>
<h3 id="actor-framework"><a class="header" href="#actor-framework">Actor Framework</a></h3>
<p>MapLibre Native is used in mobile platforms. To be performant in
underpowered environments, MapLibre Native tries to leverage message
passing across threads to render frames asynchronously. The threading
architecture in implementation realizes this using the Actor
interface<sup class="footnote-reference" id="fr-6-1"><a href="#footnote-6">6</a></sup>. In reality the messages are raw pointers. This ranges
from raw message to actionable message. By actionable message this
document means <em>anonymous functions</em> that are passed as messages between
actors. These arbitrary messages are <em>immutable</em> by design. The current
implementation of the Actor framework is done through two major
components, a <em>MailBox</em> and an <em>Actor</em>. A <em>MailBox</em> is attached to a
specific type of <em>Message</em>. In the current implementation, these are
rendering events that render layers, sources, and subsequently tiles. An
<em>Actor</em> is an independent thread passing messages to others.</p>
<h3 id="renderer"><a class="header" href="#renderer">Renderer</a></h3>
<p>A <em>Map Renderer</em> translates geospatial features in a vector or raster
tile to rendered or rasterized map tiles shown in a <em>slippy map.</em>
MapLibre Native uses a <em>Renderer</em> component to translate map tiles
fetched from a tile server to a rendered map.</p>
<p>MapLibre Native uses a pool of <em>workers</em>. These workers are
responsible for background tile generation. A render thread continuously
renders the current state of the map with available tiles at the time of
rendering. In Javascript and iOS, the render thread is the same as the
foreground/UI. For performance reasons, Android render thread is
separated from the UI thread. The changes to the map on the UI due to
user interaction is batched together and sent to the render thread for
processing. The platforms also include worker threads for processing for
platform-specific tasks such as running HTTP requests in the background.
But the core code is agnostic about where those tasks get performed.
Each platform is required to provide its own implementation of
concurrency/threading primitives for MapLibre Native core to use. The
platform code is also free to use its own threading model. For example,
Android uses a <em>GLSurfaceView</em> with a <em>GLThread</em> where the iOS SDK uses
<em>Grand Central Dispatch</em> for running asynchronous tasks.</p>
<h3 id="tile-worker"><a class="header" href="#tile-worker">Tile Worker</a></h3>
<p>We have noted early in this document that MapLibre Native uses message
passing to communicate with the renderer. These messages are <em>immutable</em>
by design and the render loops checks for these in each iteration. To
simplify, there is only one thread allocated for rendering loop,
background or foreground<sup class="footnote-reference" id="fr-7-1"><a href="#footnote-7">7</a></sup>. A <em>Tile Worker</em> is a thread that prepares
a tile of a specific type. Geometry Tile Worker by the name of it,
prepares a tile for rendering tiles that contains vector geometry.
Following that same trend, MapLibre Native offers tile worker for
raster tiles and elevation tiles. Messages sent to a tile worker can be
processed by any thread, with the assumption that only one thread at a
time will work with a tile worker instance.</p>
<p>Tile workers are not based on a common interface or base class. Tiles
are. MapLibre Native offers a base Tile class. Raster, Geometry, and
Elevation tile instances are inherited from Tile base class. Through
this inheritance MapLibre Native maintains the association of Tile
types and tile workers. Any Tile Worker is an actor that accepts
messages of a specific Tile type. For a Geometry Tile Worker, the type
is a Geometry Tile.</p>
<p>*To read in depth about the workflow of a Geometry Tile Worker, please
check <a href="#geometry-tile-worker">Geometry Tile Worker</a> chapter.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-1">
<p>To read in depth about the data flow for map initialization and
rendering in Android, please check
<a href="#android-map-rendering-data-flow">Android Map Rendering Data Flow</a> <a href="#fr-1-1-1">↩</a></p>
</li>
<li id="footnote-2-1">
<p>This document speaks of a simplified configuration for brevity.
These also includes viewport mode, constrain mode, and north
orientation. <a href="#fr-2-1-1">↩</a></p>
</li>
<li id="footnote-3-1">
<p>Platform SDKs might use a wrapper map view class atop the map
component. This is to help establish contract between the device
runtime running a different language. Android is a good example of
this behaviour. <a href="#fr-3-1-1">↩</a></p>
</li>
<li id="footnote-4">
<p>A feature is the spatial description of a real-world entity such
as a road or a utility pole. Any geometry that is displayed on a map
tile is either an individual feature or a part of a feature. <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>This document used the term glyph and character interchangeably.
In reality, a single character can have multiple glyphs. These are
called alternates. On the other hand, a single glyph can represent
multiple characters. These are called ligatures. <a href="#fr-5-1">↩</a></p>
</li>
<li id="footnote-6">
<p>In the Javascript counterpart, MapLibre GL JS, this is achieved
through usage of webworkers. <a href="#fr-6-1">↩</a></p>
</li>
<li id="footnote-7">
<p>In iOS, the render thread runs on UI thread, as in it’s a
foreground thread. Android offers wider range of devices in terms of
battery capacity. Hence, Android prefers to use a background thread
for rendering loop. <a href="#fr-7-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<p>Before we jump into the coordinate system of MapLibre Native, let’s
quickly review the concepts of translating a position on the face of
Earth to a map tile. This is not a comprehensive refresher of coordinate
reference systems or rendering basics. Rather this intends to guide the
reader on what we want to achieve in this section.</p>
<p>We start from <em>Earth</em>, which is a geoid which is mathematically
expensive to use as a reference coordinate system. Thus, we approximate
the earth to reference ellipsoids or datum. For this documents’ scope,
WGS84 is used as the canonical datum. Our goal is to represent
geometries defined by WGS84 longitude, latitude pair coordinates to a
map tile.</p>
<p>Instead of translating a full geometry, in the following subsections, we
will project a WGS 84 point to a map tile rendered in MapLibre
Native.</p>
<h4 id="world-vs-earth"><a class="header" href="#world-vs-earth">World vs Earth</a></h4>
<p>This document uses the word <em>Earth</em> when it refers to the planet in
which we all live in and make map tiles for. This document uses the word
<em>World</em> to denote the world MapLibre Native renders. The word <em>world</em>
in rendering terms mean the <em>world</em> to render. It could be a set of
cones and boxes, a modeled city, anything composed of 3D objects.
MapLibre Native renders map tiles in a range of zoom levels on a 3D
plane. Map tiles are already produced from a WGS84 ellipsoid. Therefore,
when this document uses the word <em>World,</em> it means the 3D plane
containing a set of map tiles to be rendered, not the <em>Earth</em>.</p>
<h4 id="transformations"><a class="header" href="#transformations">Transformations</a></h4>
<p>MapLibre Native requires a series of coordinate transformations to render a
geometry from map tile. This is where we refresh our rendering knowledge
a bit. To render anything through a GPU:</p>
<ol>
<li>
<p>Design and define model in the <em>Local Space</em>. We call anything that
needs to be renderer a <em>model.</em> In the Local space, a model lives in
its own coordinate system. For MapLibre Native, in local space
each individual tile is modeled. This map tile is already populated
by a map tile generation process. The longitude, latitude bound per
tile is now translated to pixel bounds in this local space.</p>
</li>
<li>
<p>When model matrix is applied to local space, as in a camera is
applied, <em>Local Space</em> transforms to <em>World Space</em>. In this space,
the model coordinates are relative to the world’s origin. In this
space all the individual map tiles to be rendered are introduced in
the world space.</p>
</li>
<li>
<p>The <em>World Space</em> is not seen from a viewpoint of a camera. When we
see the <em>world</em> from a viewpoint of a camera, view matrix
transformation is applied. Cameras can see the world up to a
distance like human eyes can. To emulate that we apply <em>Projection
Matrix</em> to <em>View Space</em> and end up in <em>Clip Space</em><sup class="footnote-reference" id="fr-8-1"><a href="#footnote-8">1</a></sup>.</p>
</li>
<li>
<p>Finally, the <em>World Space</em> is transformed to device screen by
applying viewport transform matrix.</p>
</li>
</ol>
<p>Going forward, scoping our discussion only to MapLibre Native, we
will talk mostly about two categories of coordinate systems:</p>
<ol>
<li>
<p>World Coordinates</p>
</li>
<li>
<p>Device Coordinates</p>
</li>
</ol>
<p>World Coordinates are defined in <em>World Space</em>. This speaks of how <em>this
world defines itself in a three-dimensional space</em>.<sup class="footnote-reference" id="fr-9-1"><a href="#footnote-9">2</a></sup> On the other
hand, device coordinates are used through View, Clip, and Screen Space.
The purpose of this set of coordinates is to define how the world will
be projected on a screen. Device Coordinates define <em>how a world will be
projected on a screen.</em></p>
<p>The unit of measurement will be pixels in this document. When the map
tiles are generated by a system, the unit of distance in each tile is
measured in degree angles instead of meters. Because angular distance
stays the same if we move the angle across the axis of earth.</p>
<p>Figure 2 shows rendering map tile through the rendering spaces and
transformations below:</p>
<p><img src="design/media/rendering-spaces-and-transformations-for-map-tiles.png" alt="">
<em>Figure 2: Rendering Spaces and Transformations for Map Tiles</em></p>
<h2 id="world-coordinates"><a class="header" href="#world-coordinates">World Coordinates</a></h2>
<p>World Coordinates for maps start with <em>Geographic Coordinate Systems</em>.
<em>Geographic Coordinate Systems</em> use the three-dimensional model of the
earth (ellipsoid) to define specific locations on the surface to create
a grid. Traditional longitude, and latitude coordinate pair to define a
location is an example of using geographic coordinates. EPSG: 4326
(WGS84) is the reference <em>Geographic Coordinate System</em> that most of the
world’s geospatial data is defined and stored<sup class="footnote-reference" id="fr-10-1"><a href="#footnote-10">3</a></sup> in. There is no way
to visualize the WGS84 coordinate system on a two-dimensional plane, in
this case, the map.</p>
<p>Projections are used to translate WGS84 coordinates to a plane. To be
specific, projections are used to translate a location on the ellipsoid
to a two-dimensional square. EPSG:3857<sup class="footnote-reference" id="fr-11-1"><a href="#footnote-11">4</a></sup> or projected
<em>Pseudo-Mercator Coordinate System</em> is such a coordinate system.
EPSG:3857 is used by MapLibre Native as a default coordinate system
to display maps. This system takes WGS84 coordinates and projects them
into sphere. This stretches out the landmass in the hemispheres but
mathematically makes it simpler to project a location back to a 2D
plane. As in, a sphere divided into angular equidistant grid produces
rectangular grids when projected into a 2D plane. The philosophy behind
this was to make rendering maps easy, as in drawing 2D squares on a
plane is computationally trivial.</p>
<p>Our world can be now broken down into these squares or tiles as we will
call it going forward. This system imagines the world as a giant grid of
tiles. Each tile has a fixed size defined in pixels.</p>
<pre><code>worldSize = tileSize * number of tiles across a single dimension
</code></pre>
<p>For brevity, this document assumes the reader knows that map tiles are
divided into a range of zoom levels. And each tile in zoom N gets
divided into 4 tiles in zoom N+1. A tile size of 512 pixels and zoom
level 11 will deduce <em>worldSize</em> to be the following:</p>
<pre><code>worldSize = 512 * 2^11 = 1048576
</code></pre>
<p>Although each tile breaks into 4 in the next zoom level, we used a power
of 2. This is because X and Y both dimensions expand with a factor of 2.</p>
<p>Example: We start from translating a WGS84 location with longitude
-77.035915 and latitude 38.889814. To translate a degree longitude
relies on normalizing the latitude range <code>[-180, 180]</code> to <code>[0, 1048576]</code>. This means the X pixel value of a specific tile requires
shifting our coordinate by 180. For example, a location with longitude
-77.035915 becomes*:*</p>
<pre><code>X = (180 + longitude) / 360 * worldSize
= (180 + -77.035915) / 360 * 1048576
= 299,904
</code></pre>
<p>Finding the X coordinate is easy to compute. But the Y requires a more
than normalizing the range. This is due to the aforementioned space
stretching in the hemispheres<sup class="footnote-reference" id="fr-12-1"><a href="#footnote-12">5</a></sup>. Latitude value (Y) defined in WGS84
will not be the same position after stretching. The computation looks
like the following if the latitude was 38.889814:</p>
<pre><code>y = ln(tan(45 + latitude / 2))
= ln(tan(45 + 38.889814/ 2))
= 0.73781742861
</code></pre>
<p>Now, to compute the pixel value for y:</p>
<pre><code>Y = (180 - y * (180 / π)) / 360 * worldSize
= (180 - 42.27382˚) / 360 * 1048576
= 401,156
</code></pre>
<h3 id="tile-coordinates"><a class="header" href="#tile-coordinates">Tile Coordinates</a></h3>
<p>Our next pursuit is to translate <em>World Coordinates to Tile
Coordinates</em>. Because we want to know where exactly inside a map tile a
location (longitude, latitude) coordinate gets rendered and vice versa.
This system creates different pixel ranges per zoom level. So, we append
the zoom level along with the X and Y pixel values. Dividing the pixel
values with the tile size normalizes the X and Y value <em>per tile</em>. This
means <code>(x:299,904, y:401,156, z:11)</code> becomes <code>(585.7471, 783.5067, z11)</code>.</p>
<p>We divide our X and Y pixel value by tile size because we want to know
the starting coordinates of each tile instead of individual location
coordinates. This helps in drawing a tile. If we now <em>floor</em> the
components to integers, we get <code>(585/783/11)</code>. This marks an individual
tile’s X, Y, and Z.</p>
<p>To reach our goal of translating a location to a coordinate inside a
tile, we need to know what is the <em>extent</em> of the tile. MapLibre
Native follows Mapbox Vector Tile (MVT) spec. Following said spec,
MapLibre Native internally normalizes each tile to an <em>extent</em> of
8192. Tile extent describes the width and height of the tile in integer
coordinates. This means a tile coordinate can have higher precision than
a pixel. Because normally a tile has a height and width of 512 pixels.
In this case, with an extent of 8192, each <em><strong>Tile Coordinate</strong></em> has a
precision of <code>512/8192 = 1/16</code>th of a pixel. Tile <em>extent</em> origin (0,0)
is on top left corner of the tile, and the (Xmax, Ymax) is on the bottom
right. This means (8192, 8192) <em>tile coordinate</em> will be in the bottom
right. Any coordinate greater or lesser than the <em>extent</em> range is
considered outside the <em>extent</em> of the tile. Geometries that extend past
the tile’s area as defined by the extent are often used as a <em>buffer</em>
for rendering features that overlap multiple adjacent tiles.</p>
<p>To finally deduce the <em><strong>Tile Coordinates</strong></em> we multiply the remainder
of our Tile components with <em>extent:</em></p>
<pre><code>(585.7471, 783.5067, z11) -&gt; (.7471 * 8192, .5067 * 8192) = (x:
6120, y: 4151)
</code></pre>
<p>This makes the <em><strong>Tile</strong></em> to be <code>(585/783/11)</code> and <em><strong>Tile Coordinates</strong></em>
to be <code>(x: 6120, y: 4151)</code> for WGS84 location with longitude -77.035915,
and latitude 38.889814.</p>
<p>After defining <em><strong>Tile Coordinates</strong></em>, our pursuit continues to
translate these coordinates to native device coordinates. To reiterate
our progress in the perspective of rendering, we just defined our local
space with tile coordinates. Local coordinates are the coordinates of
the object to be rendered relative to its local origin<sup class="footnote-reference" id="fr-13-1"><a href="#footnote-13">6</a></sup>. In this
case, the objects are the map tiles. The next step in traditional
rendering workflow is to translate object coordinates to world
coordinates. This is important to understand if we are to render
multiple objects in the world. If we treat all tiles in a zoom level
being rendered in a single 3D horizontal plane, then the World Space has
only one object. And in MapLibre Native, this plane has an origin of (0,0),
positioned on the top left.</p>
<h2 id="device-coordinates"><a class="header" href="#device-coordinates">Device Coordinates</a></h2>
<p>World space for MapLibre Native contains a plane in 3D with all the
tiles for any specific zoom level. Map tiles are hierarchical in nature.
As in they have different zoom levels. MapLibre Native internally
stores a tree object that mimics a tile pyramid. However, it does not
create a hierarchy of 3D planes where each plane mimics one zoom level.
It reuses the same 3D plane to re-render the tiles in the requested zoom
level at a time.</p>
<p>The journey towards rendering the tiles in the device screen from the
world space starts with <em>View Matrix</em>, as defined in the world space.
The key part here is the <em>camera</em>. A <em>view matrix</em> is a matrix that
scales, rotates, and translates<sup class="footnote-reference" id="fr-14-1"><a href="#footnote-14">7</a></sup> the world space from the view of
the camera. To add the perspective of the camera, we apply the
<em>Projection Matrix</em>. In MapLibre Native, a camera initialization
requires map center, bearing, and pitch.</p>
<p><em>Initializing the map with a center (lon, lat) does not translate or
move the 3D plane with tiles, rather moves the camera atop the defined
position named center. In the rendering world, this is not the center of
the 3D plane we render tiles on, rather the position of the camera.</em></p>
<p><img src="design/media/perspective-frustum.png" alt="">
<em>Figure 3: Perspective Frustum (Sourced from learnopengl.com)</em></p>
<p>The benefit of tile coordinates continues here. The camera representation
we use here, to be specific the view matrix, can directly take the tile
coordinates to move the camera to a particular tile in a zoom level.
Once a tile is built, the GPU can quickly draw the same tile with different
bearing, pan, pitch, and zoom parameters<sup class="footnote-reference" id="fr-15-1"><a href="#footnote-15">8</a></sup>.</p>
<p>If we keep following Figure 2, we see we need to also add a projection
matrix. And MapLibre Native uses a <em>perspective projection</em>.
Perspective projection matrix introduces the sense of depth perspective
through the camera. As in objects further from the camera will look
smaller and objects closer to the camera will look bigger. This
perspective component is defined by parameter <em>w.</em> That is why the
shaders that MapLibre Native at the time of writing uses 4
dimensional vectors over 3 dimensional vectors. The 4^th^ dimension is
this parameter <em>w</em>. Therefore, theoretically a GL coordinate is of the
form <code>(x, y, z, w)</code>.</p>
<p>Before we jump into the transformations, let’s revisit an example
scenario:</p>
<pre><code>zoom: 11.6
map center: (38.891, -77.0822)
bearing: -23.2 degrees
pitch: 45 degrees
tile: 585/783/11
</code></pre>
<p>On top of this, MapLibre Native uses a field of view of 36.87 degrees
or 0.6435011087932844 radians. This is somewhat arbitrary. The altitude
of the camera used to be defined as 1.5 screen heights above the ground.
The ground is the 3D plane that paints the map tiles. The field of view
is derived from the following formula:</p>
<pre><code>fov = 2 * arctan((height / 2) / (height * 1.5))
</code></pre>
<p>Factoring only the transformations of zoom, map center, bearing, pitch,
and tile in, with a viewport of 862 by 742 pixels, the projection matrix
will look like<sup class="footnote-reference" id="fr-16-1"><a href="#footnote-16">9</a></sup>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th><strong>x</strong></th><th><strong>y</strong></th><th><strong>z</strong></th><th><strong>w</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>x</strong></td><td>0.224</td><td>-0.079</td><td>-0.026</td><td>-0.026</td></tr>
<tr><td><strong>y</strong></td><td>-0.096</td><td>-0.184</td><td>-0.062</td><td>-0.061</td></tr>
<tr><td><strong>z</strong></td><td>0.000</td><td>0.108</td><td>-0.036</td><td>-0.036</td></tr>
<tr><td><strong>w</strong></td><td>-503.244</td><td>1071.633</td><td>1469.955</td><td>1470.211</td></tr>
</tbody>
</table>
</div>
<p>To use our <em>tile coordinates,</em> we will turn it to a 4D vector of
(x,y,z,w) with neutral w value 1. For brevity we used z value of 0. For
buildings and extrusions z value will not be 0. But this document does
not cover that.</p>
<p>So, tile coordinate <code>(x: 6120, y: 4151, z:0, w:1)</code> will transform to the
following due to a vector multiplication with the projection matrix:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th><strong>x</strong></th><th><strong>y</strong></th><th><strong>z</strong></th><th><strong>w</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>x = 6120</strong></td><td>0.2240.224 * 6120 = 1370.88</td><td>-0.079 * 6120 = -483.48</td><td>-0.026 * 6120 = -159.12</td><td>-0.026 * 6120 = -159.12</td></tr>
<tr><td><strong>z = 4151</strong></td><td>-0.096 * 4151 = -398.496</td><td>-0.184 * 4151 = -763.784</td><td>-0.062 * 4151 = -257.362</td><td>-0.061 * 4151 = 253.311</td></tr>
<tr><td><strong>z = 0</strong></td><td>0.000 * 0 = 0</td><td>0.108 * 0 = 0</td><td>-0.036 * 0 = 0</td><td>-0.036 * 0 = 0</td></tr>
<tr><td><strong>w = 1</strong></td><td>-503.244 * 1 = -503.244</td><td>1071.633 * 1 = 1071.633</td><td>1469.955 * 1 = 1469.955</td><td>1470.211 * 1 = 1470.211</td></tr>
<tr><td><strong>Final Vector</strong></td><td>469.14</td><td>-175.631</td><td>1053.473</td><td>1057.78</td></tr>
</tbody>
</table>
</div>
<p>The finalized vector is off from what we have expected with the result
from the simulation. This is due to multiplying with low precision.</p>
<p>The final vector will be <code>(x: 472.1721, y: -177.8471, z: 1052.9670, w: 1053.7176)</code>. This is not perspective normalized. Perspective
normalization happens when we divide all the components of this vector
with perspective component <em>w</em>.</p>
<pre><code>(472.1721 / 1053.72, -177.8471 / 1053.72, 1052.9670 / 1053.72)
= (x: 0.4481, y: -0.1688, z: 0.9993)
</code></pre>
<p>Doing this will take us into <em>clip space.</em> Clip coordinates contain all
the tile coordinates we wish to render in MapLibre Native but only in
a normalized coordinate space of <code>[-1.0, 1.0]</code>.</p>
<p>All that is left now is to translate this to viewport coordinates.
Following Figure 2, we use <em>viewport transform</em> to produce these
coordinates:</p>
<pre><code>Pixel Coordinates: (NormalizedX * width + width / 2, height / 2 -
NormalizedY * height)
 = (0.4481 * 862 + 431, 371 - (-0.1688 * 742))
 = (x: 624, y: 434)
</code></pre>
<p>These are our viewport screen coordinates where our desired WGS84
location longitude -77.035915 and latitude 38.889814 will be rendered.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-8">
<p>Clip coordinates are normalized to -1.0 to 1.0. For brevity, this
document does not dive deep into 3D rendering basics. <a href="#fr-8-1">↩</a></p>
</li>
<li id="footnote-9">
<p>For brevity, this document is assuming the world we live in is
three dimensional. <a href="#fr-9-1">↩</a></p>
</li>
<li id="footnote-10">
<p>For brevity, this document does not dive deep into reference
ellipsoids to approximates earth, also known as Datums. EPSG:4326 or
WGS84 is such a Datum or reference ellipsoid. <a href="#fr-10-1">↩</a></p>
</li>
<li id="footnote-11">
<p>There are other coordinate systems such as EPSG:54001 that uses
equirectangles over squares to project the WGS84 coordinates. This
document focuses on EPSG:3857 because MapLibre Native uses it by
default. <a href="#fr-11-1">↩</a></p>
</li>
<li id="footnote-12">
<p>This document scopes out the trigonometric proof of this
translation for brevity. To know more:
<a href="https://en.wikipedia.org/wiki/Web_Mercator_projection">https://en.wikipedia.org/wiki/Web_Mercator_projection</a> <a href="#fr-12-1">↩</a></p>
</li>
<li id="footnote-13">
<p>For brevity, this document does not speak in depth of rendering
basics in regards to coordinate systems. For more, please check:
<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">https://learnopengl.com/Getting-started/Coordinate-Systems</a> <a href="#fr-13-1">↩</a></p>
</li>
<li id="footnote-14">
<p>Scale, rotate, and translate are common rendering transformation
used to produce model, view, and projection matrices. These
operations are applied right to left. As in translate first, rotate
second, and scale last. Matrix multiplications are not commutative,
so order of operation matters. <a href="#fr-14-1">↩</a></p>
</li>
<li id="footnote-15">
<p>The piece of code we run on GPU is called a shader. We will see
more how shaders influence MapLibre Native rendering later in the
document. <a href="#fr-15-1">↩</a></p>
</li>
<li id="footnote-16">
<p>Matrix and examples produced from Chris Loers work hosted in:
<a href="https://chrisloer.github.io/mapbox-gl-coordinates/#11.8/38.895/-77.0757/40/60">https://chrisloer.github.io/mapbox-gl-coordinates/#11.8/38.895/-77.0757/40/60</a> <a href="#fr-16-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Expressions are <em>domain specific language (DSL)</em> built by Mapbox for
vector styles. Mapbox Vector Style is used in Mapbox Vector Tiles.
Mapbox Vector Tiles is a vector tile specification initiated by Mapbox
which was later widely adopted by the geospatial community.</p>
<p>To recap, Mapbox Vector Styles have 2 significant parts - <em>Sources</em> and <em>Layers</em>.
Sources define where the geospatial features to display the map are loaded from.
They can be GeoJSON, Mapbox Vector Tiles (MVT) etc. We draw said features
on map using <em>Layers</em>.</p>
<p>A <em>Layer</em> references a single source. This is where expressions kick in.
Expressions define how the data from a source will be painted in a layer
following a style. For example, a heatmap, requires the ability to paint
features in different zoom levels with different colors. Expressions
facilitate that. The rendering depends on the style of the layer along with
pitch, bearing, and zoom of the map. This was called <em>Data Driven Styling (DDS)</em>.
Another option that was used was to completely change the style in run time to
achieve the same outcome<sup class="footnote-reference" id="fr-17-1"><a href="#footnote-17">1</a></sup>.</p>
<p>The desire of being able to render a layer in different zoom levels
differently based on data drove the birth of <em>expressions</em>. To
summarize, expressions do the following:</p>
<ol>
<li>
<p>Expressions filter features from a source layer. This allows to
apply conditional styling on the full or parts of the feature.</p>
</li>
<li>
<p>Expressions apply rendering transformations to filtered features.
MapLibre offers expressions that can interpolate, and paint. An
expression can be applied to a feature constantly, zoom dependent,
property dependent, or in zoom and property dependent manner.</p>
</li>
</ol>
<p>For a simple example of an expression, we will build a layer that displays
a text field fixed text <code>hello world</code> for all features in a vector source:</p>
<pre><code class="language-json">{
  "id": "test",
  "type": "symbol",
  "source": "source",
  "layout": { "text-field": "Hello world" }
}
</code></pre>
<p>If we wanted it instead to display the name property of each feature,
we can use an expression like this:</p>
<pre><code class="language-json">{ "text-field": ["get", "name"] }
</code></pre>
<p>We can also mutate the value fetched from properties of the features. For
examplel, we can append a prefix <code>Hello</code> to the name by using the <code>concat</code>
expression:</p>
<pre><code class="language-json">{ "text-field": ["concat", "Hello, ", ["get", "name"]] }
</code></pre>
<p>By now, you probably have figured it out that expressions use a JSON-like
syntax to define. For brevity, let’s look at the construction of an example
expression below:</p>
<pre><code>'^': [
NumberType,
NumberType, NumberType],
(ctx, [b, e]) =&gt; Math.pow(b.evaluate(ctx), e.evaluate(ctx))
]
</code></pre>
<p>This defines an expression named <code>^</code> that returns a number
expression, and takes two number expressions as input. The
implementation follows right after. Another part to notice here is the
implementation evaluates both inputs because they are expressions too.
Expressions can be nested.</p>
<p><strong>Although it looks like JavaScript, for MapLibre Native</strong>, <strong>the
parser for any expression is written in MapLibre Native Core</strong>. Each
platform such as iOS, Android has their own Expression class which
provides builders to build an expression and add it to a layer. When an
expression is added to a layer, the rendering part of the code picks it
up in the MapLibre Native Core.</p>
<p>Also, inside MapLibre Native Core, this definition mechanism allows
extending expressions library with custom expressions if desired.</p>
<h2 id="expression-types"><a class="header" href="#expression-types">Expression Types</a></h2>
<p>In the example expression, we saw how one expression is defined. The
example also shows that expressions have types. Expression language can
accept input and output types of null, number, string, boolean, color,
object, value, array, error, collator, and formatted. The canonical
definition of Expressions is rooted in JSON. Like JSON, <code>object</code> type
is the mapping key type that maps a set of <em>keys</em> to <em>values</em>.</p>
<p>Beside the aforementioned data types, Expressions offer built-in functions
or operators such as assertion, coalesce, interpolate, distance etc.
The code uses the word <em>kind</em> to differentiate between these.
Each <em>kind</em> of expression performs a single responsibility.</p>
<p><em>Assertion expressions</em> assert the returning type from one expression is
asserted before putting into another. For example, a filter expression
of <code>["get", "feature_property"]</code>, returns a generic <em>value</em> type. To
use it on another expression that accepts a string type, an assertion
such as <code>["string", ["get", "feature_property"]]</code> is necessary.
Assertion throws an evaluation-time error if the types don’t match
during evaluation.</p>
<p>You might think this is a <em>coercion</em> instead of an <em>assertion</em>. If you are
seeking for coercions, read the upcoming paragraph. Expression names
that looks like <code>to-something</code> are coercions by convention.</p>
<p><em>Coercion expressions</em> convert a return type to another type. It also
allows to define a fallback if the conversion fails. A good example of
this is <em>to-number</em> expression. For example, <code>["to-number", ["get", "feature_property"], 0]</code> means that we are trying to cover the
feature-property to a number. If it fails, we will use 0 as a fallback.</p>
<p><em>Camera expressions</em> are expressions that allow style property
manipulation based on zoom, pitch, and distance from center.</p>
<p>Expressions are used <em>paint</em> property of a Mapbox Vector Style starting
with a <em>layer</em> or <em>filter</em> selector. Expressions are evaluated by following an
expression chain constructed from the root expression following the
input expressions recursively.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Implementation wise, expressions are divided into builders and parsers.
Each platform such as Android and iOS have dedicated builder classes for
different types of expressions. An example of interpolate expression
from Android will look like:</p>
<pre><code>fillLayer.setProperties(
    fillColor(
        interpolate(
            exponential(0.5f), zoom(),
            stop(1.0f, color(Color.RED)),
            stop(5.0f, color(Color.BLUE)),
            stop(10.0f, color(Color.GREEN))
        )
    )
);
</code></pre>
<p><strong>To render the built expression, MapLibre Native uses expression
parsers.</strong> <strong>Expression parsers are written in MapLibre Native Core
(in C++).</strong> Each expression outputs an <em>EvaluationResult</em> class.
Resolving an <em>EvaluationResult</em> can be deferred. As in, the result of an
expression can be computed only when its necessary to be computed in
runtime. A change induced by data or interaction in an expression
evaluation result will result in a new style load in the rendering loop.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-17">
<p>Sourced from Mapbox GL Native wiki:
<a href="https://github.com/mapbox/mapbox-gl-native/wiki/Expression-Architecture">https://github.com/mapbox/mapbox-gl-native/wiki/Expression-Architecture</a> <a href="#fr-17-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architectural-problems--recommendations"><a class="header" href="#architectural-problems--recommendations">Architectural Problems &amp; Recommendations</a></h1>
<p>Up until now, this document focused solely on the state of MapLibre
Native at the time of writing. This section speaks of possible future
improvements for MapLibre Native from an architectural point of view.
Before that, let’s look into the architectural challenges MapLibre
Native is facing<sup class="footnote-reference" id="fr-18-1"><a href="#footnote-18">1</a></sup>:</p>
<h2 id="renderer-coupled-with-opengl"><a class="header" href="#renderer-coupled-with-opengl">Renderer coupled with OpenGL</a></h2>
<p>The renderer component is tightly coupled to OpenGL ES. It uses OpenGL
ES as its only preferred rendering backend. Furthermore, MapLibre
Native does not have a clear separation between the following:</p>
<ol>
<li>
<p>The logical responsibility of rendering a map tile. This involves
sourcing layers, applying styles, fetching glyphs and sprites for a
map tile.</p>
</li>
<li>
<p>Rendering a prepared map tile in a rendering loop for a graphics API
such as OpenGL.</p>
</li>
</ol>
<p>The current rendering loop is only implemented for OpenGL. In 2018,
Apple deprecated OpenGL for both iOS 12 and macOS in favour of Metal.
Metal is Apple’s own 3D graphics API. MapLibre Native’s sole
dependency on OpenGL ES puts it in a risk of deprecation for iOS
customers.</p>
<h2 id="lack-of-support-for-other-map-projections-except-web-mercator"><a class="header" href="#lack-of-support-for-other-map-projections-except-web-mercator">Lack of support for other map projections except Web Mercator</a></h2>
<p>MapLibre Native supports Web Mercator (EPSG:3857) as its only
supported projection. This fulfills most of the web and device map
needs. At the time of writing, modern map renderers such as Google Maps
and Mapbox GL offers 3D globe, conic, and rectangular projections too.
At the time of writing, MapLibre Native renderer component does not
have an architectural separation for supporting multiple projections and
coordinate reference systems.</p>
<h2 id="inconsistency-among-platforms"><a class="header" href="#inconsistency-among-platforms">Inconsistency among platforms</a></h2>
<p>Each MapLibre Native platform has a Map View and Map Renderer
component. The inconsistency introduced due to differences in
concurrency model and programming language is unavoidable. But from an
abstractions point of view there are inconsistencies that can be
mitigated:</p>
<ol>
<li>
<p>Map Configuration is modeled inside MapLibre Native Core, the
shared cross platform codebase. Each platform creates its own
configuration class and creates a shadow native object. The native
configuration object is consistent across platforms but the platform
specific configuration is not.</p>
</li>
<li>
<p>MapLibre Native has a sister repository named MapLibre GL JS. At
the time of writing, MapLibre GL JS does not share any code with
MapLibre Native except shaders, the style specification, and
render test fixtures. This creates a feature inconsistency across
web and device experience for customers. The rendering architecture
is also different between Web and Mobile. MapLibre GL JS currently
uses WebGL through completely different implementations for Map,
Style, Layers, Glyph, and TileWorker.</p>
</li>
<li>
<p>MapLibre Rust is an experimental initiative to create a new MapLibre
implementation in Rust, entirely based on <em>WebGPU</em>. At the time of
writing, <em>WebGPU</em> is a young platform that exposes modern computer
graphics capabilities, especially Direct3D 12, Metal, and Vulkan
through a shared API. It has promise, but the API at the time of
writing only supports ChromeOS, macOS, and Windows 10. Technically,
it can be used with Android and iOS but these platforms do not
provide out of the box support for it. This also has created a
divergent experience for customers when it comes to using MapLibre
Native.</p>
</li>
</ol>
<h2 id="lack-of-documentation"><a class="header" href="#lack-of-documentation">Lack of documentation</a></h2>
<p>Last but not the least, MapLibre Native suffers from a general lack
of documentation. This includes current state of the code architecture,
continuous integration and development, testing strategy, and a roadmap
for future improvement. This document intends to address the first.</p>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<p>This document proposes the following component architecture for MapLibre
Native to address the architectural shortcomings.</p>
<p><img src="design/media/proposed-architecture-of-maplibre-gl.png" alt="">
<em>Figure 4: Proposed Architecture of MapLibre Native</em></p>
<p>Proposed architecture of MapLibre Native in Figure 4 addresses the
aforementioned problems by:</p>
<h4 id="modular-rendering"><a class="header" href="#modular-rendering">Modular Rendering</a></h4>
<p>Introducing modularized rendering through <em>Unified Rendering Interface</em>.
Unified Rendering Interface component will be responsible for
implementing different graphics API workers for any tile workers. Each
of these rendering workers will use platform specific shaders. This
document does not dive deep into how these shaders will be produced or
orchestrated. The problem <em>Unified Rendering Interface</em> solves is
architecturally drawing a boundary between</p>
<ol>
<li>
<p>The responsibility of rendering a map tile through GPU and,</p>
</li>
<li>
<p>Gathering all layers necessary to render a map tile through <em>tile
workers</em>.</p>
</li>
</ol>
<h4 id="projector-component"><a class="header" href="#projector-component">Projector Component</a></h4>
<p>Introducing a new component named <em>Projector.</em> A <em>projector</em> component
is responsible for adding multiple projection and coordinate system
support for map tiles. Projector will take the <em>features</em> to be rendered
as an input and project the layer to a projection or coordinate
reference system. Projected world coordinates will then be translated to
native device coordinates.</p>
<p>One example of introducing new component is supporting 3D maps in the
future. This could mean rendering map tiles on a spherical globe instead
of a flat 3D plane. At the time of writing MapLibre Native supports
2.5D extrusion for buildings and terrain tiles. Supporting confidential
datums like <em>GCJ-02</em> can also be achieved through this.</p>
<h4 id="future-convergence-with-webgpu"><a class="header" href="#future-convergence-with-webgpu">Future Convergence with WebGPU</a></h4>
<p>This document acknowledges the value proposition Rust brings. At the
time of writing, MapLibre Native Core is written in C++. Albeit written
in C++, MapLibre Native code relies on immutable message passing between
renderer and tile workers. Private functions also follow the <em>C++ move
semantics</em>. This means, each private function takes ownership of the
arguments passed to the function by copying it to a new memory.</p>
<p>Rust as a programming language enforces such intentions through compile
time safety checks. Provided Rust Foreign Function<sup class="footnote-reference" id="fr-19-1"><a href="#footnote-19">2</a></sup> Interface allows
interoperability with Rust, this document proposes the following to be
done in sequence:</p>
<ol>
<li>
<p>At first, this document proposes to implement <em><strong>Modularized
Rendering</strong></em> in C++ for MapLibre Native. This document also
proposes that Unified Rendering Interface will keep the door open
for a <em>WebGPU</em> backed renderer in MapLibre Native. This could address
the divergence of web and native platforms in the future. The WebGPU
renderer might be possible to compiled to WebAssembly and enable
WebGPU powered rendering for browsers. This paves the path forward for
a single unified renderer implementation for web and mobile devices.</p>
</li>
<li>
<p>After the delivery of <em><strong>Modularized Rendering</strong></em>, this document
proposes to eventually migrate <em>Style, Layers, Text, Glyphs,
Projector, Tile Worker, and Map</em> component to be migrated to Rust.</p>
</li>
<li>
<p>Finally, this document proposes to migrate Unified Rendering
Interface and its implementations to Rust. This will completely
transform MapLibre Native from a C++ ecosystem to a Rust
ecosystem.</p>
</li>
</ol>
<p>Following the above steps will merge towards a single MapLibre
implementation for web and native.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-18">
<p>This document deliberately does not speak of problems regarding
build and infrastructure of MapLibre Native. They will be handled
in individual design PR requests / documents. <a href="#fr-18-1">↩</a></p>
</li>
<li id="footnote-19">
<p>Rust Foreign Function Interface allows interop bindings and code
that needs to exchange C-Like strings with other programming
languages. <a href="#fr-19-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="android-map-rendering-data-flow"><a class="header" href="#android-map-rendering-data-flow">Android Map Rendering Data Flow</a></h1>
<p><img src="design/media/android-data-flow.jpg" alt="">
<em>Figure 5: Simplified data flow diagram of initializing a map in Android</em></p>
<p>Figure 5 shows a simplified data flow diagram of initializing a map. The
device section of this data flow diagram is based on Android platform.</p>
<p>Before the map initialization request makes it to MapLibre Native
Core, the request initializes a set of peer components in the platform
or device runtime. Especially for Android, we have parts written in C++
using <em>Android Native Development Kit</em> and parts written in Java.</p>
<p>A map initialization starts with initializing a map in an Android View.
A View occupies a rectangular area on the screen and is responsible for
drawing and event handling. In this diagram this is denoted as a Map
View inside the device runtime. This view is also responsible for
initiating a Device Map Renderer which subsequently initializes a GL
Thread worker. This thread is a render loop that takes UI events from
the Android View and passes it downstream to get the rendered map.</p>
<p>On the native C++ side of the device code, we see a peer Map View
component. This one is a wrapper class between the Android Map View and
the generic Map Component. For Android, this maintains the JNI method
contract established from the Java runtime. The render thread this
document talked about before is seen in the form of <em>MapRenderer</em>. This
is an Actor that passes the rendering events from the device runtime to
<em>MapLibre Native</em> renderer.</p>
<p><img src="design/media/workflow-of-rendering-tiles.jpg" alt="">
<em>Figure 6: Workflow of rendering tiles</em></p>
<p>Before the frame-by-frame map rendering
starts with <em>MapLibre Native</em> renderer, the generic map component
gets initialized. Rendering each frame of a map tile or initializing the
map view requires a set of <em>Transforms.</em> Through transform basic
mutations like rotation, tilt, projection is accomplished. Transforms
are essential for every aspect of rendering such as resizing the
viewport, setting initial map camera, changes in map camera due to tilt,
zoom, and movement. Each of these operations manifest into a set of
<em>Transforms</em> that gets applied to the to-be-rendered map tile or already
rendered map tile. The <em>Transform</em> class noted in the diagram however
does not represent a single or multitude of transformations. A Map View
like other components inside MapLibre works as a state machine. The
<em>Transform</em> class maintains the current set of global transforms applied
to the map. To simplify to change the camera orientation, zoom, or pitch
a Map View will update the state of the Transform class. And the
Transform class will use observers to send a transform event to
<em>MapLibre Native</em> renderer. This overall transform directive, such as
change camera location from point A to point B will translate to a set
of transformations deduced by the <em>Renderer</em> component.</p>
<p>Along initializing the <em>Transform</em> state, the Map View will also
initialize the <em>Style</em> sub-component. The Style component here also
follows a state machine-esque behaviour. It holds the current state of
used Styles for the Map View along with layers, glyphs, and sources. A
change in style or initialization of style translates to re-loading the
<em>Glyph Atlas</em>, <em>Sources, and Layers.</em> A <em>Glyph Atlas</em> is a combined
image all glyphs. The renderer slices the necessary glyph by bounding
boxes whenever necessary. Different sources are loaded differently. For
Tilesets, the tile data is loaded but not rendered right away. For
client provided data sources such as GeoJSON, the data is loaded from
the file source or code. Then these sources are organized into layers
dictated by the style and the layers are sent for rendering through the
actors.</p>
<p>The key philosophy of rendering tiles is tiles are rendered layer by
layer. A collection of tiles is called a tile set. To optimize tile
rendering, MapLibre Native only renders <em>dirty</em> tiles. A dirty tile
is a tile rendered in the viewport that has changed due to user
interaction. To initiate this process, MapLibre Native loads the
tileset to be rendered first. In a rendering request, if the tileset is
already loaded, MapLibre Native will use a cached tile set.</p>
<p>The next decision to make here is which tiles are to be rendered on the
viewport. To deduce this, MapLibre Native translates the device
viewport coordinates<sup class="footnote-reference" id="fr-20-1"><a href="#footnote-20">1</a></sup> to a tile cover. A tile cover loads all the
tiles that will rendered to current viewport. If the viewport already
has all the tiles that is needed to be rendered by the deduced tile
cover, there are no <em>dirty</em> tiles. If the tile cover somehow has a
single or all new tiles to be rendered in the viewport, the existing
tiles displayed in the viewport are deduced to be <em>dirty.</em> And only
these tiles are replaced instead of a complete re-render.</p>
<p>Moving to the render flow now. The render flow is depicted in Figure 7.
The diagram introduces a new component block named a <em>Tile Renderer.</em>
These diagrams might look verbose but in reality, they are a simplified
version of the actual code flow.</p>
<p>The render workflow stays the same as the initialization workflow up to
<em>reaching the Render Orchestrator.</em> This time instead of initializing
the <em>render orchestrator</em>, the flow uses the render orchestrator to
create a <em>Render Tree.</em> A render tree is a tree of to-be-rendered items
in order. This includes rendering items from layers, sources, line
atlas, and pattern atlas. A render orchestrator does not render anything
by itself. It orchestrates render items for the <em>renderer</em>.</p>
<p>In the render loop ran by the <em>Renderer</em>, each render request ends in
<em>creating a new render tree, and the render function.</em> The render
function uses a glyph manager for fetching glyphs and font stacks that
contains said glyphs. Sources and Layers are translated to
<em>RenderSource</em> and <em>RenderLayer</em> objects.</p>
<p><em>For the sake of restating, a layer is composed of a set of sources.</em></p>
<p><img src="design/media/android-rendering-map-tiles.jpg" alt="">
<em>Figure 7: Simplified data flow diagram of rendering map tiles</em></p>
<p>A <em>RenderSource</em> is produced from a single
source that has an internal <em>update</em> method. This method produces the
<em>tile pyramid</em> to render for said source if the source is a
<em>TileSource</em>. For brevity, this document only talks about tile sources.
There are other types such as GeoJSON sources. They work in a similar
manner as the tile source.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-20">
<p>Viewport coordinates are derived from the coordinate system of
the device screen. Anything rendered inside a unit cube of local
space is translated to screen space of actual pixels. The tiles are
rendered in a local space before rendered back to screen. We will
see more about that in Coordinate System section. <a href="#fr-20-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="geometry-tile-worker"><a class="header" href="#geometry-tile-worker">Geometry Tile Worker</a></h1>
<p><img src="design/media/geometry-tile-worker-state-machine.jpg" alt="">
<em>Figure 8: Simplified Geometry Tile Worker State Machine</em></p>
<p>Going back to Geometry Tile Worker, it is
a state machine. The main principle is that Geometry Tile Worker should
carry out each task till completion once it has begun even if it
requires asynchronous waiting<sup class="footnote-reference" id="fr-21-1"><a href="#footnote-21">1</a></sup>. When a Geometry Tile Worker is
working on a task, any new message to said worker is queued. Messages
per <em>unique tile</em> are grouped. Upon finishing work, Geometry Tile Worker
picks the latest message from the queue. All changes introduced in the
queued messages are <em>coalesced</em> for the next work item for the tile
worker. This way, a Geometry Tile Worker saves itself from starvation
when it is under heavy workload. <em>Coalescing</em> also helps at finalizing
the result when all the messages are processed because the map has
stopped moving.</p>
<p>To dive a little bit deeper into this process, let’s have a quick look
at Figure 8. It shows a simplified representation of Geometry Tile
Worker state machine. From a cursory look, the state transitions might
not seem self-explanatory. We will take one step at a time to clarify.</p>
<p><em>Going forward, this section will use the term <strong>worker</strong> to denote a
<strong>Geometry Tile Worker</strong> for brevity.</em></p>
<p>A <em>worker</em> is <em>Idle</em> when it has nothing to work on or completed
<em>coalescing</em> queued messages. It is in <em>Coalescing</em> state when it has
not finished processing all the messages in the queue. These two states
are the two key states the <em>worker</em> floats between.</p>
<p>The initial transition from <em>Idle</em> to <em>coalescing</em> starts from a
<em><strong>set</strong></em> message. A worker can receive a <strong>set</strong> message for data or a
layer that is dependent on data. Referring back to <strong>Figure 8</strong>, this is
what the transition label (<strong>set</strong> {Data, Layers} ) from <em>Idle</em> to
<em>Coalescing</em> state stands for. This initiates an internal workflow named
<em><strong>Parsing.</strong></em> Parsing means understanding the features to be rendered
in a layer. Parsing process is encapsulated in <em>parse()</em> method. In the
end of this method, a worker will also deduce required glyphs and images
to render the tile.</p>
<p>A worker will send a message to the Tile it is working on fetching the
necessary glyphs and images. From a threading perspective, it can happen
in the same thread as the worker or in a different thread. Looking back
to Figure 8, we also see another transition path from <em>Idle</em> state to
<em>coalescing</em> state through <em>symbolDependenciesChanged</em> event. When a
tile object is done with downloading pending glyphs and images it issues
a <em>onImagesAvailable</em> or <em>onGlyphsAvailable</em> event to the worker<sup class="footnote-reference" id="fr-22-1"><a href="#footnote-22">2</a></sup>.
Both of these events will translate to <em>symbolDependenciesChanged</em> event
in the end. When <em>symbolDependenciesChanged</em> is fired, if the worker is
on <em>Idle</em> state, it will move to <em>Coalescing</em> state. If the worker was
already working on a tile and <em>symbolDependenciesChanged</em> is fired in
the middle, it will move to <em>NeedsSymbolLayout</em> state.</p>
<h2 id="restart-a-worker-in-progress-needsparse-and-needssymbollayout-state"><a class="header" href="#restart-a-worker-in-progress-needsparse-and-needssymbollayout-state">Restart a worker in-progress: NeedsParse and NeedsSymbolLayout state</a></h2>
<p>The logical question to ask right now is why does the worker have
<em>NeedSymbolLayout</em> and <em>NeedsParse</em> state at all? Based on what we have
seen so far, parsing and fetching symbols (glyphs, images) can be done
in <em>Coalescing</em> state. This is to distinguish incremental changes
introduced while the worker is already working on something. This was to
facilitate a reset of current work and force the worker to <em>parse</em> and
<em>fetch</em> symbols again from the <em>Coalescing</em> state. If we look back to
Figure 8 now, we will see that <em>Coalescing</em> state goes to
<em>NeedsSymbolLayout</em> if a symbol update (glyphs, images) has been
encountered. <em>NeedsSymbolLayout</em> state will go to <em>NeedsParse</em> state
with a <em><strong>set</strong></em> method invocation after updating the symbols.
<em>Coalescing</em> state will go straight to <em>NeedsParse</em> state if only
incremental data or layer change is introduced with a <em><strong>set</strong></em> method
invocation.</p>
<p>To summarize, restarting an in-progress <em>worker</em> requires:</p>
<ol>
<li>
<p>Send <em>symbolDependenciesChanged</em> through <em>onImagesAvailable</em> or
<em>onGlyphsAvailable event.</em> To re-emphasize, these are not messages
passed to the worker, rather events invoked through methods.</p>
</li>
<li>
<p>This will interrupt old parsing process and issue a new <em><strong>set</strong></em>
method to re-parse data from <em>NeedsSymbolLayout</em> or <em>Coalescing</em>
state. In both cases, the worker will end up in <em>NeedsParse</em> state
to re-parse.</p>
</li>
</ol>
<p><em>setShowCollisionBoxes</em> event works in similar fashion. This event is
used to show text label collision boxes in the to-be-rendered tile. It
is used for debugging collision detection of text labels.</p>
<h2 id="finalization"><a class="header" href="#finalization">Finalization</a></h2>
<p>A worker finalizes its work when all required data is parsed, and all
symbols are loaded in a layout.</p>
<p>A <em><strong>Symbol Layout</strong></em> is the process of turning raw features into OpenGL
buffers ready to be rendered. To simplify, a <em>symbol layout</em> contains
images, glyphs, and their collision metadata positions relative to the
tile to be rendered.</p>
<p>When a geometry tile worker has completed its work, it moves to <em>Idle</em>
state by self-sending <em>coalesced</em> transition. Reiterating again, to
consider the worker has coalesced, it has to <em>parse</em> all the <em>coalesced</em>
data from available messages in the queue for a particular tile.</p>
<hr>
<hr>
<ol class="footnote-definition">
<li id="footnote-21">
<p>This is not entirely true. Going forward this section will shed
some light on <em>why.</em> For the time being, the assumption accelerates
understanding. <a href="#fr-21-1">↩</a></p>
</li>
<li id="footnote-22">
<p>In reality, <em>onGlyphsAvailable</em> and <em>onImagesAvailable</em> events
will be fired from GlyphManager and ImageManger instances. For
brevity, this document does not speak of these classes. <a href="#fr-22-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="maplibre-native-profiling"><a class="header" href="#maplibre-native-profiling">MapLibre Native profiling</a></h1>
<p>MabLibre Native integrates <a href="https://github.com/wolfpld/tracy">Tracy profiler</a> which offers an easy way to understand and optimize your application’s CPU and GPU performance</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tracy-profiling"><a class="header" href="#tracy-profiling">Tracy profiling</a></h1>
<h4 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h4>
<p>MapLibre Native integrates <a href="https://github.com/wolfpld/tracy">Tracy profiler</a> which offers an easy way to understand and optimize your application’s CPU and GPU performance.
Tracy mainly consists in manually adding markup instrumentation in the code to log performance events. These events can then be analyzed and visualized using the <a href="https://github.com/wolfpld/tracy/tree/master/profiler">Tracy Profiler tool</a>.</p>
<p>Instrumentation is generally the first step in profiling applications that use MapLibre. Once slow inner-loop routines are identified, additional hardware vendor specific tools can be used to collect hardware counters and optimize low level CPU and GPU code.</p>
<h4 id="tracy-client"><a class="header" href="#tracy-client">Tracy client</a></h4>
<p>Tracy client consists of an API to mark CPU and GPU performance zones. A zone is a code section where the start and end timestamps are recorded.</p>
<h4 id="tracy-server"><a class="header" href="#tracy-server">Tracy server</a></h4>
<p>The server is the Tracy profiler that allows the analysis and visualization of the client recorded data.
The server can be downloaded from <a href="https://github.com/wolfpld/tracy/releases">Tracy release page</a> or it can be easily built from <a href="https://github.com/wolfpld/tracy/tree/master/profiler">sources</a> on Linux, Windows or Mac using CMake</p>
<h4 id="enabling-instrumentation-in-maplibre-native"><a class="header" href="#enabling-instrumentation-in-maplibre-native">Enabling instrumentation in MapLibre Native</a></h4>
<p>Instrumentation is enabled by turning <code>ON</code> the CMake option <code>MLN_USE_TRACY</code>.
Tracy computational overhead is very low but by default it keeps all instrumentation events that are not consumed by the server in system memory. This can have a negative effect on platforms with low memory. To prevent high memory usage, <code>TRACY_ON_DEMAND</code> macro should defined. This way instrumentation data is only stored when the server is connected to the application.</p>
<h4 id="instrumentation-in-maplibre"><a class="header" href="#instrumentation-in-maplibre">Instrumentation in MapLibre</a></h4>
<p>The file <code>include/mbgl/util/instrumentation.hpp</code> defines the following instrumentation macros:</p>
<h5 id="mln_trace_zonelabel"><a class="header" href="#mln_trace_zonelabel"><code>MLN_TRACE_ZONE(label)</code></a></h5>
<p>The macro records the timestamps at the start and end of the code scope. The parameter label is a user defined name for the zone. Example:</p>
<pre><code class="language-cpp">// code is not instrumented
{
  MLN_TRACE_ZONE(EmptyZone) // Records from here until the end of the scope
  // code here is instrumented
}
// other here not instrumented
</code></pre>
<h5 id="mln_trace_func"><a class="header" href="#mln_trace_func"><code>MLN_TRACE_FUNC()</code></a></h5>
<p>The macro is meant to be placed at the start of a function and expands to:</p>
<pre><code class="language-cpp">MLN_TRACE_ZONE(__FUNCTION__)
</code></pre>
<h5 id="gpu-instrumentation"><a class="header" href="#gpu-instrumentation">GPU instrumentation</a></h5>
<p>OpenGL is also supported in MapLibre native. Tracy support is currently missing for other APIs such as Metal and need to be added separately.</p>
<h5 id="mln_trace_gl_zonelabel"><a class="header" href="#mln_trace_gl_zonelabel"><code>MLN_TRACE_GL_ZONE(label)</code></a></h5>
<p>This macro is similar to <code>MLN_TRACE_ZONE</code> except that <a href="https://www.khronos.org/opengl/wiki/Query_Object">OpenGL timestamp queries</a> are inserted in the GPU command buffer instead of recording CPU time.</p>
<h5 id="mln_trace_func_gllabel"><a class="header" href="#mln_trace_func_gllabel"><code>MLN_TRACE_FUNC_GL(label)</code></a></h5>
<p>This macro is similar to <code>MLN_TRACE_FUNC</code> except that <a href="https://www.khronos.org/opengl/wiki/Query_Object">OpenGL timestamp queries</a> are inserted in the GPU command buffer instead of recording CPU time.</p>
<h5 id="other-macros"><a class="header" href="#other-macros">Other macros</a></h5>
<p>The above macros can be added inside MapLibre code and also in the application code that calls MapLibre.</p>
<p>The following macros should only be used if there are changes to MapLibre internals:</p>
<h5 id="mln_end_frame"><a class="header" href="#mln_end_frame"><code>MLN_END_FRAME()</code></a></h5>
<p>Mark the end of a frame.</p>
<h5 id="mln_trace_gl_context"><a class="header" href="#mln_trace_gl_context"><code>MLN_TRACE_GL_CONTEXT()</code></a></h5>
<p>Placed after an OpenGL context is created.</p>
<h5 id="mln_trace_alloc_textureid-size-and-mln_trace_free_textureid"><a class="header" href="#mln_trace_alloc_textureid-size-and-mln_trace_free_textureid"><code>MLN_TRACE_ALLOC_TEXTURE(id, size)</code> and <code>MLN_TRACE_FREE_TEXTURE(id)</code></a></h5>
<p>Record a read-only texture allocation and deallocation</p>
<h5 id="mln_trace_alloc_rtid-size-and-mln_trace_free_rtid"><a class="header" href="#mln_trace_alloc_rtid-size-and-mln_trace_free_rtid"><code>MLN_TRACE_ALLOC_RT(id, size)</code> and <code>MLN_TRACE_FREE_RT(id)</code></a></h5>
<p>Record a render target texture allocation and deallocation</p>
<h5 id="mln_trace_alloc_vertex_bufferid-size-and-mln_trace_free_vertex_bufferid"><a class="header" href="#mln_trace_alloc_vertex_bufferid-size-and-mln_trace_free_vertex_bufferid"><code>MLN_TRACE_ALLOC_VERTEX_BUFFER(id, size)</code> and <code>MLN_TRACE_FREE_VERTEX_BUFFER(id)</code></a></h5>
<p>Record a buffer allocation and deallocation that is intended to be used as a read-only vertex buffer</p>
<h5 id="mln_trace_alloc_index_bufferid-size-and-mln_trace_free_index_bufferid"><a class="header" href="#mln_trace_alloc_index_bufferid-size-and-mln_trace_free_index_bufferid"><code>MLN_TRACE_ALLOC_INDEX_BUFFER(id, size)</code> and <code>MLN_TRACE_FREE_INDEX_BUFFER(id)</code></a></h5>
<p>Record a buffer allocation and deallocation that is intended to be used as a read-only index buffer</p>
<h5 id="mln_trace_alloc_const_bufferid-size-and-mln_trace_free_const_bufferid"><a class="header" href="#mln_trace_alloc_const_bufferid-size-and-mln_trace_free_const_bufferid"><code>MLN_TRACE_ALLOC_CONST_BUFFER(id, size)</code> and <code>MLN_TRACE_FREE_CONST_BUFFER(id)</code></a></h5>
<p>Record a buffer allocation and deallocation that is intended to be used as a constant buffer</p>
<h4 id="usage-example-on-linux-and-windows"><a class="header" href="#usage-example-on-linux-and-windows">Usage example on Linux and Windows</a></h4>
<p>Download or build the Tracy profiler (server) and run it.</p>
<p>Make sure you generate the MapLibre project with the option <code>MLN_USE_TRACY</code> enabled.</p>
<p>As an example, the glfw sample is used.</p>
<p>With CMake, in MapLibre repository root do</p>
<pre><code class="language-bash"># generate project
cmake -B build -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=RelWithDebInfo -DMLN_WITH_CLANG_TIDY=OFF -DMLN_WITH_COVERAGE=OFF -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON -DMLN_USE_TRACY=ON
# build
cmake --build build --target mbgl-glfw -j 8
# run
./build/platform/glfw/mbgl-glfw --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --benchmark
</code></pre>
<p>with Bazel</p>
<pre><code class="language-bash"># build and run
bazel run //platform/glfw:glfw_app -- --style https://raw.githubusercontent.com/maplibre/demotiles/gh-pages/style.json --benchmark
</code></pre>
<p>In the Tracy Profiler hit the connect button (or select the glfw application from the list of applications that are running Tracy Client). Profile then optimize the code.</p>
<h4 id="connecting-the-profiler-to-a-maplibre-android-application"><a class="header" href="#connecting-the-profiler-to-a-maplibre-android-application">Connecting the profiler to a MapLibre Android application</a></h4>
<p>The Android application communicates instrumentation data to the profiler (Tracy server) on the network using port 8086 by default. You can expose the port to the profiler using Android Debug Bridge by running the command:</p>
<pre><code class="language-bash">adb forward tcp:8086 tcp:8086
</code></pre>
<h4 id="more-information-and-advanced-usage-in-tracy"><a class="header" href="#more-information-and-advanced-usage-in-tracy">More information and advanced usage in Tracy</a></h4>
<ul>
<li><a href="https://github.com/wolfpld/tracy/">Tracy Github page</a></li>
<li><a href="https://github.com/wolfpld/tracy/releases/latest/download/tracy.pdf">Tracy user guide</a></li>
<li><a href="https://www.youtube.com/watch?v=fB5B46lbapc">Tracy demo on Youtube</a></li>
<li><a href="https://www.youtube.com/watch?v=ghXk3Bk5F2U&amp;t=37s">Tracy CppCon presentation on Youtube</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>We have added experimental support for integrating Rust code into the source tree.</p>
<h2 id="rust-bridge"><a class="header" href="#rust-bridge">Rust Bridge</a></h2>
<p>The Rust bridge lives in the root <code>rustutils</code> directory.</p>
<p>We use <a href="https://cxx.rs/">CXX</a> to allow interop between Rust and C++.</p>
<h2 id="building-3"><a class="header" href="#building-3">Building</a></h2>
<h3 id="cmake-2"><a class="header" href="#cmake-2">CMake</a></h3>
<p>When building with CMake, need to have the correct Rust toolchain(s) installed. See <a href="https://www.rust-lang.org/tools/install">Install Rust</a> to install Rust.</p>
<p>You can use <code>rustup</code> to manage toolchains. Which toolchain you needs depends on your host platform and for what platform you are trying to build. If your host and target platform are the same, you probably have the correct toolchain installed after installing Rust. For example when building for <strong>Android</strong> and building on a <strong>x84 Linux</strong> host you would use the following command:</p>
<pre><code class="language-shell">rustup target add --toolchain stable-x86_64-unknown-linux-gnu aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
</code></pre>
<p>See <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Platform Support</a> in the Rust documentation for more details. You will get a descriptive error message when the correct toolchain is not available, so we don’t list all possible combinations here.</p>
<p>You also need to have cxxbridge installed:</p>
<pre><code class="language-shell">cargo install cxxbridge-cmd@1.0.157 --locked
</code></pre>
<p>Set <code>-DMLN_USE_RUST=ON</code> when generating a configuration with CMake.</p>
<h3 id="bazel-2"><a class="header" href="#bazel-2">Bazel</a></h3>
<p>Pass the <code>--//:use_rust</code> flag to Bazel commands.</p>
<p>Note that when <a href="ios/README.html">generating an Xcode project</a> you should not pass this option to Bazel directly, but as follows:</p>
<pre><code class="language-shell">bazel run //platform/ios:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags="--//:renderer=metal --//:use_rust"
</code></pre>
<h2 id="just"><a class="header" href="#just">Just</a></h2>
<p>For the Rust subproject, we suggest installing <a href="https://github.com/casey/just#readme">just</a>, a modern alternative to <code>make</code>. The <code>justfile</code> in the root directory contains a number of useful commands for building and testing the Rust code.  The same commands can be run directly, but <code>just</code> provides a more convenient interface.</p>
<ul>
<li>Install <code>just</code> with <code>cargo install just</code></li>
<li>Run <code>just</code> in the <code>/rustutils</code> dir to see a list of available commands</li>
<li>Some common commands: <code>just check</code>, <code>just test</code>, <code>just fmt</code></li>
<li>To run the same steps as used by CI, run <code>just ci-test</code></li>
</ul>
<h2 id="creating-a-new-module"><a class="header" href="#creating-a-new-module">Creating a new Module</a></h2>
<p>To create a new module:</p>
<ol>
<li>Add a new source file to <code>rustutils/src/example.rs</code>.</li>
<li>Implement it, see the <a href="https://cxx.rs/index.html">CXX documentation</a> or see <code>rustutils/src/color.rs</code> for an example.</li>
<li>Create a C++ source file that will use the generated C++ header. See <code>src/mbgl/util/color.rs.cpp</code> for an example. Import the generated header with
<pre><code class="language-cpp">#include &lt;rustutils/example.hpp&gt;
</code></pre>
</li>
<li>Conditionally include either the <code>*.rs.cpp</code> file or the <code>*.cpp</code> file it replaces in CMake and Bazel. Here is what it looks like for CMake:
<pre><code class="language-cmake">${PROJECT_SOURCE_DIR}/src/mbgl/util/color$&lt;IF:$&lt;BOOL:${MLN_USE_RUST}&gt;,.rs.cpp,.cpp&gt;
</code></pre>
And here for Bazel:
<pre><code class="language-bazel">select({
  "//:rust": [
      "src/mbgl/util/color.rs.cpp",
  ],
  "//conditions:default": [
      "src/mbgl/util/color.cpp",
  ],
})
</code></pre>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
