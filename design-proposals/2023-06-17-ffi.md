# Foreign Function Interface (FFI) Library

## Motivation

Enable FFI bindings (C API) with MapLibre API for Rust and Dart (Flutter) using a Foreign Function Interface (FFI) Library.

## Proposed Change

Add a C API to the MapLibre source tree in the form of a FFI library.  This library would be integrated into CMake as an optional target.  The external FFI API would be exposed using a C header file.  This header file would be consumed by Rust and Dart interface generation tools.

A longer term strategy could be to expose extern C interfaces directly in the common source tree.  This would decrease the long term cost of ownership.

The approach that evolved to this proposed solution involved decoupling GLFW from the GLFW app, then abstracting out platform and backend code.  This was initialy done targeting Flutter, after which the same API was used to create a Rust app that behaves similar to the GLFW application.

### Common Interface

* version - returns FFI interface version
* initialize - returns unique context pointer
* de_initialize - tears down map instance and frees context
* draw_frame - renders a single frame
* resize - resizes the map
* run_task - used for housekeeping tasks independent of render path
* load_gl_functions - function pointer callback for resolving GL functions

### Map Instance Lifecycle

It is expected to dynamically control the lifecycle of one or many map instances at runtime.

### Multiple Maps

* Multiple maps are run in the same process.  This enables sharing of a single ambient cache.

* Some use cases require four simultaneous map instances

Multiple map instances are enabled using a unique context pointer.  A unique context pointer is passed back for every `initialize` invocation. The context pointer is release on `de_initialized` or when the library reference is destroyed.

Each instance requires a unique FBO, which is passed into draw_frame.

The `draw_frame` call is optimally tied to the host compositor "onFrame" callback.

A housekeeping thread in the primary app is used to call `run_task` for each map instance.  This prevents introducing variability to the render path.

### Global Functions

Functions that impact all map instances are implemented as static functions, and do not require a context.

* NetworkStatus on/off
* InvalidateAmbientCache

### Backend Selection

* Build flags determine the backend

The environment that consumes the FFI library is responsible for initializing its own graphics backend.  This limits a library artifact to a specific platform (Mac, Window, Linux) and runtime revision.  The required parts are passed into the FFI initialize call using an opaque data pointer (nativeWindow).  Backend/Platform build flags determine how this opaque data pointer is cast/used.

This approach enables minimizing platform specific code in the FFI library.

## API Modifications

No change to the core MapLibre API, as a subset of the complete MapLibre API would be exposed via non-mangled interface.

## Migration Plan and Compatibility

No migration plan required.

## Rejected Alternatives

Unknown
