package org.maplibre.android.annotations

import android.graphics.PointF
import androidx.annotation.UiThread
import androidx.annotation.VisibleForTesting
import com.mapbox.geojson.Feature
import com.mapbox.geojson.FeatureCollection
import java.util.concurrent.atomic.AtomicBoolean
import org.maplibre.android.geometry.LatLng
import org.maplibre.android.log.Logger
import org.maplibre.android.maps.MapLibreMap
import org.maplibre.android.maps.MapLibreMap.OnMapClickListener
import org.maplibre.android.maps.MapLibreMap.OnMapLongClickListener
import org.maplibre.android.maps.MapView
import org.maplibre.android.maps.Style
import org.maplibre.android.style.expressions.Expression
import org.maplibre.android.style.layers.Layer
import org.maplibre.android.style.layers.PropertyValue
import org.maplibre.android.style.sources.GeoJsonOptions
import org.maplibre.android.style.sources.GeoJsonSource
import timber.log.Timber

/**
 * Generic AnnotationManager, can be used to create annotation specific managers.
 *
 * @param L type of the underlying layer
 * @param T type of annotation that the manager handles
 */
abstract class AnnotationManager<L : Layer, T : KAnnotation<*>> @UiThread internal constructor(
    private val mapView: MapView,
    protected val maplibreMap: MapLibreMap,
    protected var style: Style,
    protected var coreElementProvider: CoreElementProvider<L>,
    private val draggableAnnotationController: DraggableAnnotationController,
    private val belowLayerId: String?,
    private val aboveLayerId: String?,
    geoJsonOptions: GeoJsonOptions?
) {
    @VisibleForTesting
    internal val annotations: MutableMap<Long, T> = mutableMapOf()

    @VisibleForTesting
    internal var usedDataDrivenProperties: MutableList<String> = mutableListOf()

    val constantPropertyUsageMap: MutableMap<String, PropertyValue<*>> = mutableMapOf()
    var layerFilter: Expression? = null
    private val dragListeners: MutableList<OnAnnotationDragListener<T>> = mutableListOf()
    private val clickListeners: MutableList<OnAnnotationClickListener<T>> = mutableListOf()
    private val longClickListeners: MutableList<OnAnnotationLongClickListener<T>> = mutableListOf()

    /**
     * IDs generated by managers are negative, IDs generated by MaplibreMap are positive.
     *
     * This is not strictly necessary, as the managers that are used internally by MaplibreMap
     * are not exposed to the user, so they can't manually add any IDs.
     *
     * All unattached annotations have the ID 0.
     */
    private var nextId: Long = -1
    protected lateinit var layer: L
    protected lateinit var geoJsonSource: GeoJsonSource
    private val mapClickResolver: MapClickResolver
    private val isSourceUpToDate = AtomicBoolean(true)

    init {
        if (!style.isFullyLoaded) {
            throw RuntimeException("The style has to be non-null and fully loaded.")
        }
        mapClickResolver = MapClickResolver().also {
            maplibreMap.addOnMapClickListener(it)
            maplibreMap.addOnMapLongClickListener(it)
        }
        draggableAnnotationController.addAnnotationManager(this)
        initializeSourcesAndLayers(geoJsonOptions)
        mapView.addOnDidFinishLoadingStyleListener {
            maplibreMap.getStyle { loadedStyle ->
                style = loadedStyle
                initializeSourcesAndLayers(geoJsonOptions)
            }
        }
    }

    val layerId: String
        /**
         * Returns a layer ID that annotations created by this manager are laid out on.
         *
         *
         * This reference can be used together with [Style.addLayerAbove]
         * or [Style.addLayerBelow] to improve other layers positioning in relation to this manager.
         *
         * @return underlying layer's ID
         */
        get() = layer.id

    /**
     * Add an annotation to the layer that this manager handles.
     */
    @UiThread
    fun add(annotation: T) {
        if (annotation.id == 0L) {
            // At this point, the annotation has no ID iff the user has added it directly to the manager.
            annotation.attach(this, nextId--)
        }
        annotations[annotation.id]?.let {
            throw IllegalStateException("An ID was generated twice.")
        }
        annotations[annotation.id] = annotation
        updateSource()
    }

    /**
     * Add multiple annotations to the layer that this manager handles.
     */
    @UiThread
    fun addAll(annotations: List<T>) {
        annotations.forEach {
            add(it)
        }
    }

    /**
     * Delete an annotation from the layer that this manager handles.
     *
     * @param annotation annotation to be deleted
     */
    @UiThread
    fun delete(annotation: T) {
        annotations.remove(annotation.id)
        draggableAnnotationController.onAnnotationDeleted(annotation)
        updateSource()
    }

    /**
     * Deletes multiple annotations from the layer that this manager handles.
     *
     * @param annotationList the list of annotations to be deleted
     */
    @UiThread
    fun delete(annotationList: List<T>) {
        annotationList.map { it.id }.forEach { annotations.remove(it) }
        annotationList.forEach {
            draggableAnnotationController.onAnnotationDeleted(it)
        }
        updateSource()
    }

    /**
     * Deletes all annotations from the map.
     */
    @UiThread
    fun deleteAll() {
        annotations.forEach {
            draggableAnnotationController.onAnnotationDeleted(it.value)
        }
        annotations.clear()
        updateSource()
    }

    /**
     * Trigger an update to the underlying source. The update is delayed until after
     * the next UI draw to batch multiple actions.
     */
    fun updateSource() {
        // Only schedule a new refresh if not already scheduled
        if (isSourceUpToDate.compareAndSet(true, false)) {
            mapView.post {
                isSourceUpToDate.set(true)
                if (style.isFullyLoaded) {
                    updateSourceNow()
                } else {
                    // We are in progress of loading a new style
                    return@post
                }
            }
        }
    }

    /**
     * Undelayed source update, only used for testing and by [updateSource].
     */
    @VisibleForTesting
    internal fun updateSourceNow() {
        val features: List<Feature> = annotations.values.map {
            Feature.fromGeometry(
                it.geometry,
                it.dataDrivenProperties.nonDefaultMap().plus(PROPERTY_ID to it.id).asJsonObject()
            )
        }

        annotations.values.flatMap {
            it.dataDrivenProperties.nonDefaultMap().keys
        }
            .distinct()
            .minus(usedDataDrivenProperties.toSet())
            .also {
                usedDataDrivenProperties.addAll(it)
            }
            .map {
                generateDataDrivenPropertyExpression(it)
            }.forEach {
                // TODO here we could also add all properties at once, but this is not compatible with our tests as-is
                layer.setProperties(it)
            }

        geoJsonSource.setGeoJson(FeatureCollection.fromFeatures(features))
    }

    protected abstract fun generateDataDrivenPropertyExpression(property: String): PropertyValue<Expression>

    /*
     * The following six methods are `open` so that implementations can hint the autocompletion
     * to show the respective typealias instead of OnAnnotationDragListener<T> et al.
     */
    /**
     * Add a callback to be invoked when an annotation is dragged.
     *
     * @param d the callback to be invoked when an annotation is dragged
     */
    @UiThread
    open fun addDragListener(d: OnAnnotationDragListener<T>) {
        dragListeners.add(d)
    }

    /**
     * Remove a previously added callback that was to be invoked when an annotation has been dragged.
     *
     * @param d the callback to be removed
     */
    @UiThread
    open fun removeDragListener(d: OnAnnotationDragListener<T>) {
        dragListeners.remove(d)
    }

    /**
     * Add a callback to be invoked when a symbol has been clicked.
     *
     * @param u the callback to be invoked when a symbol is clicked
     */
    @UiThread
    open fun addClickListener(u: OnAnnotationClickListener<T>) {
        clickListeners.add(u)
    }

    /**
     * Remove a previously added callback that was to be invoked when symbol has been clicked.
     *
     * @param u the callback to be removed
     */
    @UiThread
    open fun removeClickListener(u: OnAnnotationClickListener<T>) {
        clickListeners.remove(u)
    }

    /**
     * Add a callback to be invoked when a symbol has been long clicked.
     *
     * @param v the callback to be invoked when a symbol is clicked
     */
    @UiThread
    open fun addLongClickListener(v: OnAnnotationLongClickListener<T>) {
        longClickListeners.add(v)
    }

    /**
     * Remove a previously added callback that was to be invoked when symbol has been long clicked.
     *
     * @param v the callback to be removed
     */
    @UiThread
    open fun removeLongClickListener(v: OnAnnotationLongClickListener<T>) {
        longClickListeners.remove(v)
    }

    @VisibleForTesting
    internal fun getClickListeners(): List<OnAnnotationClickListener<T>> {
        return clickListeners
    }

    @VisibleForTesting
    internal fun getLongClickListeners(): List<OnAnnotationLongClickListener<T>> {
        return longClickListeners
    }

    @JvmName("getDragListeners")
    internal fun getDragListeners(): List<OnAnnotationDragListener<T>> {
        return dragListeners
    }

    /**
     * Cleanup annotation manager by clearing listeners, removing all references to annotations,
     * and by removing the source from the style.
     */
    @UiThread
    fun onDestroy() {
        maplibreMap.removeOnMapClickListener(mapClickResolver)
        maplibreMap.removeOnMapLongClickListener(mapClickResolver)
        draggableAnnotationController.removeAnnotationManager(this)
        dragListeners.clear()
        clickListeners.clear()
        longClickListeners.clear()
        style.removeSource(geoJsonSource)
        style.removeLayer(layer)
        annotations.clear()
    }

    abstract fun setFilter(expression: Expression)

    private fun initializeSourcesAndLayers(geoJsonOptions: GeoJsonOptions?) {
        geoJsonSource = coreElementProvider.getSource(geoJsonOptions).also {
            style.addSource(it)
        }

        if (belowLayerId != null && aboveLayerId != null) {
            throw IllegalArgumentException(
                "At most one of belowLayerId and aboveLayerId can be set, not both!"
            )
        }

        layer = coreElementProvider.layer.also {
            if (belowLayerId != null) {
                style.addLayerBelow(it, belowLayerId)
            } else if (aboveLayerId != null) {
                style.addLayerAbove(it, aboveLayerId)
            } else {
                style.addLayer(it)
            }
        }

        layer.setProperties(*constantPropertyUsageMap.values.toTypedArray())
        layerFilter?.let {
            setFilter(it)
        }

        updateSource()
    }

    /**
     * Inner class for transforming map click events into annotation clicks
     */
    private inner class MapClickResolver : OnMapClickListener, OnMapLongClickListener {

        override fun onMapClick(point: LatLng): Boolean = if (clickListeners.isNotEmpty()) {
            queryMapForFeatures(point)?.let { annotation ->
                clickListeners.any { it.onAnnotationClick(annotation) }
            } ?: false
        } else {
            false
        }

        override fun onMapLongClick(point: LatLng): Boolean = if (longClickListeners.isNotEmpty()) {
            queryMapForFeatures(point)?.let { annotation ->
                longClickListeners.any { it.onAnnotationLongClick(annotation) }
            } ?: false
        } else {
            false
        }
    }

    private fun queryMapForFeatures(point: LatLng): T? =
        queryMapForFeatures(maplibreMap.projection.toScreenLocation(point))

    fun queryMapForFeatures(point: PointF): T? =
        maplibreMap.queryRenderedFeatures(point, coreElementProvider.layerId).firstOrNull()?.let { feature ->
            val id = feature.getProperty(PROPERTY_ID).asLong
            annotations[id]
        }

    companion object {
        private const val TAG = "AnnotationManager"
        const val PROPERTY_ID = "id"
    }
}
